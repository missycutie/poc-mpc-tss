import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { get, post } from '@toruslabs/http-helpers';
import deepmerge from 'deepmerge';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import base64url from 'base64url';
import Bowser from 'bowser';
import log$1 from 'loglevel';
import { EventEmitter } from 'events';
import { SessionManager } from '@toruslabs/session-manager';
import { NodeDetailManager } from '@toruslabs/fetch-node-details';
import { Torus, keccak256 as keccak256$1 } from '@toruslabs/torus.js';
import { register } from '@chaitanyapotti/register-service-worker';
import { getPublic, sign } from '@toruslabs/eccrypto';
import { keccak256, encryptData, decryptData } from '@toruslabs/metadata-helpers';

const LOGIN = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  GITHUB: "github",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  LINE: "line",
  EMAIL_PASSWORD: "email_password",
  PASSWORDLESS: "passwordless",
  EMAIL_PASSWORDLESS: "email_passwordless",
  SMS_PASSWORDLESS: "sms_passwordless",
  JWT: "jwt",
  PASSKEYS: "passkeys"
};
const AGGREGATE_VERIFIER = {
  SINGLE_VERIFIER_ID: "single_id_verifier"
  // AND_AGGREGATE_VERIFIER : "and_aggregate_verifier",
  // OR_AGGREGATE_VERIFIER : "or_aggregate_verifier",
};
const UX_MODE = {
  POPUP: "popup",
  REDIRECT: "redirect"
};
const REDIRECT_PARAMS_STORAGE_METHOD = {
  LOCAL_STORAGE: "localStorage",
  SESSION_STORAGE: "sessionStorage",
  SERVER: "server"
};
const TORUS_METHOD = {
  TRIGGER_LOGIN: "triggerLogin",
  TRIGGER_AGGREGATE_LOGIN: "triggerAggregateLogin"
};
const SENTRY_TXNS = {
  FETCH_NODE_DETAILS: "fetchNodeDetails",
  PUB_ADDRESS_LOOKUP: "pubAddressLookup",
  FETCH_SHARES: "fetchShares"
};

var log = log$1.getLogger("customauth");

function eventToPromise(emitter) {
  return new Promise((resolve, reject) => {
    const handler = ev => {
      const {
        error = "",
        data
      } = ev;
      emitter.removeEventListener("message", handler);
      if (error) return reject(new Error(error));
      return resolve(data);
    };
    emitter.addEventListener("message", handler);
  });
}

// These are the default connection names used by auth0
const loginToConnectionMap = {
  [LOGIN.APPLE]: "apple",
  [LOGIN.GITHUB]: "github",
  [LOGIN.LINKEDIN]: "linkedin",
  [LOGIN.TWITTER]: "twitter",
  [LOGIN.WEIBO]: "weibo",
  [LOGIN.LINE]: "line",
  [LOGIN.EMAIL_PASSWORD]: "Username-Password-Authentication",
  [LOGIN.PASSWORDLESS]: "email",
  [LOGIN.EMAIL_PASSWORDLESS]: "email",
  [LOGIN.SMS_PASSWORDLESS]: "sms"
};
const padUrlString = url => url.href.endsWith("/") ? url.href : `${url.href}/`;

/**
 * Returns a random number. Don't use for cryptographic purposes.
 * @returns a random number
 */
const randomId = () => Math.random().toString(36).slice(2);
const broadcastChannelOptions = {
  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']
  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)
};
function caseSensitiveField(field, isCaseSensitive) {
  return isCaseSensitive ? field : field.toLowerCase();
}
const getVerifierId = (userInfo, typeOfLogin, verifierIdField, isVerifierIdCaseSensitive = true) => {
  const {
    name,
    sub
  } = userInfo;
  if (verifierIdField) return caseSensitiveField(userInfo[verifierIdField], isVerifierIdCaseSensitive);
  switch (typeOfLogin) {
    case LOGIN.PASSWORDLESS:
    case LOGIN.EMAIL_PASSWORD:
    case LOGIN.EMAIL_PASSWORDLESS:
    case LOGIN.SMS_PASSWORDLESS:
      return caseSensitiveField(name, isVerifierIdCaseSensitive);
    case LOGIN.WEIBO:
    case LOGIN.GITHUB:
    case LOGIN.TWITTER:
    case LOGIN.APPLE:
    case LOGIN.LINKEDIN:
    case LOGIN.LINE:
    case LOGIN.JWT:
      return caseSensitiveField(sub, isVerifierIdCaseSensitive);
    default:
      throw new Error("Invalid login type to get verifier id");
  }
};
const handleRedirectParameters = (hash, queryParameters) => {
  const hashParameters = hash.split("&").reduce((result, item) => {
    const [part0, part1] = item.split("=");
    result[part0] = part1;
    return result;
  }, {});
  log.info(hashParameters, queryParameters);
  let instanceParameters = {};
  let error = "";
  if (Object.keys(hashParameters).length > 0 && hashParameters.state) {
    instanceParameters = JSON.parse(base64url.decode(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};
    error = hashParameters.error_description || hashParameters.error || error;
  } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {
    instanceParameters = JSON.parse(base64url.decode(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};
    if (queryParameters.error) error = queryParameters.error;
  }
  return {
    error,
    instanceParameters,
    hashParameters
  };
};
function storageAvailable(type) {
  let storage;
  try {
    storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    const e = error;
    return e && (
    // everything except Firefox
    e.code === 22 ||
    // Firefox
    e.code === 1014 ||
    // test name field too, because code might not be present
    // everything except Firefox
    e.name === "QuotaExceededError" ||
    // Firefox
    e.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
    // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0;
  }
}
function getPopupFeatures() {
  // Fixes dual-screen position                             Most browsers      Firefox
  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
  const w = 1200;
  const h = 700;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1; // No reliable estimate

  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
  return features;
}
const isFirefox = () => {
  var _window;
  return ((_window = window) === null || _window === void 0 || (_window = _window.navigator) === null || _window === void 0 ? void 0 : _window.userAgent.toLowerCase().indexOf("firefox")) > -1 || false;
};
function constructURL(params) {
  const {
    baseURL,
    query,
    hash
  } = params;
  const url = new URL(baseURL);
  if (query) {
    Object.keys(query).forEach(key => {
      url.searchParams.append(key, query[key]);
    });
  }
  if (hash) {
    const h = new URL(constructURL({
      baseURL,
      query: hash
    })).searchParams.toString();
    url.hash = h;
  }
  return url.toString();
}
function are3PCSupported() {
  var _navigator;
  const browserInfo = Bowser.parse(navigator.userAgent);
  log.info(JSON.stringify(browserInfo), "current browser info");
  let thirdPartyCookieSupport = true;
  // brave
  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {
    thirdPartyCookieSupport = false;
  }
  // All webkit & gecko engine instances use itp (intelligent tracking prevention -
  // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)
  if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {
    thirdPartyCookieSupport = false;
  }
  return thirdPartyCookieSupport;
}
const validateAndConstructUrl = domain => {
  try {
    const url = new URL(decodeURIComponent(domain));
    return url;
  } catch (error) {
    throw new Error(`${(error === null || error === void 0 ? void 0 : error.message) || ""}, Note: Your jwt domain: (i.e ${domain}) must have http:// or https:// prefix`);
  }
};
function isMobileOrTablet() {
  const browser = Bowser.getParser(navigator.userAgent);
  const platform = browser.getPlatform();
  return platform.type === Bowser.PLATFORMS_MAP.tablet || platform.type === Bowser.PLATFORMS_MAP.mobile;
}
function getTimeout(typeOfLogin) {
  if ((typeOfLogin === LOGIN.FACEBOOK || typeOfLogin === LOGIN.LINE) && isMobileOrTablet()) {
    return 1000 * 60; // 60 seconds to finish the login
  }
  return 1000 * 10; // 10 seconds
}
function decodeToken(token) {
  const [header, payload] = token.split(".");
  return {
    header: JSON.parse(base64url.decode(header)),
    payload: JSON.parse(base64url.decode(payload))
  };
}

class PopupHandler extends EventEmitter {
  constructor({
    url,
    target,
    features,
    timeout = 30000
  }) {
    // eslint-disable-next-line constructor-super
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    _defineProperty(this, "timeout", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures();
    this.window = undefined;
    this.windowTimer = undefined;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = undefined;
        }, this.timeout);
      }
      if (this.window === undefined) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url.href, this.target, this.features);
    if (!this.window) throw new Error("popup window is blocked");
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
    return Promise.resolve();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url.href);
    } else {
      window.location.href = this.url.href;
    }
  }
}

const _excluded$2 = ["access_token", "id_token"];
class AbstractLoginHandler {
  // Not using object constructor because of this issue
  // https://github.com/microsoft/TypeScript/issues/5326
  constructor(params) {
    _defineProperty(this, "nonce", randomId());
    _defineProperty(this, "finalURL", void 0);
    _defineProperty(this, "params", void 0);
    this.params = params;
  }
  get state() {
    return encodeURIComponent(base64url.encode(JSON.stringify(_objectSpread(_objectSpread({}, this.params.customState || {}), {}, {
      instanceId: this.nonce,
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin,
      redirectToOpener: this.params.redirectToOpener || false
    }))));
  }
  async handleLoginWindow(params) {
    const verifierWindow = new PopupHandler({
      url: this.finalURL,
      features: params.popupFeatures,
      timeout: getTimeout(this.params.typeOfLogin)
    });
    if (this.params.uxMode === UX_MODE.REDIRECT) {
      verifierWindow.redirect(params.locationReplaceOnRedirect);
    } else {
      const {
        BroadcastChannel
      } = await import('@toruslabs/broadcast-channel');
      return new Promise((resolve, reject) => {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let bc;
        const handleData = async ev => {
          try {
            const {
              error,
              data
            } = ev;
            const _ref = data || {},
              {
                instanceParams,
                hashParams: {
                  access_token: accessToken,
                  id_token: idToken
                }
              } = _ref,
              rest = _objectWithoutProperties(_ref.hashParams, _excluded$2);
            if (error) {
              log.error(ev);
              reject(new Error(`Error: ${error}. Info: ${JSON.stringify(ev.data || {})}`));
              return;
            }
            if (ev.data && instanceParams.verifier === this.params.verifier) {
              log.info(ev.data);
              if (!this.params.redirectToOpener && bc) await bc.postMessage({
                success: true
              });
              resolve(_objectSpread(_objectSpread({
                accessToken,
                idToken: idToken || ""
              }, rest), {}, {
                // State has to be last here otherwise it will be overwritten
                state: instanceParams
              }));
            }
          } catch (error) {
            log.error(error);
            reject(error);
          }
        };
        if (!this.params.redirectToOpener) {
          bc = new BroadcastChannel(`redirect_channel_${this.nonce}`, broadcastChannelOptions);
          bc.addEventListener("message", async ev => {
            await handleData(ev);
            bc.close();
            verifierWindow.close();
          });
        } else {
          const postMessageEventHandler = async postMessageEvent => {
            if (!postMessageEvent.data) return;
            const ev = postMessageEvent.data;
            if (ev.channel !== `redirect_channel_${this.nonce}`) return;
            window.removeEventListener("message", postMessageEventHandler);
            handleData(ev);
            verifierWindow.close();
          };
          window.addEventListener("message", postMessageEventHandler);
        }
        try {
          verifierWindow.open();
        } catch (error) {
          log.error(error);
          reject(error);
          return;
        }
        verifierWindow.once("close", () => {
          if (bc) bc.close();
          reject(new Error("user closed popup"));
        });
      });
    }
    return null;
  }
}

class DiscordHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token");
    _defineProperty(this, "SCOPE", "identify email");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://discord.com/api/oauth2/authorize");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = deepmerge({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://discord.com/api/users/@me", {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });
    const {
      id,
      avatar,
      email = "",
      username: name = "",
      discriminator = ""
    } = userInfo;
    const profileImage = avatar === null ? `https://cdn.discordapp.com/embed/avatars/${Number(discriminator) % 5}.png` : `https://cdn.discordapp.com/avatars/${id}/${avatar}.png?size=2048`;
    return {
      profileImage,
      name: `${name}#${discriminator}`,
      email,
      verifierId: id,
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin
    };
  }
}

class FacebookHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token");
    _defineProperty(this, "SCOPE", "public_profile email");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://www.facebook.com/v20.0/dialog/oauth");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = deepmerge({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://graph.facebook.com/me?fields=name,email,picture.type(large)", {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });
    const {
      name = "",
      id,
      picture,
      email = ""
    } = userInfo;
    return {
      email,
      name,
      profileImage: picture.data.url || "",
      verifier: this.params.verifier,
      verifierId: id,
      typeOfLogin: this.params.typeOfLogin
    };
  }
}

class GoogleHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "SCOPE", "profile email openid");
    _defineProperty(this, "PROMPT", "select_account");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://accounts.google.com/o/oauth2/v2/auth");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = deepmerge({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      prompt: this.PROMPT,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE,
      nonce: this.nonce
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://www.googleapis.com/userinfo/v2/me", {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });
    const {
      picture: profileImage = "",
      email = "",
      name = ""
    } = userInfo;
    return {
      email,
      name,
      profileImage,
      verifier: this.params.verifier,
      verifierId: email.toLowerCase(),
      typeOfLogin: this.params.typeOfLogin
    };
  }
}

class JwtHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "SCOPE", "openid profile email");
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "PROMPT", "login");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      domain
    } = this.params.jwtParams;
    const finalUrl = validateAndConstructUrl(domain);
    finalUrl.pathname += finalUrl.pathname.endsWith("/") ? "authorize" : "/authorize";
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams));
    delete clonedParams.domain;
    const finalJwtParams = deepmerge({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      prompt: this.PROMPT,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE,
      connection: loginToConnectionMap[this.params.typeOfLogin],
      nonce: this.nonce
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      idToken,
      accessToken
    } = params;
    const {
      domain,
      verifierIdField,
      isVerifierIdCaseSensitive,
      user_info_route = "userinfo"
    } = this.params.jwtParams;
    if (accessToken) {
      try {
        const domainUrl = new URL(domain);
        const userInfo = await get(`${padUrlString(domainUrl)}${user_info_route}`, {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        });
        const {
          picture,
          name,
          email
        } = userInfo;
        return {
          email,
          name,
          profileImage: picture,
          verifierId: getVerifierId(userInfo, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
          verifier: this.params.verifier,
          typeOfLogin: this.params.typeOfLogin
        };
      } catch (error) {
        // ignore
        log$1.warn(error, "Unable to get userinfo from endpoint");
      }
    }
    if (idToken) {
      const decodedToken = decodeToken(idToken).payload;
      const {
        name,
        email,
        picture
      } = decodedToken;
      return {
        profileImage: picture,
        name,
        email,
        verifierId: getVerifierId(decodedToken, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    }
    throw new Error("Access/id token not available");
  }
}

class MockLoginHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    this.setFinalUrl();
  }
  setFinalUrl() {
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams));
    delete clonedParams.domain;
    const finalJwtParams = deepmerge({
      state: this.state,
      client_id: this.params.clientId,
      nonce: this.nonce
    }, clonedParams);
    this.finalURL = new URL(constructURL({
      baseURL: this.params.redirect_uri,
      query: null,
      hash: finalJwtParams
    }));
  }
  async getUserInfo(params) {
    const {
      idToken,
      accessToken
    } = params;
    const {
      domain,
      verifierIdField,
      isVerifierIdCaseSensitive,
      user_info_route = "userinfo"
    } = this.params.jwtParams;
    if (accessToken) {
      try {
        const domainUrl = new URL(domain);
        const userInfo = await get(`${padUrlString(domainUrl)}${user_info_route}`, {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        });
        const {
          picture,
          name,
          email
        } = userInfo;
        return {
          email,
          name,
          profileImage: picture,
          verifierId: getVerifierId(userInfo, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
          verifier: this.params.verifier,
          typeOfLogin: this.params.typeOfLogin
        };
      } catch (error) {
        // ignore
        log$1.warn(error, "Unable to get userinfo from endpoint");
      }
    }
    if (idToken) {
      const decodedToken = decodeToken(idToken).payload;
      const {
        name,
        email,
        picture
      } = decodedToken;
      return {
        profileImage: picture,
        name,
        email,
        verifierId: getVerifierId(decodedToken, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    }
    throw new Error("Access/id token not available");
  }
  handleLoginWindow(params) {
    const {
      id_token: idToken,
      access_token: accessToken
    } = this.params.jwtParams;
    const verifierWindow = new PopupHandler({
      url: this.finalURL,
      features: params.popupFeatures
    });
    if (this.params.uxMode === UX_MODE.REDIRECT) {
      verifierWindow.redirect(params.locationReplaceOnRedirect);
    } else {
      return Promise.resolve({
        state: {},
        idToken,
        accessToken
      });
    }
    return null;
  }
}

async function fetchDataFromBroadcastServer(identifier, storageServerUrl) {
  try {
    const configManager = new SessionManager({
      sessionId: identifier,
      sessionServerBaseUrl: storageServerUrl,
      allowedOrigin: true
    });
    const data = await configManager.authorizeSession();
    return data;
  } catch (error) {
    log$1.error("fetch data from storage server error", error);
    throw new Error("Unable to retrieve data from storage server, invalid key or key expired.");
  }
}

class PasskeysHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      passkeysHostUrl
    } = this.params.customState || {};
    if (!passkeysHostUrl) throw new Error("Invalid passkeys url.");
    const finalUrl = new URL(passkeysHostUrl);
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = deepmerge({
      state: this.state,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(parameters, storageServerUrl) {
    const {
      idToken,
      extraParams
    } = parameters;
    const {
      sessionId
    } = JSON.parse(base64url.decode(extraParams)) || {};
    if (!sessionId) {
      throw new Error("sessionId not found");
    }
    const {
      verifier_id: verifierId,
      signature,
      clientDataJSON,
      authenticatorData,
      publicKey,
      challenge,
      rpOrigin,
      rpId,
      credId,
      transports,
      username
    } = await fetchDataFromBroadcastServer(sessionId, storageServerUrl);
    if (signature !== idToken) {
      throw new Error("idtoken should be equal to signature");
    }
    return {
      email: "",
      name: "Passkeys Login",
      profileImage: "",
      verifier: this.params.verifier,
      verifierId,
      typeOfLogin: this.params.typeOfLogin,
      extraVerifierParams: {
        signature,
        clientDataJSON,
        authenticatorData,
        publicKey,
        challenge,
        rpOrigin,
        rpId,
        credId,
        transports,
        username
      }
    };
  }
}

const _excluded$1 = ["access_token", "id_token"];
class PasswordlessHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "SCOPE", "openid profile email");
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "PROMPT", "login");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      domain
    } = this.params.jwtParams;
    const domainUrl = validateAndConstructUrl(domain);
    domainUrl.pathname = "/passwordless/start";
    this.finalURL = domainUrl;
  }
  async getUserInfo(params) {
    const {
      idToken,
      accessToken
    } = params;
    const {
      domain,
      verifierIdField,
      isVerifierIdCaseSensitive
    } = this.params.jwtParams;
    try {
      const domainUrl = new URL(domain);
      const userInfo = await get(`${padUrlString(domainUrl)}userinfo`, {
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      });
      const {
        picture,
        name,
        email
      } = userInfo;
      return {
        email,
        name,
        profileImage: picture,
        verifierId: getVerifierId(userInfo, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    } catch (error) {
      log.error(error);
      const decodedToken = decodeToken(idToken).payload;
      const {
        name,
        email,
        picture
      } = decodedToken;
      return {
        profileImage: picture,
        name,
        email,
        verifierId: getVerifierId(decodedToken, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    }
  }
  async handleLoginWindow() {
    const {
      BroadcastChannel
    } = await import('@toruslabs/broadcast-channel');
    return new Promise((resolve, reject) => {
      if (this.params.redirectToOpener) {
        reject(new Error("Cannot use redirect to opener for passwordless"));
        return;
      }
      const handleData = ev => {
        try {
          const {
            error,
            data
          } = ev;
          const _ref = data || {},
            {
              instanceParams,
              hashParams: {
                access_token: accessToken,
                id_token: idToken
              }
            } = _ref,
            rest = _objectWithoutProperties(_ref.hashParams, _excluded$1);
          if (error) {
            log.error(ev.error);
            reject(new Error(error));
            return;
          }
          if (ev.data && instanceParams.verifier === this.params.verifier) {
            log.info(ev.data);
            resolve(_objectSpread(_objectSpread({
              accessToken,
              idToken: idToken || ""
            }, rest), {}, {
              state: instanceParams
            }));
          }
        } catch (error) {
          log.error(error);
          reject(error);
        }
      };
      const bc = new BroadcastChannel(`redirect_channel_${this.nonce}`, broadcastChannelOptions);
      bc.addEventListener("message", async ev => {
        handleData(ev);
        bc.close();
      });
      try {
        const {
          connection = "email",
          login_hint
        } = this.params.jwtParams;
        const finalJwtParams = deepmerge({
          client_id: this.params.clientId,
          connection,
          email: connection === "email" ? login_hint : undefined,
          phone_number: connection === "sms" ? login_hint : undefined,
          send: "link",
          authParams: {
            scope: this.SCOPE,
            state: this.state,
            response_type: this.RESPONSE_TYPE,
            redirect_uri: this.params.redirect_uri,
            nonce: this.nonce,
            prompt: this.PROMPT
          }
        }, {
          authParams: this.params.jwtParams
        });
        // using stringify and parse to remove undefined params
        // This method is only resolved when the user clicks the email link
        post(this.finalURL.href, JSON.parse(JSON.stringify(finalJwtParams))).then(response => {
          log.info("posted", response);
          return undefined;
        }).catch(error => {
          log.error(error);
          reject(error);
        });
      } catch (error) {
        log.error(error);
        reject(error);
      }
    });
  }
}

class TwitchHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token");
    _defineProperty(this, "SCOPE", "user:read:email");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://id.twitch.tv/oauth2/authorize");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = deepmerge({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE,
      force_verify: "true"
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://api.twitch.tv/helix/users", {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Client-ID": this.params.clientId
      }
    });
    const [{
      profile_image_url: profileImage = "",
      display_name: name = "",
      email = "",
      id: verifierId
    }] = userInfo.data || [];
    return {
      profileImage,
      name,
      email,
      verifierId,
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin
    };
  }
}

// REGION: AUTH0 PARAMS

const EMAIL_FLOW = {
  link: "link",
  code: "code"
};

class Web3AuthPasswordlessHandler extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "SCOPE", "openid profile email");
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "PROMPT", "login");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      domain
    } = this.params.jwtParams || {};
    const finalUrl = validateAndConstructUrl(domain || "https://passwordless.web3auth.io/v6");
    finalUrl.pathname += finalUrl.pathname.endsWith("/") ? "authorize" : "/authorize";
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    delete clonedParams.domain;
    this.params.customState = _objectSpread(_objectSpread({}, this.params.customState || {}), {}, {
      client: this.params.web3AuthClientId
    });
    const finalJwtParams = deepmerge({
      state: this.state,
      client_id: this.params.clientId || this.params.web3AuthClientId,
      redirect_uri: this.params.redirect_uri,
      nonce: this.nonce,
      network: this.params.web3AuthNetwork,
      connection: loginToConnectionMap[this.params.typeOfLogin],
      scope: this.SCOPE,
      response_type: this.RESPONSE_TYPE,
      prompt: this.PROMPT,
      flow_type: (clonedParams === null || clonedParams === void 0 ? void 0 : clonedParams.flow_type) || EMAIL_FLOW.code
    }, clonedParams);
    Object.keys(finalJwtParams).forEach(key => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      idToken
    } = params;
    const decodedToken = decodeToken(idToken).payload;
    const {
      name,
      email,
      picture
    } = decodedToken;
    return {
      profileImage: picture,
      name,
      email,
      verifierId: name.toLowerCase(),
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin
    };
  }
}

const createHandler = params => {
  const {
    verifier,
    typeOfLogin,
    clientId,
    jwtParams
  } = params;
  if (!verifier || !typeOfLogin || !clientId) {
    throw new Error("Invalid params. Missing verifier, typeOfLogin or clientId");
  }
  const {
    domain,
    login_hint,
    id_token,
    access_token
  } = jwtParams || {};
  switch (typeOfLogin) {
    case LOGIN.GOOGLE:
      return new GoogleHandler(params);
    case LOGIN.FACEBOOK:
      return new FacebookHandler(params);
    case LOGIN.TWITCH:
      return new TwitchHandler(params);
    case LOGIN.DISCORD:
      return new DiscordHandler(params);
    case LOGIN.EMAIL_PASSWORDLESS:
    case LOGIN.SMS_PASSWORDLESS:
      if (!login_hint) throw new Error("Invalid params. Missing login_hint for web3auth passwordless login");
      return new Web3AuthPasswordlessHandler(params);
    case LOGIN.PASSWORDLESS:
      if (!domain || !login_hint) throw new Error("Invalid params. Missing domain or login_hint for passwordless login");
      return new PasswordlessHandler(params);
    case LOGIN.APPLE:
    case LOGIN.GITHUB:
    case LOGIN.LINKEDIN:
    case LOGIN.TWITTER:
    case LOGIN.WEIBO:
    case LOGIN.LINE:
    case LOGIN.EMAIL_PASSWORD:
    case LOGIN.JWT:
    case LOGIN.REDDIT:
      if (id_token || access_token) {
        return new MockLoginHandler(params);
      }
      if (!domain) throw new Error("Invalid params for jwt login. Missing domain");
      return new JwtHandler(params);
    case LOGIN.PASSKEYS:
      return new PasskeysHandler(params);
    default:
      throw new Error("Unsupported login type");
  }
};
var createHandler$1 = createHandler;

const registerServiceWorker = baseUrl => new Promise((resolve, reject) => {
  const swUrl = `${baseUrl}sw.js`;
  if ("serviceWorker" in window.navigator) {
    // if swIntegrity is not calculated
    register(swUrl, {
      ready() {
        log.info("App is being served from cache by a service worker.\n For more details, visit https://goo.gl/AFskqB");
        resolve(undefined);
      },
      registered() {
        log.info("Service worker has been registered.");
        resolve(undefined);
      },
      cached() {
        log.info("Content has been cached for offline use.");
        resolve(undefined);
      },
      updatefound() {
        log.info("New content is downloading.");
      },
      updated() {
        log.info("New content is available; please refresh.");
      },
      offline() {
        log.info("No internet connection found. App is running in offline mode.");
        reject(new Error("App is offline"));
      },
      error(error) {
        log.error("Error during service worker registration:", error);
        reject(error);
      }
    });
  } else {
    reject(new Error("Service workers are not supported"));
  }
});

class SentryHandler {
  constructor(sentry) {
    _defineProperty(this, "sentry", null);
    this.sentry = sentry;
  }
  startSpan(context, callback) {
    if (this.sentry) {
      return this.sentry.startSpan(context, callback);
    }
    return callback(null);
  }
}

const serializeError = async error => {
  // Find first Error or create an "unknown" Error to keep stack trace.
  const isError = error instanceof Error;
  const isString = typeof error === "string";
  const isApiErrorIndex = error && typeof error === "object" && "status" in error && "type" in error;
  let err;
  if (isApiErrorIndex) {
    const apiError = error;
    const contentType = apiError.headers.get("content-type");
    if (contentType.includes("application/json")) {
      const errJson = await apiError.json();
      err = new Error((errJson === null || errJson === void 0 ? void 0 : errJson.error) || (errJson === null || errJson === void 0 ? void 0 : errJson.message) || JSON.stringify(errJson));
    } else if (contentType.includes("text/plain")) {
      err = new Error(await apiError.text());
    } else {
      err = new Error(`${apiError.status} ${apiError.type.toString()} ${apiError.statusText}`);
    }
  } else if (isString) {
    err = new Error(error);
  } else if (isError) {
    err = error;
  } else {
    err = new Error("Unknown error");
  }
  return err;
};

class StorageHelper {
  constructor(serverUrl) {
    _defineProperty(this, "currentStorageMethod", REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "storageServerUrl", "https://session.web3auth.io");
    _defineProperty(this, "localStorageAvailable", true);
    this.storageServerUrl = serverUrl;
  }
  get storageMethodUsed() {
    return this.currentStorageMethod;
  }
  init() {
    const support = are3PCSupported();
    const localStorageAvailable = storageAvailable(REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE);
    this.localStorageAvailable = localStorageAvailable;
    if (support && localStorageAvailable) {
      // use local storage as default for storing stuff
      this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE;
    } else {
      // use server store as default for storing stuff
      this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.SERVER;
    }
    this.isInitialized = true;
  }
  async storeLoginDetails(params, scope) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.currentStorageMethod === REDIRECT_PARAMS_STORAGE_METHOD.SERVER) {
      const privKey = keccak256(Buffer.from(scope, "utf8"));
      const privKeyHex = privKey.toString("hex");
      const publicKeyHex = getPublic(privKey).toString("hex");
      const encData = await encryptData(privKeyHex, params);
      const signature = (await sign(privKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex");
      await post(`${this.storageServerUrl}/store/set`, {
        key: publicKeyHex,
        data: encData,
        signature
      });
    }
    if (this.localStorageAvailable) window.localStorage.setItem(`torus_login_${scope}`, JSON.stringify(params));
  }
  async retrieveLoginDetails(scope) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.localStorageAvailable) {
      const loginDetails = window.localStorage.getItem(`torus_login_${scope}`);
      if (loginDetails) return JSON.parse(loginDetails || "{}");
    }
    if (this.currentStorageMethod === REDIRECT_PARAMS_STORAGE_METHOD.SERVER) {
      const privKey = keccak256(Buffer.from(scope, "utf8"));
      const privKeyHex = privKey.toString("hex");
      const publicKeyHex = getPublic(privKey).toString("hex");
      try {
        const encData = await get(`${this.storageServerUrl}/store/get?key=${publicKeyHex}`);
        if (encData.message) {
          const currentLoginDetails = await decryptData(privKeyHex, encData.message);
          return currentLoginDetails;
        }
      } catch (error) {
        if (error.status === 404) {
          log.warn(error, "Session likely expired");
        } else {
          throw error;
        }
      }
    }
  }
  clearLoginDetailsStorage(scope) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.localStorageAvailable) window.localStorage.removeItem(`torus_login_${scope}`);
    // No need to clear server details cause they auto expire and scope is never re-used for different login attempts
  }
  clearOrphanedLoginDetails() {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (!this.localStorageAvailable) return;
    const allStorageKeys = Object.keys(window.localStorage);
    allStorageKeys.forEach(key => {
      if (key.startsWith("torus_login_")) {
        window.localStorage.removeItem(key);
      }
    });
    // No need to clear server details cause they auto expire and scope is never re-used for different login attempts
  }
}

const _excluded = ["access_token", "id_token"],
  _excluded2 = ["access_token", "id_token"],
  _excluded3 = ["args", "method"];
class CustomAuth {
  constructor({
    baseUrl,
    network,
    enableLogging = false,
    redirectToOpener = false,
    redirectPathName = "redirect",
    apiKey = "torus-default",
    uxMode = UX_MODE.POPUP,
    locationReplaceOnRedirect = false,
    popupFeatures,
    storageServerUrl = "https://session.web3auth.io",
    sentry,
    enableOneKey = false,
    web3AuthClientId,
    useDkg,
    metadataUrl = "https://metadata.tor.us",
    keyType = "secp256k1",
    serverTimeOffset = 0,
    nodeDetails,
    checkCommitment = true
  }) {
    _defineProperty(this, "isInitialized", void 0);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "torus", void 0);
    _defineProperty(this, "nodeDetailManager", void 0);
    _defineProperty(this, "storageHelper", void 0);
    _defineProperty(this, "sentryHandler", void 0);
    if (!web3AuthClientId) throw new Error("Please provide a valid web3AuthClientId in constructor");
    if (!network) throw new Error("Please provide a valid network in constructor");
    this.isInitialized = false;
    const baseUri = new URL(baseUrl);
    this.config = {
      baseUrl: padUrlString(baseUri),
      get redirect_uri() {
        return `${this.baseUrl}${redirectPathName}`;
      },
      redirectToOpener,
      uxMode,
      locationReplaceOnRedirect,
      popupFeatures,
      useDkg,
      web3AuthClientId,
      web3AuthNetwork: network,
      keyType,
      nodeDetails,
      checkCommitment
    };
    const torus = new Torus({
      network,
      enableOneKey,
      serverTimeOffset,
      clientId: web3AuthClientId,
      legacyMetadataHost: metadataUrl,
      keyType
    });
    Torus.setAPIKey(apiKey);
    this.torus = torus;
    this.nodeDetailManager = new NodeDetailManager({
      network
    });
    if (enableLogging) log.enableAll();else log.disableAll();
    this.storageHelper = new StorageHelper(storageServerUrl);
    this.sentryHandler = new SentryHandler(sentry);
  }
  async init({
    skipSw = false,
    skipInit = false,
    skipPrefetch = false
  } = {}) {
    this.storageHelper.init();
    if (skipInit) {
      this.isInitialized = true;
      return;
    }
    if (!skipSw) {
      const fetchSwResponse = await fetch(`${this.config.baseUrl}sw.js`, {
        cache: "reload"
      });
      if (fetchSwResponse.ok) {
        try {
          await registerServiceWorker(this.config.baseUrl);
          this.isInitialized = true;
          return;
        } catch (error) {
          log.warn(error);
        }
      } else {
        throw new Error("Service worker is not being served. Please serve it");
      }
    }
    if (!skipPrefetch) {
      // Skip the redirect check for firefox
      if (isFirefox()) {
        this.isInitialized = true;
        return;
      }
      await this.handlePrefetchRedirectUri();
      return;
    }
    this.isInitialized = true;
  }
  async triggerLogin(args) {
    const {
      verifier,
      typeOfLogin,
      clientId,
      jwtParams,
      hash,
      queryParameters,
      customState
    } = args;
    log.info("Verifier: ", verifier);
    if (!this.isInitialized) {
      throw new Error("Not initialized yet");
    }
    const loginHandler = createHandler$1({
      typeOfLogin,
      clientId,
      verifier,
      redirect_uri: this.config.redirect_uri,
      redirectToOpener: this.config.redirectToOpener,
      jwtParams,
      uxMode: this.config.uxMode,
      customState,
      web3AuthClientId: this.config.web3AuthClientId,
      web3AuthNetwork: this.config.web3AuthNetwork
    });
    let loginParams;
    if (hash && queryParameters) {
      const {
        error,
        hashParameters,
        instanceParameters
      } = handleRedirectParameters(hash, queryParameters);
      if (error) throw new Error(error);
      const {
          access_token: accessToken,
          id_token: idToken
        } = hashParameters,
        rest = _objectWithoutProperties(hashParameters, _excluded);
      // State has to be last here otherwise it will be overwritten
      loginParams = _objectSpread(_objectSpread({
        accessToken,
        idToken
      }, rest), {}, {
        state: instanceParameters
      });
    } else {
      this.storageHelper.clearOrphanedLoginDetails();
      if (this.config.uxMode === UX_MODE.REDIRECT) {
        await this.storageHelper.storeLoginDetails({
          method: TORUS_METHOD.TRIGGER_LOGIN,
          args
        }, loginHandler.nonce);
      }
      loginParams = await loginHandler.handleLoginWindow({
        locationReplaceOnRedirect: this.config.locationReplaceOnRedirect,
        popupFeatures: this.config.popupFeatures
      });
      if (this.config.uxMode === UX_MODE.REDIRECT) return null;
    }
    const userInfo = await loginHandler.getUserInfo(loginParams);
    const torusKey = await this.getTorusKey(verifier, userInfo.verifierId, {
      verifier_id: userInfo.verifierId
    }, loginParams.idToken || loginParams.accessToken, userInfo.extraVerifierParams);
    return _objectSpread(_objectSpread({}, torusKey), {}, {
      userInfo: _objectSpread(_objectSpread({}, userInfo), loginParams)
    });
  }
  async triggerAggregateLogin(args) {
    // This method shall break if any of the promises fail. This behaviour is intended
    const {
      aggregateVerifierType,
      verifierIdentifier,
      subVerifierDetailsArray
    } = args;
    if (!this.isInitialized) {
      throw new Error("Not initialized yet");
    }
    if (!aggregateVerifierType || !verifierIdentifier || !Array.isArray(subVerifierDetailsArray)) {
      throw new Error("Invalid params. Missing aggregateVerifierType, verifierIdentifier or subVerifierDetailsArray");
    }
    if (aggregateVerifierType === AGGREGATE_VERIFIER.SINGLE_VERIFIER_ID && subVerifierDetailsArray.length !== 1) {
      throw new Error("Single id verifier can only have one sub verifier");
    }
    const userInfoPromises = [];
    const loginParamsArray = [];
    for (const subVerifierDetail of subVerifierDetailsArray) {
      const {
        clientId,
        typeOfLogin,
        verifier,
        jwtParams,
        hash,
        queryParameters,
        customState
      } = subVerifierDetail;
      const loginHandler = createHandler$1({
        typeOfLogin,
        clientId,
        verifier,
        redirect_uri: this.config.redirect_uri,
        redirectToOpener: this.config.redirectToOpener,
        jwtParams,
        uxMode: this.config.uxMode,
        customState,
        web3AuthClientId: this.config.web3AuthClientId,
        web3AuthNetwork: this.config.web3AuthNetwork
      });
      // We let the user login to each verifier in a loop. Don't wait for key derivation here.!
      let loginParams;
      if (hash && queryParameters) {
        const {
          error,
          hashParameters,
          instanceParameters
        } = handleRedirectParameters(hash, queryParameters);
        if (error) throw new Error(error);
        const {
            access_token: accessToken,
            id_token: idToken
          } = hashParameters,
          rest = _objectWithoutProperties(hashParameters, _excluded2);
        // State has to be last here otherwise it will be overwritten
        loginParams = _objectSpread(_objectSpread({
          accessToken,
          idToken
        }, rest), {}, {
          state: instanceParameters
        });
      } else {
        this.storageHelper.clearOrphanedLoginDetails();
        if (this.config.uxMode === UX_MODE.REDIRECT) {
          await this.storageHelper.storeLoginDetails({
            method: TORUS_METHOD.TRIGGER_AGGREGATE_LOGIN,
            args
          }, loginHandler.nonce);
        }
        loginParams = await loginHandler.handleLoginWindow({
          locationReplaceOnRedirect: this.config.locationReplaceOnRedirect,
          popupFeatures: this.config.popupFeatures
        });
        if (this.config.uxMode === UX_MODE.REDIRECT) return null;
      }
      // Fail the method even if one promise fails

      userInfoPromises.push(loginHandler.getUserInfo(loginParams));
      loginParamsArray.push(loginParams);
    }
    const _userInfoArray = await Promise.all(userInfoPromises);
    const userInfoArray = _userInfoArray.map(userInfo => _objectSpread(_objectSpread({}, userInfo), {}, {
      aggregateVerifier: verifierIdentifier
    }));
    const aggregateVerifierParams = {
      verify_params: [],
      sub_verifier_ids: [],
      verifier_id: ""
    };
    const aggregateIdTokenSeeds = [];
    let aggregateVerifierId = "";
    let extraVerifierParams = {};
    for (let index = 0; index < subVerifierDetailsArray.length; index += 1) {
      const loginParams = loginParamsArray[index];
      const {
        idToken,
        accessToken
      } = loginParams;
      const userInfo = userInfoArray[index];
      aggregateVerifierParams.verify_params.push({
        verifier_id: userInfo.verifierId,
        idtoken: idToken || accessToken
      });
      aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
      aggregateIdTokenSeeds.push(idToken || accessToken);
      aggregateVerifierId = userInfo.verifierId; // using last because idk
      extraVerifierParams = userInfo.extraVerifierParams;
    }
    aggregateIdTokenSeeds.sort();
    const aggregateIdToken = keccak256$1(Buffer.from(aggregateIdTokenSeeds.join(String.fromCharCode(29)), "utf8")).slice(2);
    aggregateVerifierParams.verifier_id = aggregateVerifierId;
    const torusKey = await this.getTorusKey(verifierIdentifier, aggregateVerifierId, aggregateVerifierParams, aggregateIdToken, extraVerifierParams);
    return _objectSpread(_objectSpread({}, torusKey), {}, {
      userInfo: userInfoArray.map((x, index) => _objectSpread(_objectSpread({}, x), loginParamsArray[index]))
    });
  }
  async getTorusKey(verifier, verifierId, verifierParams, idToken, additionalParams) {
    const nodeDetails = await this.sentryHandler.startSpan({
      name: SENTRY_TXNS.FETCH_NODE_DETAILS
    }, async () => {
      if (this.config.nodeDetails) {
        return this.config.nodeDetails;
      }
      return this.nodeDetailManager.getNodeDetails({
        verifier,
        verifierId
      });
    });
    log.debug("torus-direct/getTorusKey", {
      torusNodeEndpoints: nodeDetails.torusNodeEndpoints
    });
    const sharesResponse = await this.sentryHandler.startSpan({
      name: SENTRY_TXNS.FETCH_SHARES
    }, async () => {
      return this.torus.retrieveShares({
        endpoints: nodeDetails.torusNodeEndpoints,
        indexes: nodeDetails.torusIndexes,
        verifier,
        verifierParams,
        idToken,
        nodePubkeys: nodeDetails.torusNodePub,
        extraParams: _objectSpread({}, additionalParams),
        useDkg: this.config.useDkg,
        checkCommitment: this.config.checkCommitment
      });
    });
    log.debug("torus-direct/getTorusKey", {
      retrieveShares: sharesResponse
    });
    return sharesResponse;
  }
  async getAggregateTorusKey(verifier, verifierId,
  // unique identifier for user e.g. sub on jwt
  subVerifierInfoArray) {
    const aggregateVerifierParams = {
      verify_params: [],
      sub_verifier_ids: [],
      verifier_id: ""
    };
    const aggregateIdTokenSeeds = [];
    let extraVerifierParams = {};
    for (let index = 0; index < subVerifierInfoArray.length; index += 1) {
      const userInfo = subVerifierInfoArray[index];
      aggregateVerifierParams.verify_params.push({
        verifier_id: verifierId,
        idtoken: userInfo.idToken
      });
      aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
      aggregateIdTokenSeeds.push(userInfo.idToken);
      extraVerifierParams = userInfo.extraVerifierParams;
    }
    aggregateIdTokenSeeds.sort();
    const aggregateIdToken = keccak256$1(Buffer.from(aggregateIdTokenSeeds.join(String.fromCharCode(29)), "utf8")).slice(2);
    aggregateVerifierParams.verifier_id = verifierId;
    return this.getTorusKey(verifier, verifierId, aggregateVerifierParams, aggregateIdToken, extraVerifierParams);
  }
  async getRedirectResult({
    replaceUrl = true,
    clearLoginDetails = true
  } = {}) {
    await this.init({
      skipInit: true
    });
    const url = new URL(window.location.href);
    const hash = url.hash.substring(1);
    const queryParams = {};
    url.searchParams.forEach((value, key) => {
      queryParams[key] = value;
    });
    if (!hash && Object.keys(queryParams).length === 0) {
      throw new Error("Found Empty hash and query parameters. This can happen if user reloads the page");
    }
    const {
      error,
      instanceParameters,
      hashParameters
    } = handleRedirectParameters(hash, queryParams);
    const {
      instanceId
    } = instanceParameters;
    log.info(instanceId, "instanceId");
    const loginDetails = await this.storageHelper.retrieveLoginDetails(instanceId);
    const _ref = loginDetails || {},
      {
        args,
        method
      } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded3);
    log.info(args, method);
    if (error) {
      return {
        error,
        state: instanceParameters || {},
        method,
        result: {},
        hashParameters,
        args
      };
    }
    let result;
    try {
      if (method === TORUS_METHOD.TRIGGER_LOGIN) {
        const methodArgs = args;
        methodArgs.hash = hash;
        methodArgs.queryParameters = queryParams;
        result = await this.triggerLogin(methodArgs);
      } else if (method === TORUS_METHOD.TRIGGER_AGGREGATE_LOGIN) {
        const methodArgs = args;
        methodArgs.subVerifierDetailsArray.forEach(x => {
          x.hash = hash;
          x.queryParameters = queryParams;
        });
        result = await this.triggerAggregateLogin(methodArgs);
      }
    } catch (err) {
      const serializedError = await serializeError(err);
      log.error(serializedError);
      if (clearLoginDetails) {
        this.storageHelper.clearLoginDetailsStorage(instanceId);
      }
      return _objectSpread({
        error: `${serializedError.message || ""}`,
        state: instanceParameters || {},
        method,
        result: {},
        hashParameters,
        args
      }, rest);
    }
    if (!result) return _objectSpread({
      error: `Init parameters not found. It might be because storage is not available. Please retry the login in a different browser. Used storage method: ${this.storageHelper.storageMethodUsed}`,
      state: instanceParameters || {},
      method,
      result: {},
      hashParameters,
      args
    }, rest);
    if (replaceUrl) {
      const cleanUrl = window.location.origin + window.location.pathname;
      window.history.replaceState(_objectSpread(_objectSpread({}, window.history.state), {}, {
        as: cleanUrl,
        url: cleanUrl
      }), "", cleanUrl);
    }
    if (clearLoginDetails) {
      this.storageHelper.clearLoginDetailsStorage(instanceId);
    }
    return _objectSpread({
      method,
      result,
      state: instanceParameters || {},
      hashParameters,
      args
    }, rest);
  }
  async handlePrefetchRedirectUri() {
    if (!document) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const redirectHtml = document.createElement("link");
      redirectHtml.href = this.config.redirect_uri;
      if (window.location.origin !== new URL(this.config.redirect_uri).origin) redirectHtml.crossOrigin = "anonymous";
      redirectHtml.type = "text/html";
      redirectHtml.rel = "prefetch";
      const resolveFn = () => {
        this.isInitialized = true;
        resolve();
      };
      try {
        if (redirectHtml.relList && redirectHtml.relList.supports) {
          if (redirectHtml.relList.supports("prefetch")) {
            redirectHtml.onload = resolveFn;
            redirectHtml.onerror = () => {
              reject(new Error(`Please serve redirect.html present in serviceworker folder of this package on ${this.config.redirect_uri}`));
            };
            document.head.appendChild(redirectHtml);
          } else {
            // Link prefetch is not supported. pass through
            resolveFn();
          }
        } else {
          // Link prefetch is not detectable. pass through
          resolveFn();
        }
      } catch (err) {
        resolveFn();
      }
    });
  }
}
var CustomAuth$1 = CustomAuth;

export { AGGREGATE_VERIFIER, CustomAuth$1 as CustomAuth, EMAIL_FLOW, LOGIN, REDIRECT_PARAMS_STORAGE_METHOD, SENTRY_TXNS, TORUS_METHOD, UX_MODE, are3PCSupported, broadcastChannelOptions, constructURL, createHandler$1 as createHandler, decodeToken, eventToPromise, getPopupFeatures, getTimeout, getVerifierId, handleRedirectParameters, isFirefox, isMobileOrTablet, loginToConnectionMap, padUrlString, randomId, serializeError, storageAvailable, validateAndConstructUrl };
