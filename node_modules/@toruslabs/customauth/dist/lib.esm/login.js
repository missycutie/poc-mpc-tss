import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { NodeDetailManager } from '@toruslabs/fetch-node-details';
import { Torus, keccak256 } from '@toruslabs/torus.js';
import createHandler from './handlers/HandlerFactory.js';
import { registerServiceWorker } from './registerServiceWorker.js';
import SentryHandler from './sentry.js';
import { UX_MODE, TORUS_METHOD, AGGREGATE_VERIFIER, SENTRY_TXNS } from './utils/enums.js';
import { serializeError } from './utils/error.js';
import { padUrlString, isFirefox, handleRedirectParameters } from './utils/helpers.js';
import log from './utils/loglevel.js';
import StorageHelper from './utils/StorageHelper.js';

const _excluded = ["access_token", "id_token"],
  _excluded2 = ["access_token", "id_token"],
  _excluded3 = ["args", "method"];
class CustomAuth {
  constructor({
    baseUrl,
    network,
    enableLogging = false,
    redirectToOpener = false,
    redirectPathName = "redirect",
    apiKey = "torus-default",
    uxMode = UX_MODE.POPUP,
    locationReplaceOnRedirect = false,
    popupFeatures,
    storageServerUrl = "https://session.web3auth.io",
    sentry,
    enableOneKey = false,
    web3AuthClientId,
    useDkg,
    metadataUrl = "https://metadata.tor.us",
    keyType = "secp256k1",
    serverTimeOffset = 0,
    nodeDetails,
    checkCommitment = true
  }) {
    _defineProperty(this, "isInitialized", void 0);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "torus", void 0);
    _defineProperty(this, "nodeDetailManager", void 0);
    _defineProperty(this, "storageHelper", void 0);
    _defineProperty(this, "sentryHandler", void 0);
    if (!web3AuthClientId) throw new Error("Please provide a valid web3AuthClientId in constructor");
    if (!network) throw new Error("Please provide a valid network in constructor");
    this.isInitialized = false;
    const baseUri = new URL(baseUrl);
    this.config = {
      baseUrl: padUrlString(baseUri),
      get redirect_uri() {
        return `${this.baseUrl}${redirectPathName}`;
      },
      redirectToOpener,
      uxMode,
      locationReplaceOnRedirect,
      popupFeatures,
      useDkg,
      web3AuthClientId,
      web3AuthNetwork: network,
      keyType,
      nodeDetails,
      checkCommitment
    };
    const torus = new Torus({
      network,
      enableOneKey,
      serverTimeOffset,
      clientId: web3AuthClientId,
      legacyMetadataHost: metadataUrl,
      keyType
    });
    Torus.setAPIKey(apiKey);
    this.torus = torus;
    this.nodeDetailManager = new NodeDetailManager({
      network
    });
    if (enableLogging) log.enableAll();else log.disableAll();
    this.storageHelper = new StorageHelper(storageServerUrl);
    this.sentryHandler = new SentryHandler(sentry);
  }
  async init({
    skipSw = false,
    skipInit = false,
    skipPrefetch = false
  } = {}) {
    this.storageHelper.init();
    if (skipInit) {
      this.isInitialized = true;
      return;
    }
    if (!skipSw) {
      const fetchSwResponse = await fetch(`${this.config.baseUrl}sw.js`, {
        cache: "reload"
      });
      if (fetchSwResponse.ok) {
        try {
          await registerServiceWorker(this.config.baseUrl);
          this.isInitialized = true;
          return;
        } catch (error) {
          log.warn(error);
        }
      } else {
        throw new Error("Service worker is not being served. Please serve it");
      }
    }
    if (!skipPrefetch) {
      // Skip the redirect check for firefox
      if (isFirefox()) {
        this.isInitialized = true;
        return;
      }
      await this.handlePrefetchRedirectUri();
      return;
    }
    this.isInitialized = true;
  }
  async triggerLogin(args) {
    const {
      verifier,
      typeOfLogin,
      clientId,
      jwtParams,
      hash,
      queryParameters,
      customState
    } = args;
    log.info("Verifier: ", verifier);
    if (!this.isInitialized) {
      throw new Error("Not initialized yet");
    }
    const loginHandler = createHandler({
      typeOfLogin,
      clientId,
      verifier,
      redirect_uri: this.config.redirect_uri,
      redirectToOpener: this.config.redirectToOpener,
      jwtParams,
      uxMode: this.config.uxMode,
      customState,
      web3AuthClientId: this.config.web3AuthClientId,
      web3AuthNetwork: this.config.web3AuthNetwork
    });
    let loginParams;
    if (hash && queryParameters) {
      const {
        error,
        hashParameters,
        instanceParameters
      } = handleRedirectParameters(hash, queryParameters);
      if (error) throw new Error(error);
      const {
          access_token: accessToken,
          id_token: idToken
        } = hashParameters,
        rest = _objectWithoutProperties(hashParameters, _excluded);
      // State has to be last here otherwise it will be overwritten
      loginParams = _objectSpread(_objectSpread({
        accessToken,
        idToken
      }, rest), {}, {
        state: instanceParameters
      });
    } else {
      this.storageHelper.clearOrphanedLoginDetails();
      if (this.config.uxMode === UX_MODE.REDIRECT) {
        await this.storageHelper.storeLoginDetails({
          method: TORUS_METHOD.TRIGGER_LOGIN,
          args
        }, loginHandler.nonce);
      }
      loginParams = await loginHandler.handleLoginWindow({
        locationReplaceOnRedirect: this.config.locationReplaceOnRedirect,
        popupFeatures: this.config.popupFeatures
      });
      if (this.config.uxMode === UX_MODE.REDIRECT) return null;
    }
    const userInfo = await loginHandler.getUserInfo(loginParams);
    const torusKey = await this.getTorusKey(verifier, userInfo.verifierId, {
      verifier_id: userInfo.verifierId
    }, loginParams.idToken || loginParams.accessToken, userInfo.extraVerifierParams);
    return _objectSpread(_objectSpread({}, torusKey), {}, {
      userInfo: _objectSpread(_objectSpread({}, userInfo), loginParams)
    });
  }
  async triggerAggregateLogin(args) {
    // This method shall break if any of the promises fail. This behaviour is intended
    const {
      aggregateVerifierType,
      verifierIdentifier,
      subVerifierDetailsArray
    } = args;
    if (!this.isInitialized) {
      throw new Error("Not initialized yet");
    }
    if (!aggregateVerifierType || !verifierIdentifier || !Array.isArray(subVerifierDetailsArray)) {
      throw new Error("Invalid params. Missing aggregateVerifierType, verifierIdentifier or subVerifierDetailsArray");
    }
    if (aggregateVerifierType === AGGREGATE_VERIFIER.SINGLE_VERIFIER_ID && subVerifierDetailsArray.length !== 1) {
      throw new Error("Single id verifier can only have one sub verifier");
    }
    const userInfoPromises = [];
    const loginParamsArray = [];
    for (const subVerifierDetail of subVerifierDetailsArray) {
      const {
        clientId,
        typeOfLogin,
        verifier,
        jwtParams,
        hash,
        queryParameters,
        customState
      } = subVerifierDetail;
      const loginHandler = createHandler({
        typeOfLogin,
        clientId,
        verifier,
        redirect_uri: this.config.redirect_uri,
        redirectToOpener: this.config.redirectToOpener,
        jwtParams,
        uxMode: this.config.uxMode,
        customState,
        web3AuthClientId: this.config.web3AuthClientId,
        web3AuthNetwork: this.config.web3AuthNetwork
      });
      // We let the user login to each verifier in a loop. Don't wait for key derivation here.!
      let loginParams;
      if (hash && queryParameters) {
        const {
          error,
          hashParameters,
          instanceParameters
        } = handleRedirectParameters(hash, queryParameters);
        if (error) throw new Error(error);
        const {
            access_token: accessToken,
            id_token: idToken
          } = hashParameters,
          rest = _objectWithoutProperties(hashParameters, _excluded2);
        // State has to be last here otherwise it will be overwritten
        loginParams = _objectSpread(_objectSpread({
          accessToken,
          idToken
        }, rest), {}, {
          state: instanceParameters
        });
      } else {
        this.storageHelper.clearOrphanedLoginDetails();
        if (this.config.uxMode === UX_MODE.REDIRECT) {
          await this.storageHelper.storeLoginDetails({
            method: TORUS_METHOD.TRIGGER_AGGREGATE_LOGIN,
            args
          }, loginHandler.nonce);
        }
        loginParams = await loginHandler.handleLoginWindow({
          locationReplaceOnRedirect: this.config.locationReplaceOnRedirect,
          popupFeatures: this.config.popupFeatures
        });
        if (this.config.uxMode === UX_MODE.REDIRECT) return null;
      }
      // Fail the method even if one promise fails

      userInfoPromises.push(loginHandler.getUserInfo(loginParams));
      loginParamsArray.push(loginParams);
    }
    const _userInfoArray = await Promise.all(userInfoPromises);
    const userInfoArray = _userInfoArray.map(userInfo => _objectSpread(_objectSpread({}, userInfo), {}, {
      aggregateVerifier: verifierIdentifier
    }));
    const aggregateVerifierParams = {
      verify_params: [],
      sub_verifier_ids: [],
      verifier_id: ""
    };
    const aggregateIdTokenSeeds = [];
    let aggregateVerifierId = "";
    let extraVerifierParams = {};
    for (let index = 0; index < subVerifierDetailsArray.length; index += 1) {
      const loginParams = loginParamsArray[index];
      const {
        idToken,
        accessToken
      } = loginParams;
      const userInfo = userInfoArray[index];
      aggregateVerifierParams.verify_params.push({
        verifier_id: userInfo.verifierId,
        idtoken: idToken || accessToken
      });
      aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
      aggregateIdTokenSeeds.push(idToken || accessToken);
      aggregateVerifierId = userInfo.verifierId; // using last because idk
      extraVerifierParams = userInfo.extraVerifierParams;
    }
    aggregateIdTokenSeeds.sort();
    const aggregateIdToken = keccak256(Buffer.from(aggregateIdTokenSeeds.join(String.fromCharCode(29)), "utf8")).slice(2);
    aggregateVerifierParams.verifier_id = aggregateVerifierId;
    const torusKey = await this.getTorusKey(verifierIdentifier, aggregateVerifierId, aggregateVerifierParams, aggregateIdToken, extraVerifierParams);
    return _objectSpread(_objectSpread({}, torusKey), {}, {
      userInfo: userInfoArray.map((x, index) => _objectSpread(_objectSpread({}, x), loginParamsArray[index]))
    });
  }
  async getTorusKey(verifier, verifierId, verifierParams, idToken, additionalParams) {
    const nodeDetails = await this.sentryHandler.startSpan({
      name: SENTRY_TXNS.FETCH_NODE_DETAILS
    }, async () => {
      if (this.config.nodeDetails) {
        return this.config.nodeDetails;
      }
      return this.nodeDetailManager.getNodeDetails({
        verifier,
        verifierId
      });
    });
    log.debug("torus-direct/getTorusKey", {
      torusNodeEndpoints: nodeDetails.torusNodeEndpoints
    });
    const sharesResponse = await this.sentryHandler.startSpan({
      name: SENTRY_TXNS.FETCH_SHARES
    }, async () => {
      return this.torus.retrieveShares({
        endpoints: nodeDetails.torusNodeEndpoints,
        indexes: nodeDetails.torusIndexes,
        verifier,
        verifierParams,
        idToken,
        nodePubkeys: nodeDetails.torusNodePub,
        extraParams: _objectSpread({}, additionalParams),
        useDkg: this.config.useDkg,
        checkCommitment: this.config.checkCommitment
      });
    });
    log.debug("torus-direct/getTorusKey", {
      retrieveShares: sharesResponse
    });
    return sharesResponse;
  }
  async getAggregateTorusKey(verifier, verifierId,
  // unique identifier for user e.g. sub on jwt
  subVerifierInfoArray) {
    const aggregateVerifierParams = {
      verify_params: [],
      sub_verifier_ids: [],
      verifier_id: ""
    };
    const aggregateIdTokenSeeds = [];
    let extraVerifierParams = {};
    for (let index = 0; index < subVerifierInfoArray.length; index += 1) {
      const userInfo = subVerifierInfoArray[index];
      aggregateVerifierParams.verify_params.push({
        verifier_id: verifierId,
        idtoken: userInfo.idToken
      });
      aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
      aggregateIdTokenSeeds.push(userInfo.idToken);
      extraVerifierParams = userInfo.extraVerifierParams;
    }
    aggregateIdTokenSeeds.sort();
    const aggregateIdToken = keccak256(Buffer.from(aggregateIdTokenSeeds.join(String.fromCharCode(29)), "utf8")).slice(2);
    aggregateVerifierParams.verifier_id = verifierId;
    return this.getTorusKey(verifier, verifierId, aggregateVerifierParams, aggregateIdToken, extraVerifierParams);
  }
  async getRedirectResult({
    replaceUrl = true,
    clearLoginDetails = true
  } = {}) {
    await this.init({
      skipInit: true
    });
    const url = new URL(window.location.href);
    const hash = url.hash.substring(1);
    const queryParams = {};
    url.searchParams.forEach((value, key) => {
      queryParams[key] = value;
    });
    if (!hash && Object.keys(queryParams).length === 0) {
      throw new Error("Found Empty hash and query parameters. This can happen if user reloads the page");
    }
    const {
      error,
      instanceParameters,
      hashParameters
    } = handleRedirectParameters(hash, queryParams);
    const {
      instanceId
    } = instanceParameters;
    log.info(instanceId, "instanceId");
    const loginDetails = await this.storageHelper.retrieveLoginDetails(instanceId);
    const _ref = loginDetails || {},
      {
        args,
        method
      } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded3);
    log.info(args, method);
    if (error) {
      return {
        error,
        state: instanceParameters || {},
        method,
        result: {},
        hashParameters,
        args
      };
    }
    let result;
    try {
      if (method === TORUS_METHOD.TRIGGER_LOGIN) {
        const methodArgs = args;
        methodArgs.hash = hash;
        methodArgs.queryParameters = queryParams;
        result = await this.triggerLogin(methodArgs);
      } else if (method === TORUS_METHOD.TRIGGER_AGGREGATE_LOGIN) {
        const methodArgs = args;
        methodArgs.subVerifierDetailsArray.forEach(x => {
          x.hash = hash;
          x.queryParameters = queryParams;
        });
        result = await this.triggerAggregateLogin(methodArgs);
      }
    } catch (err) {
      const serializedError = await serializeError(err);
      log.error(serializedError);
      if (clearLoginDetails) {
        this.storageHelper.clearLoginDetailsStorage(instanceId);
      }
      return _objectSpread({
        error: `${serializedError.message || ""}`,
        state: instanceParameters || {},
        method,
        result: {},
        hashParameters,
        args
      }, rest);
    }
    if (!result) return _objectSpread({
      error: `Init parameters not found. It might be because storage is not available. Please retry the login in a different browser. Used storage method: ${this.storageHelper.storageMethodUsed}`,
      state: instanceParameters || {},
      method,
      result: {},
      hashParameters,
      args
    }, rest);
    if (replaceUrl) {
      const cleanUrl = window.location.origin + window.location.pathname;
      window.history.replaceState(_objectSpread(_objectSpread({}, window.history.state), {}, {
        as: cleanUrl,
        url: cleanUrl
      }), "", cleanUrl);
    }
    if (clearLoginDetails) {
      this.storageHelper.clearLoginDetailsStorage(instanceId);
    }
    return _objectSpread({
      method,
      result,
      state: instanceParameters || {},
      hashParameters,
      args
    }, rest);
  }
  async handlePrefetchRedirectUri() {
    if (!document) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const redirectHtml = document.createElement("link");
      redirectHtml.href = this.config.redirect_uri;
      if (window.location.origin !== new URL(this.config.redirect_uri).origin) redirectHtml.crossOrigin = "anonymous";
      redirectHtml.type = "text/html";
      redirectHtml.rel = "prefetch";
      const resolveFn = () => {
        this.isInitialized = true;
        resolve();
      };
      try {
        if (redirectHtml.relList && redirectHtml.relList.supports) {
          if (redirectHtml.relList.supports("prefetch")) {
            redirectHtml.onload = resolveFn;
            redirectHtml.onerror = () => {
              reject(new Error(`Please serve redirect.html present in serviceworker folder of this package on ${this.config.redirect_uri}`));
            };
            document.head.appendChild(redirectHtml);
          } else {
            // Link prefetch is not supported. pass through
            resolveFn();
          }
        } else {
          // Link prefetch is not detectable. pass through
          resolveFn();
        }
      } catch (err) {
        resolveFn();
      }
    });
  }
}
var CustomAuth$1 = CustomAuth;

export { CustomAuth$1 as default };
