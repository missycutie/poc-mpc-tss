'use strict';

var base64url = require('base64url');
var Bowser = require('bowser');
var enums = require('./enums.js');
var loglevel = require('./loglevel.js');

function eventToPromise(emitter) {
  return new Promise((resolve, reject) => {
    const handler = ev => {
      const {
        error = "",
        data
      } = ev;
      emitter.removeEventListener("message", handler);
      if (error) return reject(new Error(error));
      return resolve(data);
    };
    emitter.addEventListener("message", handler);
  });
}

// These are the default connection names used by auth0
const loginToConnectionMap = {
  [enums.LOGIN.APPLE]: "apple",
  [enums.LOGIN.GITHUB]: "github",
  [enums.LOGIN.LINKEDIN]: "linkedin",
  [enums.LOGIN.TWITTER]: "twitter",
  [enums.LOGIN.WEIBO]: "weibo",
  [enums.LOGIN.LINE]: "line",
  [enums.LOGIN.EMAIL_PASSWORD]: "Username-Password-Authentication",
  [enums.LOGIN.PASSWORDLESS]: "email",
  [enums.LOGIN.EMAIL_PASSWORDLESS]: "email",
  [enums.LOGIN.SMS_PASSWORDLESS]: "sms"
};
const padUrlString = url => url.href.endsWith("/") ? url.href : `${url.href}/`;

/**
 * Returns a random number. Don't use for cryptographic purposes.
 * @returns a random number
 */
const randomId = () => Math.random().toString(36).slice(2);
const broadcastChannelOptions = {
  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']
  webWorkerSupport: false // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)
};
function caseSensitiveField(field, isCaseSensitive) {
  return isCaseSensitive ? field : field.toLowerCase();
}
const getVerifierId = (userInfo, typeOfLogin, verifierIdField, isVerifierIdCaseSensitive = true) => {
  const {
    name,
    sub
  } = userInfo;
  if (verifierIdField) return caseSensitiveField(userInfo[verifierIdField], isVerifierIdCaseSensitive);
  switch (typeOfLogin) {
    case enums.LOGIN.PASSWORDLESS:
    case enums.LOGIN.EMAIL_PASSWORD:
    case enums.LOGIN.EMAIL_PASSWORDLESS:
    case enums.LOGIN.SMS_PASSWORDLESS:
      return caseSensitiveField(name, isVerifierIdCaseSensitive);
    case enums.LOGIN.WEIBO:
    case enums.LOGIN.GITHUB:
    case enums.LOGIN.TWITTER:
    case enums.LOGIN.APPLE:
    case enums.LOGIN.LINKEDIN:
    case enums.LOGIN.LINE:
    case enums.LOGIN.JWT:
      return caseSensitiveField(sub, isVerifierIdCaseSensitive);
    default:
      throw new Error("Invalid login type to get verifier id");
  }
};
const handleRedirectParameters = (hash, queryParameters) => {
  const hashParameters = hash.split("&").reduce((result, item) => {
    const [part0, part1] = item.split("=");
    result[part0] = part1;
    return result;
  }, {});
  loglevel.info(hashParameters, queryParameters);
  let instanceParameters = {};
  let error = "";
  if (Object.keys(hashParameters).length > 0 && hashParameters.state) {
    instanceParameters = JSON.parse(base64url.decode(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};
    error = hashParameters.error_description || hashParameters.error || error;
  } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {
    instanceParameters = JSON.parse(base64url.decode(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};
    if (queryParameters.error) error = queryParameters.error;
  }
  return {
    error,
    instanceParameters,
    hashParameters
  };
};
function storageAvailable(type) {
  let storage;
  try {
    storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    const e = error;
    return e && (
    // everything except Firefox
    e.code === 22 ||
    // Firefox
    e.code === 1014 ||
    // test name field too, because code might not be present
    // everything except Firefox
    e.name === "QuotaExceededError" ||
    // Firefox
    e.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
    // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0;
  }
}
function getPopupFeatures() {
  // Fixes dual-screen position                             Most browsers      Firefox
  const dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
  const w = 1200;
  const h = 700;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1; // No reliable estimate

  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
  return features;
}
const isFirefox = () => {
  var _window;
  return ((_window = window) === null || _window === void 0 || (_window = _window.navigator) === null || _window === void 0 ? void 0 : _window.userAgent.toLowerCase().indexOf("firefox")) > -1 || false;
};
function constructURL(params) {
  const {
    baseURL,
    query,
    hash
  } = params;
  const url = new URL(baseURL);
  if (query) {
    Object.keys(query).forEach(key => {
      url.searchParams.append(key, query[key]);
    });
  }
  if (hash) {
    const h = new URL(constructURL({
      baseURL,
      query: hash
    })).searchParams.toString();
    url.hash = h;
  }
  return url.toString();
}
function are3PCSupported() {
  var _navigator;
  const browserInfo = Bowser.parse(navigator.userAgent);
  loglevel.info(JSON.stringify(browserInfo), "current browser info");
  let thirdPartyCookieSupport = true;
  // brave
  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {
    thirdPartyCookieSupport = false;
  }
  // All webkit & gecko engine instances use itp (intelligent tracking prevention -
  // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)
  if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {
    thirdPartyCookieSupport = false;
  }
  return thirdPartyCookieSupport;
}
const validateAndConstructUrl = domain => {
  try {
    const url = new URL(decodeURIComponent(domain));
    return url;
  } catch (error) {
    throw new Error(`${(error === null || error === void 0 ? void 0 : error.message) || ""}, Note: Your jwt domain: (i.e ${domain}) must have http:// or https:// prefix`);
  }
};
function isMobileOrTablet() {
  const browser = Bowser.getParser(navigator.userAgent);
  const platform = browser.getPlatform();
  return platform.type === Bowser.PLATFORMS_MAP.tablet || platform.type === Bowser.PLATFORMS_MAP.mobile;
}
function getTimeout(typeOfLogin) {
  if ((typeOfLogin === enums.LOGIN.FACEBOOK || typeOfLogin === enums.LOGIN.LINE) && isMobileOrTablet()) {
    return 1000 * 60; // 60 seconds to finish the login
  }
  return 1000 * 10; // 10 seconds
}
function decodeToken(token) {
  const [header, payload] = token.split(".");
  return {
    header: JSON.parse(base64url.decode(header)),
    payload: JSON.parse(base64url.decode(payload))
  };
}

exports.are3PCSupported = are3PCSupported;
exports.broadcastChannelOptions = broadcastChannelOptions;
exports.constructURL = constructURL;
exports.decodeToken = decodeToken;
exports.eventToPromise = eventToPromise;
exports.getPopupFeatures = getPopupFeatures;
exports.getTimeout = getTimeout;
exports.getVerifierId = getVerifierId;
exports.handleRedirectParameters = handleRedirectParameters;
exports.isFirefox = isFirefox;
exports.isMobileOrTablet = isMobileOrTablet;
exports.loginToConnectionMap = loginToConnectionMap;
exports.padUrlString = padUrlString;
exports.randomId = randomId;
exports.storageAvailable = storageAvailable;
exports.validateAndConstructUrl = validateAndConstructUrl;
