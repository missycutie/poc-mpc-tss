/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AwaitableMap: () => (/* reexport */ AwaitableMap),
  MapQueue: () => (/* reexport */ MapQueue),
  deriveShareCoefficients: () => (/* reexport */ deriveShareCoefficients),
  fraction: () => (/* reexport */ fraction),
  lagrangeCoefficient: () => (/* reexport */ lagrangeCoefficient),
  lagrangeCoefficients: () => (/* reexport */ lagrangeCoefficients)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: ./src/map.ts

class AwaitableMap {
  constructor() {
    defineProperty_default()(this, "map", new Map());
    defineProperty_default()(this, "queue", new Map());
  }
  get size() {
    return this.map.size;
  }
  getSync(k) {
    return this.map.get(k);
  }

  /**
   * Gets the value at key `k`, or waits for the duration of `timeout` for a
   * corresponding value to be set. If `timeout` is reached, returns
   * `undefined`.
   */
  async get(k, timeout = 0) {
    const v = this.map.get(k);
    if (v) {
      return v;
    }
    return new Promise(resolve => {
      const prom = {
        resolve,
        timeout: setTimeout(() => {
          // Timeout reached.

          // Delete from queue.
          const proms = this.queue.get(k);
          if (proms) {
            const i = proms.indexOf(prom);
            if (i >= 0) {
              proms.splice(i, 1);
            }
          }

          // Resolve to undefined.
          resolve(undefined);
        }, timeout)
      };
      let proms = this.queue.get(k);
      if (!proms) {
        proms = [];
        this.queue.set(k, proms);
      }
      proms.push(prom);
    });
  }
  set(k, v) {
    this.map.set(k, v);
    const proms = this.queue.get(k);
    if (proms) {
      for (const prom of proms) {
        clearTimeout(prom.timeout);
        prom.resolve(v);
      }
      this.queue.delete(k);
    }
  }
  delete(k) {
    this.map.delete(k);
    this.queue.delete(k);
  }
  forEach(callbackfn) {
    this.map.forEach(callbackfn);
  }
  clear() {
    this.map.clear();
    this.queue.clear();
  }
}
class MapQueue {
  constructor() {
    defineProperty_default()(this, "buffer", new Map());
    defineProperty_default()(this, "queue", new Map());
  }
  /**
   * Pops the next value queued for key `k` from the buffer, or waits for the
   * duration of `timeout` for a corresponding value to arrive. If `timeout` is
   * reached, returns `undefined`.
   */
  async pop(k, timeout = 0) {
    const vals = this.buffer.get(k);
    if (vals && vals.length > 0) {
      const val = vals.splice(0, 1)[0];
      return val;
    }
    return new Promise(resolve => {
      const prom = {
        resolve,
        timeout: setTimeout(() => {
          // Timeout reached.

          // Delete from queue.
          const proms = this.queue.get(k);
          if (proms) {
            const i = proms.indexOf(prom);
            if (i >= 0) {
              proms.splice(i, 1);
            }
          }

          // Resolve to undefined.
          resolve(undefined);
        }, timeout)
      };
      let proms = this.queue.get(k);
      if (!proms) {
        proms = [];
        this.queue.set(k, proms);
      }
      proms.push(prom);
    });
  }
  push(k, v) {
    const proms = this.queue.get(k);
    if (proms && proms.length > 0) {
      const prom = proms.splice(0, 1)[0];
      clearTimeout(prom.timeout);
      prom.resolve(v);
      return;
    }
    let vals = this.buffer.get(k);
    if (!vals) {
      vals = [];
      this.buffer.set(k, vals);
    }
    vals.push(v);
  }
  delete(k) {
    this.buffer.delete(k);
    this.queue.delete(k);
  }
  forEach(callbackfn) {
    this.buffer.forEach((vals, k) => {
      vals.forEach(v => {
        callbackfn(v, k);
      });
    });
  }
  clear() {
    this.buffer.clear();
    this.queue.clear();
  }
}
;// CONCATENATED MODULE: external "bn.js"
const external_bn_js_namespaceObject = require("bn.js");
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_namespaceObject);
;// CONCATENATED MODULE: ./src/util.ts

function fraction(nom, denom, modulus) {
  return nom.mul(denom.invm(modulus)).umod(modulus);
}
function lagrangeCoefficient(x_coords, target_coeff, target_x, modulus) {
  return x_coords.filter((_, i) => i !== target_coeff).reduce((prev, cur) => {
    const frac = fraction(target_x.sub(cur), x_coords[target_coeff].sub(cur), modulus);
    return prev.mul(frac).umod(modulus);
  }, new (external_bn_js_default())(1));
}
function lagrangeCoefficients(x_coords, target_x, modulus) {
  const x_coords_BN = x_coords.map(i => new (external_bn_js_default())(i));
  const target_x_BN = new (external_bn_js_default())(target_x);
  return x_coords_BN.map((_value, i) => lagrangeCoefficient(x_coords_BN, i, target_x_BN, modulus));
}

/**
 * Derive share coefficients for converting a 2-level Shamir secret sharing into
 * a 1-level Shamir secret sharing.
 *
 * Input:
 *
 * Level 1: [SERVERS, CLIENT]
 * Level 2: [SERVER_1, ... , SERVER_N]
 *
 * Ouput:
 *
 * Level 1: [SCOEFF_1 * SERVER_1, ..., SCOEFF_N * SERVER_N, C_COEFF * CLIENT]
 *
 * @param serverXCoords - The x-coordinates of the selected servers.
 * @param clientXCoord - The target x-coordinate of the client.
 * @param modulus - The finite field modulus.
 * @param serversXCoordL1 - The x-coordinate of the servers at level 1.
 * @param clientXCoordL1 - The x-coordinate of the client at level 1.
 * @returns - The share coefficients for the client and the servers.
 */
function deriveShareCoefficients(serverXCoords, clientXCoord, modulus, serversXCoordL1 = 1, clientXCoordL1 = 2) {
  const l1Coefficients = lagrangeCoefficients([serversXCoordL1, clientXCoordL1], 0, modulus);
  const l2Coefficients = lagrangeCoefficients(serverXCoords, 0, modulus);
  if (serverXCoords.includes(clientXCoord)) {
    throw new Error(`Invalid server x-coordinates: overlapping with client x-coordinate: ${serverXCoords} ${clientXCoord}`);
  }
  const targetCoefficients = lagrangeCoefficients([clientXCoord, ...serverXCoords], 0, modulus);

  // Derive server coefficients.
  const serverCoefficients = l2Coefficients.map((coeff, i) => fraction(l1Coefficients[0].mul(coeff), targetCoefficients[i + 1], modulus));

  // Derive client coefficient.
  const clientCoefficient = fraction(l1Coefficients[1], targetCoefficients[0], modulus);
  return {
    serverCoefficients,
    clientCoefficient
  };
}
;// CONCATENATED MODULE: ./src/index.ts


module.exports = __webpack_exports__;
/******/ })()
;