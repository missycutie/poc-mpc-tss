import { encrypt as encrypt$1, decrypt as decrypt$1 } from '@toruslabs/eccrypto';
import BN from 'bn.js';
import { ec } from 'elliptic';

const ecCurveSecp256k1 = new ec("secp256k1");
function randomSelection(arr, num) {
  if (num > arr.length) throw new Error("trying to select more elements than available");
  const selected = [];
  const slice = arr.slice();
  while (selected.length < num) {
    selected.push(slice.splice(Math.floor(Math.random() * slice.length), 1)[0]);
  }
  return selected;
}
function ecPoint(ecCurve, p) {
  if (p.x === null && p.y === null) {
    return ecCurve.curve.g.add(ecCurve.curve.g.neg());
  }
  return ecCurve.keyFromPublic({
    x: p.x.padStart(64, "0"),
    y: p.y.padStart(64, "0")
  }).getPublic();
}
function hexPoint(p) {
  if (p.isInfinity()) {
    return {
      x: null,
      y: null
    };
  }
  return {
    x: p.getX().toString(16, 64),
    y: p.getY().toString(16, 64)
  };
}
// Wrappers around ECC encrypt/decrypt to use the hex serialization
async function encrypt(publicKey, msg) {
  const encryptedDetails = await encrypt$1(publicKey, msg);
  return {
    ciphertext: encryptedDetails.ciphertext.toString("hex"),
    ephemPublicKey: encryptedDetails.ephemPublicKey.toString("hex"),
    iv: encryptedDetails.iv.toString("hex"),
    mac: encryptedDetails.mac.toString("hex")
  };
}
async function decrypt(privKey, msg) {
  const bufferEncDetails = {
    ciphertext: Buffer.from(msg.ciphertext, "hex"),
    ephemPublicKey: Buffer.from(msg.ephemPublicKey, "hex"),
    iv: Buffer.from(msg.iv, "hex"),
    mac: Buffer.from(msg.mac, "hex")
  };
  return decrypt$1(privKey, bufferEncDetails);
}
function generatePolynomial(degree, yIntercept, randomElement) {
  const res = [];
  let i = 0;
  if (yIntercept !== undefined) {
    res.push(yIntercept);
    i++;
  }
  for (; i <= degree; i++) {
    res.push(randomElement());
  }
  return res;
}
function getShare(polynomial, index, modulus) {
  let res = new BN(0);
  for (let i = 0; i < polynomial.length; i++) {
    const term = polynomial[i].mul(new BN(index).pow(new BN(i)));
    res = res.add(term.umod(modulus));
  }
  return res.umod(modulus);
}
function dotProduct(arr1, arr2, modulus) {
  if (arr1.length !== arr2.length) {
    throw new Error("arrays of different lengths");
  }
  let sum = new BN(0);
  for (let i = 0; i < arr1.length; i++) {
    sum = sum.add(arr1[i].mul(arr2[i]));
    if (modulus) {
      sum = sum.umod(modulus);
    }
  }
  return sum;
}
function getLagrangeCoeff(_allIndexes, _myIndex, _target, modulus) {
  const allIndexes = _allIndexes.map(i => new BN(i));
  const myIndex = new BN(_myIndex);
  const target = new BN(_target);
  let upper = new BN(1);
  let lower = new BN(1);
  for (let j = 0; j < allIndexes.length; j += 1) {
    if (myIndex.cmp(allIndexes[j]) !== 0) {
      let tempUpper = target.sub(allIndexes[j]);
      tempUpper = tempUpper.umod(modulus);
      upper = upper.mul(tempUpper);
      upper = upper.umod(modulus);
      let tempLower = myIndex.sub(allIndexes[j]);
      tempLower = tempLower.umod(modulus);
      lower = lower.mul(tempLower).umod(modulus);
    }
  }
  return upper.mul(lower.invm(modulus)).umod(modulus);
}
function lagrangeInterpolation(shares, nodeIndex, modulus) {
  if (shares.length !== nodeIndex.length) {
    return null;
  }
  let secret = new BN(0);
  for (let i = 0; i < shares.length; i += 1) {
    let upper = new BN(1);
    let lower = new BN(1);
    for (let j = 0; j < shares.length; j += 1) {
      if (i !== j) {
        upper = upper.mul(nodeIndex[j].neg());
        upper = upper.umod(modulus);
        let temp = nodeIndex[i].sub(nodeIndex[j]);
        temp = temp.umod(modulus);
        lower = lower.mul(temp).umod(modulus);
      }
    }
    let delta = upper.mul(lower.invm(modulus)).umod(modulus);
    delta = delta.mul(shares[i]).umod(modulus);
    secret = secret.add(delta);
  }
  return secret.umod(modulus);
}

export { decrypt, dotProduct, ecCurveSecp256k1, ecPoint, encrypt, generatePolynomial, getLagrangeCoeff, getShare, hexPoint, lagrangeInterpolation, randomSelection };
