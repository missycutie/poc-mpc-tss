/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  sign: () => (/* reexport */ sign)
});

;// CONCATENATED MODULE: external "@toruslabs/tss-frost-common"
const tss_frost_common_namespaceObject = require("@toruslabs/tss-frost-common");
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/tss-client-util"
const tss_client_util_namespaceObject = require("@toruslabs/tss-client-util");
;// CONCATENATED MODULE: external "socket.io-client"
const external_socket_io_client_namespaceObject = require("socket.io-client");
;// CONCATENATED MODULE: ./src/msg.ts




const READ_TIMEOUT = 10000;
const CONNECT_TIMEOUT = 10000;
function messageKey(sender, receiver, type) {
  return JSON.stringify([sender, receiver, type]);
}
class MessageBroker {
  constructor(session, sender) {
    defineProperty_default()(this, "session_id", void 0);
    defineProperty_default()(this, "sender_id", void 0);
    defineProperty_default()(this, "messages", new tss_client_util_namespaceObject.MapQueue());
    defineProperty_default()(this, "sockets", new Map());
    this.session_id = session;
    this.sender_id = sender;
  }
  getSocket(server_id) {
    return this.sockets.get(server_id);
  }

  // Connects to the remote endpoints and populates the sockets map.
  //
  // If already connected, clears existing connections first.
  async connect(ids, endpoints) {
    if (ids.length !== endpoints.length) {
      throw new Error("ids must have same length as endpoints");
    }

    // Close existing connections.
    this.close();

    // Create sockets.
    const sockets = endpoints.map(wsEndpoint => {
      const url = new URL("socket.io", wsEndpoint);
      return (0,external_socket_io_client_namespaceObject.io)(url.origin, {
        path: url.pathname,
        transports: ["websocket", "polling"],
        withCredentials: true,
        reconnectionDelayMax: 10000,
        reconnectionAttempts: 3
      });
    });

    // Wait for sockets to be connected.
    const proms = sockets.map(socket => {
      return new Promise((resolve, reject) => {
        socket.on("connect", resolve);
        setTimeout(() => {
          reject(new Error("Connection timeout"));
        }, CONNECT_TIMEOUT);
      });
    });
    await Promise.all(proms);

    // Connect sockets to messaging queue and populate socket map.
    sockets.forEach((socket, i) => {
      // Connect to messaging queue.
      const serverId = ids[i];
      socket.on("send", async (msg, cb) => {
        // Check correct sender and session.
        if (msg.sender !== serverId) {
          console.log(`ignoring message: wrong sender: expected ${serverId}, got ${msg.sender}`);
          return;
        }
        if (msg.session !== this.session_id) {
          console.log(`ignoring message: wrong session: expected ${this.session_id}, got ${msg.session}`);
          return;
        }

        // Push to queue.
        const m = {
          sender: msg.sender,
          data: (0,tss_frost_common_namespaceObject.base64ToBytes)(msg.msg_data),
          receiver: msg.recipient,
          type: msg.msg_type
        };
        const k = messageKey(m.sender, m.receiver, m.type);
        this.messages.push(k, m);

        // Optional callback.
        if (cb) cb();
      });

      // Add to socket map.
      this.sockets.set(serverId, socket);
    });
  }

  // Closes connections and cleans up memory.
  close() {
    this.sockets.forEach(socket => socket.disconnect());
    this.sockets.clear();
  }
  async send(to, mtype, mdata) {
    const socket = this.sockets.get(to);
    if (!socket) {
      throw new Error("Socket not found");
    }
    const msg = {
      msg_data: (0,tss_frost_common_namespaceObject.bytesToBase64)(mdata),
      msg_type: mtype,
      recipient: to,
      sender: this.sender_id,
      session: this.session_id
    };
    socket.emit("send_msg", msg);
  }
  async receive(from, mtype) {
    const k = messageKey(from, this.sender_id, mtype);
    const msg = await this.messages.pop(k, READ_TIMEOUT);
    if (!msg) {
      throw new Error("Timeout");
    }
    return msg.data;
  }
}
;// CONCATENATED MODULE: ./src/sign.ts


async function requestSign(server, session, server_id, pubkey, server_ids, server_endpoints, client_id, socket_id, msg, signatures, share_coefficient) {
  const parties = server_ids.slice();
  const endpoints = server_endpoints.slice().map(ep => ep.endsWith("/") ? ep.slice(0, -1) : ep);

  // Add client socket.
  parties.push(client_id);
  endpoints.push(`websocket:${socket_id.id}`);
  const body = {
    session,
    msg: (0,tss_frost_common_namespaceObject.bytesToBase64)(msg),
    player_index: server_id,
    pubkey,
    parties,
    endpoints,
    signatures,
    share_coefficient
  };
  const url = new URL("sign", server);
  const resp = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
  if (!resp.ok) {
    const errMsg = (await resp.json()).message;
    throw new Error(errMsg);
  }
}

// Generates a sequence of random bytes with sufficient entropy for use with a
// cryptographic random number generator.
function generateRngSeed() {
  const buf = new Uint8Array(32);
  crypto.getRandomValues(buf);
  return buf;
}

// Signature as hex string.

/**
 * Initiate and run the signing protocol with the designated parties.
 *
 * @param session - The signing session identifier.
 * @param signatures - The signatures used for authentication.
 * @param server_ids - The server identities. Must be equal to their share's
 * x-coordinate.
 * @param server_endpoints - The network endpoints of the servers corresponding
 * to `server_ids`.
 * @param client_index - The client identity. Must be equal to the share's
 * x-coordinate.
 * @param keyshare - The client key share.
 * @param pubkey - The public key.
 * @param msg - The message to be signed.
 * @param server_coefficients - Optional coefficients for server shares. Can be
 * used for converting between different secret sharing hierarchies.
 * @returns
 */
async function sign(wasmLib, session, signatures, server_ids, server_endpoints, client_index, keyshare, pubkey, msg, server_coefficients = undefined) {
  // Create network session.
  const mb = new MessageBroker(session, client_index);
  await mb.connect(server_ids, server_endpoints);

  // Initiate signing protocol at counterparties.
  server_ids.forEach((p, i) => {
    const socket = mb.getSocket(p);
    if (socket === undefined) {
      throw new Error(`socket not found: party ${p}`);
    }
    requestSign(new URL(server_endpoints[i]), session, p, pubkey, server_ids, server_endpoints, client_index, socket, msg, signatures, server_coefficients ? server_coefficients[i] : undefined).catch(error => {
      console.error(`Server ${i}: ${error}`);
    });
  });

  // Generate seed for RNG.
  const seed = generateRngSeed();

  // Create Wasm memory manager.
  const mem = new tss_frost_common_namespaceObject.MemoryManager();
  try {
    // Copy objects to Wasm memory.
    const seedWasm = mem.add(new wasmLib.RngSeed(seed));
    const keyWasm = mem.add(wasmLib.KeyShare.from_raw(client_index, keyshare, pubkey));

    // Run signing protocol.
    const sig = mem.add(await wasmLib.sign(seedWasm, mb, new Uint32Array(server_ids), keyWasm, msg));
    return sig.to_hex();
  } finally {
    // Free allocated Wasm memory.
    mem.free();
    // Cleanup network session.
    mb.close();
  }
}
;// CONCATENATED MODULE: ./src/index.ts


module.exports = __webpack_exports__;
/******/ })()
;