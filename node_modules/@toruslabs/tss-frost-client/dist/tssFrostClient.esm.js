import { base64ToBytes, bytesToBase64, MemoryManager } from '@toruslabs/tss-frost-common';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { MapQueue } from '@toruslabs/tss-client-util';
import { io } from 'socket.io-client';

const READ_TIMEOUT = 10000;
const CONNECT_TIMEOUT = 10000;
function messageKey(sender, receiver, type) {
  return JSON.stringify([sender, receiver, type]);
}
class MessageBroker {
  constructor(session, sender) {
    _defineProperty(this, "session_id", void 0);
    _defineProperty(this, "sender_id", void 0);
    _defineProperty(this, "messages", new MapQueue());
    _defineProperty(this, "sockets", new Map());
    this.session_id = session;
    this.sender_id = sender;
  }
  getSocket(server_id) {
    return this.sockets.get(server_id);
  }

  // Connects to the remote endpoints and populates the sockets map.
  //
  // If already connected, clears existing connections first.
  async connect(ids, endpoints) {
    if (ids.length !== endpoints.length) {
      throw new Error("ids must have same length as endpoints");
    }

    // Close existing connections.
    this.close();

    // Create sockets.
    const sockets = endpoints.map(wsEndpoint => {
      const url = new URL("socket.io", wsEndpoint);
      return io(url.origin, {
        path: url.pathname,
        transports: ["websocket", "polling"],
        withCredentials: true,
        reconnectionDelayMax: 10000,
        reconnectionAttempts: 3
      });
    });

    // Wait for sockets to be connected.
    const proms = sockets.map(socket => {
      return new Promise((resolve, reject) => {
        socket.on("connect", resolve);
        setTimeout(() => {
          reject(new Error("Connection timeout"));
        }, CONNECT_TIMEOUT);
      });
    });
    await Promise.all(proms);

    // Connect sockets to messaging queue and populate socket map.
    sockets.forEach((socket, i) => {
      // Connect to messaging queue.
      const serverId = ids[i];
      socket.on("send", async (msg, cb) => {
        // Check correct sender and session.
        if (msg.sender !== serverId) {
          console.log(`ignoring message: wrong sender: expected ${serverId}, got ${msg.sender}`);
          return;
        }
        if (msg.session !== this.session_id) {
          console.log(`ignoring message: wrong session: expected ${this.session_id}, got ${msg.session}`);
          return;
        }

        // Push to queue.
        const m = {
          sender: msg.sender,
          data: base64ToBytes(msg.msg_data),
          receiver: msg.recipient,
          type: msg.msg_type
        };
        const k = messageKey(m.sender, m.receiver, m.type);
        this.messages.push(k, m);

        // Optional callback.
        if (cb) cb();
      });

      // Add to socket map.
      this.sockets.set(serverId, socket);
    });
  }

  // Closes connections and cleans up memory.
  close() {
    this.sockets.forEach(socket => socket.disconnect());
    this.sockets.clear();
  }
  async send(to, mtype, mdata) {
    const socket = this.sockets.get(to);
    if (!socket) {
      throw new Error("Socket not found");
    }
    const msg = {
      msg_data: bytesToBase64(mdata),
      msg_type: mtype,
      recipient: to,
      sender: this.sender_id,
      session: this.session_id
    };
    socket.emit("send_msg", msg);
  }
  async receive(from, mtype) {
    const k = messageKey(from, this.sender_id, mtype);
    const msg = await this.messages.pop(k, READ_TIMEOUT);
    if (!msg) {
      throw new Error("Timeout");
    }
    return msg.data;
  }
}

async function requestSign(server, session, server_id, pubkey, server_ids, server_endpoints, client_id, socket_id, msg, signatures, share_coefficient) {
  const parties = server_ids.slice();
  const endpoints = server_endpoints.slice().map(ep => ep.endsWith("/") ? ep.slice(0, -1) : ep);

  // Add client socket.
  parties.push(client_id);
  endpoints.push(`websocket:${socket_id.id}`);
  const body = {
    session,
    msg: bytesToBase64(msg),
    player_index: server_id,
    pubkey,
    parties,
    endpoints,
    signatures,
    share_coefficient
  };
  const url = new URL("sign", server);
  const resp = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
  if (!resp.ok) {
    const errMsg = (await resp.json()).message;
    throw new Error(errMsg);
  }
}

// Generates a sequence of random bytes with sufficient entropy for use with a
// cryptographic random number generator.
function generateRngSeed() {
  const buf = new Uint8Array(32);
  crypto.getRandomValues(buf);
  return buf;
}

// Signature as hex string.

/**
 * Initiate and run the signing protocol with the designated parties.
 *
 * @param session - The signing session identifier.
 * @param signatures - The signatures used for authentication.
 * @param server_ids - The server identities. Must be equal to their share's
 * x-coordinate.
 * @param server_endpoints - The network endpoints of the servers corresponding
 * to `server_ids`.
 * @param client_index - The client identity. Must be equal to the share's
 * x-coordinate.
 * @param keyshare - The client key share.
 * @param pubkey - The public key.
 * @param msg - The message to be signed.
 * @param server_coefficients - Optional coefficients for server shares. Can be
 * used for converting between different secret sharing hierarchies.
 * @returns
 */
async function sign(wasmLib, session, signatures, server_ids, server_endpoints, client_index, keyshare, pubkey, msg, server_coefficients = undefined) {
  // Create network session.
  const mb = new MessageBroker(session, client_index);
  await mb.connect(server_ids, server_endpoints);

  // Initiate signing protocol at counterparties.
  server_ids.forEach((p, i) => {
    const socket = mb.getSocket(p);
    if (socket === undefined) {
      throw new Error(`socket not found: party ${p}`);
    }
    requestSign(new URL(server_endpoints[i]), session, p, pubkey, server_ids, server_endpoints, client_index, socket, msg, signatures, server_coefficients ? server_coefficients[i] : undefined).catch(error => {
      console.error(`Server ${i}: ${error}`);
    });
  });

  // Generate seed for RNG.
  const seed = generateRngSeed();

  // Create Wasm memory manager.
  const mem = new MemoryManager();
  try {
    // Copy objects to Wasm memory.
    const seedWasm = mem.add(new wasmLib.RngSeed(seed));
    const keyWasm = mem.add(wasmLib.KeyShare.from_raw(client_index, keyshare, pubkey));

    // Run signing protocol.
    const sig = mem.add(await wasmLib.sign(seedWasm, mb, new Uint32Array(server_ids), keyWasm, msg));
    return sig.to_hex();
  } finally {
    // Free allocated Wasm memory.
    mem.free();
    // Cleanup network session.
    mb.close();
  }
}

export { sign };
