import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { generatePrivate } from '@toruslabs/eccrypto';
import BN from 'bn.js';
import { keccak256 } from 'ethereum-cryptography/keccak';
import { ec } from 'elliptic';
import { io } from 'socket.io-client';

const WEB3_SESSION_HEADER_KEY = "x-web3-session-id";
const DELIMITERS = {
  Delimiter1: "\u001c",
  Delimiter2: "\u0015",
  Delimiter3: "\u0016",
  Delimiter4: "\u0017"
};

function getEc() {
  return new ec("secp256k1");
}
function getLagrangeCoeffs(_allIndexes, _myIndex) {
  let _target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const ec = getEc();
  const allIndexes = _allIndexes.map(i => new BN(i));
  const myIndex = new BN(_myIndex);
  const target = new BN(_target);
  let upper = new BN(1);
  let lower = new BN(1);
  for (let j = 0; j < allIndexes.length; j += 1) {
    if (myIndex.cmp(allIndexes[j]) !== 0) {
      let tempUpper = target.sub(allIndexes[j]);
      tempUpper = tempUpper.umod(ec.curve.n);
      upper = upper.mul(tempUpper);
      upper = upper.umod(ec.curve.n);
      let tempLower = myIndex.sub(allIndexes[j]);
      tempLower = tempLower.umod(ec.curve.n);
      lower = lower.mul(tempLower).umod(ec.curve.n);
    }
  }
  return upper.mul(lower.invm(ec.curve.n)).umod(ec.curve.n);
}
function ecPoint(p) {
  const ec = getEc();
  return ec.keyFromPublic({
    x: p.x.padStart(64, "0"),
    y: p.y.padStart(64, "0")
  }).getPublic();
}
const getAdditiveCoeff = (isUser, participatingServerIndexes, userTSSIndex, serverIndex) => {
  const ec = getEc();
  if (isUser) {
    return getLagrangeCoeffs([1, userTSSIndex], userTSSIndex);
  }
  // generate the lagrange coeff that converts the current server DKG share into an additive sharing
  const serverLagrangeCoeff = getLagrangeCoeffs(participatingServerIndexes, serverIndex);
  const masterLagrangeCoeff = getLagrangeCoeffs([1, userTSSIndex], 1);
  const additiveLagrangeCoeff = serverLagrangeCoeff.mul(masterLagrangeCoeff).umod(ec.curve.n);
  return additiveLagrangeCoeff;
};

// Note: this is only needed for DKLS and not for FROST
const getDenormaliseCoeff = (party, parties) => {
  if (parties.indexOf(party) === -1) throw new Error(`party ${party} not found in parties ${parties}`);
  const ec = getEc();
  // generate the lagrange coeff that denormalises the additive sharing into the shamir sharing that TSS is expecting
  const denormaliseLagrangeCoeff = getLagrangeCoeffs(parties, party).invm(ec.curve.n).umod(ec.curve.n);
  return denormaliseLagrangeCoeff;
};
const getDKLSCoeff = (isUser, participatingServerIndexes, userTSSIndex, serverIndex) => {
  const sortedServerIndexes = participatingServerIndexes.sort((a, b) => a - b);
  for (let i = 0; i < sortedServerIndexes.length; i++) {
    if (sortedServerIndexes[i] !== participatingServerIndexes[i]) throw new Error("server indexes must be sorted");
  }
  // generate denormalise coeff for DKLS
  const parties = [];

  // total number of parties for DKLS = total number of servers + 1 (user is the last party)
  // server party indexes
  let serverPartyIndex = 0;
  for (let i = 0; i < participatingServerIndexes.length; i++) {
    const currentPartyIndex = i + 1;
    parties.push(currentPartyIndex);
    if (participatingServerIndexes[i] === serverIndex) serverPartyIndex = currentPartyIndex;
  }
  const userPartyIndex = parties.length + 1;
  parties.push(userPartyIndex); // user party index
  if (isUser) {
    const additiveCoeff = getAdditiveCoeff(isUser, participatingServerIndexes, userTSSIndex, serverIndex);
    const denormaliseCoeff = getDenormaliseCoeff(userPartyIndex, parties);
    const ec = getEc();
    return denormaliseCoeff.mul(additiveCoeff).umod(ec.curve.n);
  }
  const additiveCoeff = getAdditiveCoeff(isUser, participatingServerIndexes, userTSSIndex, serverIndex);
  const denormaliseCoeff = getDenormaliseCoeff(serverPartyIndex, parties);
  const ec = getEc();
  const coeff = denormaliseCoeff.mul(additiveCoeff).umod(ec.curve.n);
  return coeff;
};
const createSockets = async (wsEndpoints, sessionId) => {
  return wsEndpoints.map(wsEndpoint => {
    if (wsEndpoint === null || wsEndpoint === undefined) {
      return null;
    }
    return io(wsEndpoint, {
      path: "/tss/socket.io",
      query: {
        sessionId
      },
      transports: ["websocket", "polling"],
      withCredentials: true,
      reconnectionDelayMax: 10000,
      reconnectionAttempts: 5
    });
  });
};
function getTSSPubKey(dkgPubKey, userSharePubKey, userTSSIndex) {
  const serverLagrangeCoeff = getLagrangeCoeffs([1, userTSSIndex], 1);
  const userLagrangeCoeff = getLagrangeCoeffs([1, userTSSIndex], userTSSIndex);
  const serverTerm = ecPoint(dkgPubKey).mul(serverLagrangeCoeff);
  const userTerm = ecPoint(userSharePubKey).mul(userLagrangeCoeff);
  return serverTerm.add(userTerm);
}
const generateEndpoints = (parties, clientIndex) => {
  const endpoints = [];
  const tssWSEndpoints = [];
  const partyIndexes = [];
  for (let i = 0; i < parties; i++) {
    partyIndexes.push(i);
    if (i === clientIndex) {
      endpoints.push(null);
      tssWSEndpoints.push(null);
    } else {
      endpoints.push(`https://sapphire-${i + 1}.auth.network/tss`);
      tssWSEndpoints.push(`https://sapphire-${i + 1}.auth.network`);
    }
  }
  return {
    endpoints,
    tssWSEndpoints,
    partyIndexes
  };
};
const setupSockets = async (tssWSEndpoints, sessionId) => {
  const sockets = await createSockets(tssWSEndpoints, sessionId);
  // wait for websockets to be connected
  await new Promise(resolve => {
    const checkConnectionTimer = setInterval(() => {
      for (let i = 0; i < sockets.length; i++) {
        if (sockets[i] !== null && !sockets[i].connected) return;
      }
      clearInterval(checkConnectionTimer);
      resolve(true);
    }, 100);
  });
  return sockets;
};

// TODO: create namespace for globals
if (globalThis.tss_clients === undefined) {
  // Cleanup leads to memory leaks with just an object. Should use a map instead.
  // TODO: This should be singular
  globalThis.tss_clients = new Map();
}
if (globalThis.js_read_msg === undefined) {
  globalThis.js_read_msg = async function (session, self_index, party, msg_type) {
    const tss_client = globalThis.tss_clients.get(session);
    tss_client.log(`reading msg, ${msg_type}`);
    if (msg_type === "ga1_worker_support") {
      return "unsupported";
    }
    const mm = tss_client.msgQueue.find(m => m.sender === party && m.recipient === self_index && m.msg_type === msg_type);
    if (!mm) {
      // It is very important that this promise can reject, since it is passed through to dkls library and awaited internally. If it cannot reject and a message is lost,
      // it will never resolve and hang indefinitely with no possibility of recovery.
      return new Promise((resolve, reject) => {
        let counter = 0;
        const timer = setInterval(() => {
          const found = tss_client.msgQueue.find(m => m.sender === party && m.recipient === self_index && m.msg_type === msg_type);
          if (found !== undefined) {
            clearInterval(timer);
            resolve(found.msg_data);
          }
          if (counter >= 1000) {
            clearInterval(timer);
            // TODO Fix wasm to handle error objects properly and then reject
            // with Error instead of string.
            //
            // eslint-disable-next-line prefer-promise-reject-errors
            reject("Message not received in a reasonable time");
          }
          counter++;
        }, 10);
      });
    }
    return mm.msg_data;
  };
}
if (globalThis.js_send_msg === undefined) {
  globalThis.js_send_msg = async function (session, self_index, party, msg_type, msg_data) {
    const tss_client = globalThis.tss_clients.get(session);
    tss_client.log(`sending msg, ${msg_type}`);
    if (msg_type.indexOf("ga1_data_unprocessed") > -1) {
      throw new Error("ga1_data_unprocessed should not be sent directly");
    }
    if (tss_client.websocketOnly) {
      const socket = tss_client.sockets[party];
      socket.emit("send_msg", {
        session,
        sender: self_index,
        recipient: party,
        msg_type,
        msg_data
      });
    } else {
      const sid = session.split(DELIMITERS.Delimiter4)[1];
      const endpoint = tss_client.lookupEndpoint(session, party);
      fetch(`${endpoint}/send`, {
        method: "POST",
        headers: {
          [WEB3_SESSION_HEADER_KEY]: sid,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session,
          sender: self_index,
          recipient: party,
          msg_type,
          msg_data
        })
      });
    }
    return true;
  };
}
class Client {
  // Note: create sockets externally before passing it in in the constructor to allow socket reuse
  constructor(_session, _index, _parties, _endpoints, _sockets, _share, _pubKey, _websocketOnly, _tssLib) {
    _defineProperty(this, "session", void 0);
    _defineProperty(this, "index", void 0);
    _defineProperty(this, "parties", void 0);
    _defineProperty(this, "msgQueue", []);
    _defineProperty(this, "sockets", void 0);
    _defineProperty(this, "endpoints", void 0);
    _defineProperty(this, "share", void 0);
    _defineProperty(this, "pubKey", void 0);
    _defineProperty(this, "websocketOnly", void 0);
    _defineProperty(this, "tssLib", void 0);
    _defineProperty(this, "_startPrecomputeTime", void 0);
    _defineProperty(this, "_endPrecomputeTime", void 0);
    _defineProperty(this, "_startSignTime", void 0);
    _defineProperty(this, "_endSignTime", void 0);
    _defineProperty(this, "log", void 0);
    _defineProperty(this, "_consumed", void 0);
    _defineProperty(this, "_sLessThanHalf", void 0);
    _defineProperty(this, "_precomputeComplete", []);
    _defineProperty(this, "_precomputeFailed", []);
    _defineProperty(this, "precomputed_value", null);
    _defineProperty(this, "_ready", false);
    _defineProperty(this, "_signer", void 0);
    _defineProperty(this, "_rng", void 0);
    // this is required due to precompute not being marked async
    _defineProperty(this, "_readyResolve", null);
    if (_parties.length !== _sockets.length) {
      throw new Error("parties and sockets length must be equal, add null for client if necessary");
    }
    if (_parties.length !== _endpoints.length) {
      throw new Error("parties and endpoints length must be equal, add null for client if necessary");
    }
    this.session = _session;
    this.index = _index;
    this.parties = _parties;
    this.endpoints = _endpoints;
    this.sockets = _sockets;
    this.share = _share;
    this.pubKey = _pubKey;
    this.websocketOnly = _websocketOnly;
    this.log = console.log;
    this._consumed = false;
    this._sLessThanHalf = true;
    this.tssLib = _tssLib;
    _sockets.forEach(socket => {
      if (socket) {
        if (socket.hasListeners("send")) {
          socket.off("send");
        }

        // Add listener for incoming messages
        socket.on("send", async (data, cb) => {
          const {
            session,
            sender,
            recipient,
            msg_type,
            msg_data
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this.msgQueue.push({
            session,
            sender,
            recipient,
            msg_type,
            msg_data
          });
          if (cb) cb();
        });
        // Add listener for completion
        socket.on("precompute_complete", async (data, cb) => {
          const {
            session,
            party
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this._precomputeComplete.push(party);
          if (cb) cb();
        });
        socket.on("precompute_failed", async (data, cb) => {
          const {
            session,
            party
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this._precomputeFailed.push(party);
          if (cb) cb();
        });
      }
    });
    globalThis.tss_clients.set(this.session, this);
  }
  get sid() {
    return this.session.split(DELIMITERS.Delimiter4)[1];
  }
  async ready() {
    if (this._readyResolve != null) {
      await this._readyResolve;
    } else {
      throw new Error("Precompute needs to be called before ready");
    }

    // ensure that there were no failures and all peers are finished
    await new Promise((resolve, reject) => {
      let counter = 0;
      const timer = setInterval(() => {
        if (this._precomputeFailed.length === 0 && this._precomputeComplete.filter((x, i, a) => a.indexOf(x) === i).length === this.parties.length && this.precomputed_value != null) {
          clearInterval(timer);
          this._ready = true;
          resolve();
        } else if (this._precomputeFailed.length > 0) {
          reject(new Error("Peer failure detected, please try again"));
        }
        if (counter >= 500) {
          clearInterval(timer);
          reject(new Error("Client is not ready"));
        }
        counter++;
      }, 10);
    });
  }
  precompute(additionalParams) {
    // check if sockets have connected and have an id;
    this.sockets.forEach((socket, party) => {
      if (socket !== null) {
        if (socket.id === undefined) {
          throw new Error(`socket not connected yet, session: ${this.session}, party: ${party}`);
        }
      }
    });
    const precomputePromises = [];
    for (let i = 0; i < this.parties.length; i++) {
      const party = this.parties[i];
      if (party !== this.index) {
        precomputePromises.push(new Promise((resolve, reject) => {
          fetch(`${this.lookupEndpoint(this.session, party)}/precompute`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              [WEB3_SESSION_HEADER_KEY]: this.sid
            },
            body: JSON.stringify(_objectSpread({
              endpoints: this.endpoints.map((endpoint, j) => {
                if (j !== this.index) {
                  return endpoint;
                }
                // pass in different id for websocket connection for each server so that the server can communicate back
                return `websocket:${this.sockets[party].id}`;
              }),
              session: this.session,
              parties: this.parties,
              player_index: party,
              threshold: this.parties.length,
              pubkey: this.pubKey,
              notifyWebsocketId: this.sockets[party].id,
              sendWebsocket: this.sockets[party].id
            }, additionalParams))
          }).then(async resp => {
            const json = await resp.json();
            if (resp.status !== 200) {
              throw new Error(`precompute route failed on ${this.lookupEndpoint(this.session, party)} with status ${resp.status} \n ${JSON.stringify(json)} `);
            }
            return resolve(resp);
          }).catch(err => {
            reject(err);
          });
        }));
      }
    }

    // TODO: Refactor precompute to be async instead of using inline async here.
    const setupPrecompute = async () => {
      this._startPrecomputeTime = Date.now();
      await Promise.all(precomputePromises);
      this._signer = await this.tssLib.threshold_signer(this.session, this.index, this.parties.length, this.parties.length, this.share, this.pubKey);
      this._rng = await this.tssLib.random_generator(Buffer.from(generatePrivate()).toString("base64"));
      await this.tssLib.setup(this._signer, this._rng);
      const precomputeResult = await this.tssLib.precompute(new Uint8Array(this.parties), this._signer, this._rng);
      this.precomputed_value = precomputeResult;
      this._precomputeComplete.push(this.index);
      this._consumed = false;
      this._endPrecomputeTime = Date.now();
    };
    this._readyResolve = setupPrecompute().catch(e => {
      this._precomputeFailed.push(this.index);
      console.error(e);
    });
  }
  async sign(msg, hash_only, original_message, hash_algo, additionalParams) {
    if (this._consumed === true) {
      throw new Error("This instance has already signed a message and cannot be reused");
    }
    if (this._ready === false) {
      throw new Error("client is not ready");
    }

    // check message hashing
    if (!hash_only) {
      if (hash_algo === "keccak256") {
        if (Buffer.from(keccak256(Buffer.from(original_message))).toString("base64") !== msg) {
          throw new Error("hash of original message does not match msg");
        }
      } else {
        throw new Error(`hash algo ${hash_algo} not supported`);
      }
    }
    this._startSignTime = Date.now();
    const sigFragments = [];
    const fragmentPromises = [];
    for (let i = 0; i < this.parties.length; i++) {
      const party = i;
      if (party === this.index) {
        // create signature fragment for this client
        sigFragments.push(await this.tssLib.local_sign(msg, hash_only, this.precomputed_value));
      } else {
        // collect signature fragment from all peers
        fragmentPromises.push(new Promise((resolve, reject) => {
          const endpoint = this.lookupEndpoint(this.session, party);
          fetch(`${endpoint}/sign`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              [WEB3_SESSION_HEADER_KEY]: this.sid
            },
            body: JSON.stringify(_objectSpread({
              session: this.session,
              sender: this.index,
              recipient: party,
              msg,
              hash_only,
              original_message,
              hash_algo
            }, additionalParams))
          }).then(res => res.json()).then(res => resolve(res.sig)).catch(err => {
            reject(err);
          });
        }));
      }
    }
    const peerFragments = await Promise.all(fragmentPromises);
    peerFragments.forEach(fragment => {
      sigFragments.push(fragment);
    });
    const R = await this.tssLib.get_r_from_precompute(this.precomputed_value);
    const sig = await this.tssLib.local_verify(msg, hash_only, R, sigFragments, this.pubKey);
    this._endSignTime = Date.now();
    const sigHex = Buffer.from(sig, "base64").toString("hex");
    const r = new BN(sigHex.slice(0, 64), 16);
    let s = new BN(sigHex.slice(64), 16);
    let recoveryParam = Buffer.from(R, "base64")[63] % 2;
    if (this._sLessThanHalf) {
      const ec = getEc();
      const halfOfSecp256k1n = ec.n.div(new BN(2));
      if (s.gt(halfOfSecp256k1n)) {
        s = ec.n.sub(s);
        recoveryParam = (recoveryParam + 1) % 2;
      }
    }
    this._consumed = true;
    this._ready = false;
    this._readyResolve = null;
    return {
      r,
      s,
      recoveryParam
    };
  }
  lookupEndpoint(session, party) {
    if (session !== this.session) throw new Error("incorrect session when looking up endpoint");
    return this.endpoints[party];
  }
  async cleanup(additionalParams) {
    // free native objects
    this.tssLib.random_generator_free(this._rng);
    this.tssLib.threshold_signer_free(this._signer);

    // clear data for this client
    this._precomputeComplete = [];
    this._precomputeFailed = [];
    this.precomputed_value = null;
    this._endPrecomputeTime = null;
    this._startPrecomputeTime = null;
    this._endSignTime = null;
    this._startSignTime = null;
    this._consumed = false;
    this._ready = false;
    this._readyResolve = null;

    // remove references
    globalThis.tss_clients.delete(this.session);
    this.sockets.forEach(soc => {
      if (soc && soc.connected) {
        soc.close();
      }
    });
    await Promise.all(this.parties.map(async party => {
      if (party !== this.index) {
        await fetch(`${this.lookupEndpoint(this.session, party)}/cleanup`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            [WEB3_SESSION_HEADER_KEY]: this.sid
          },
          body: JSON.stringify(_objectSpread({
            session: this.session
          }, additionalParams))
        });
      }
      return Promise.resolve(true);
    }));
  }
}

// TODO: This should be removed, the client should not require any local storage.
// Client should only operate on data supplied to it.

class WebDb {
  constructor() {
    _defineProperty(this, "get", key => {
      return new Promise(resolve => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          // r(memoryDB[key])
          const value = globalThis.localStorage.getItem(key);
          resolve(value);
        } else {
          chrome.storage.local.get(key, result => {
            resolve(result[key]);
            return result;
          });
        }
      });
    });
    _defineProperty(this, "set", (key, value) => {
      return new Promise(resolve => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          globalThis.localStorage.setItem(key, value);
          // memoryDB[key] = value
          resolve();
        } else {
          chrome.storage.local.set({
            [key]: value
          }, () => {
            resolve();
          });
        }
      });
    });
    _defineProperty(this, "delete", key => {
      return new Promise(resolve => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          // r(memoryDB[key])
          globalThis.localStorage.removeItem(key);
          resolve();
        } else {
          chrome.storage.local.remove(key);
          resolve();
        }
      });
    });
  }
}
const localStorageDB = new WebDb();

export { Client, DELIMITERS, WEB3_SESSION_HEADER_KEY, createSockets, ecPoint, generateEndpoints, getAdditiveCoeff, getDKLSCoeff, getDenormaliseCoeff, getEc, getLagrangeCoeffs, getTSSPubKey, localStorageDB, setupSockets };
