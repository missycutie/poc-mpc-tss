/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 834:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  K: () => (/* binding */ Client)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(990);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);
;// CONCATENATED MODULE: external "@toruslabs/eccrypto"
const eccrypto_namespaceObject = require("@toruslabs/eccrypto");
// EXTERNAL MODULE: external "bn.js"
var external_bn_js_ = __webpack_require__(415);
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_);
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/_assert.js
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}

const assert = { number, bool, bytes, hash, exists, output };
/* harmony default export */ const _assert = (assert);
//# sourceMappingURL=_assert.js.map
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/_u64.js
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
const rotr32L = (h, _l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore

// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
/* harmony default export */ const _u64 = ((/* unused pure expression or super */ null && (u64)));
//# sourceMappingURL=_u64.js.map
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/utils.js
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.

// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function utils_isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
// Other libraries would silently corrupt the data instead of throwing an error,
// when they don't support it.
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!utils_isBytes(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await nextTick();
        ts += diff;
    }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!utils_isBytes(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!utils_isBytes(a))
            throw new Error('Uint8Array expected');
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function utils_wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === 'function') {
        return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/sha3.js



// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        exists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        exists(this, false);
        bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const sha3_224 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 144, 224 / 8)));
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
const sha3_256 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 136, 256 / 8)));
const sha3_384 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 104, 384 / 8)));
const sha3_512 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 72, 512 / 8)));
const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);
const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);
const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
const shake128 = /* @__PURE__ */ (/* unused pure expression or super */ null && (genShake(0x1f, 168, 128 / 8)));
const shake256 = /* @__PURE__ */ (/* unused pure expression or super */ null && (genShake(0x1f, 136, 256 / 8)));
//# sourceMappingURL=sha3.js.map
;// CONCATENATED MODULE: ../../node_modules/ethereum-cryptography/esm/utils.js


const assertBool = _assert.bool;
const assertBytes = _assert.bytes;


// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
function utils_hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return _hexToBytes(sliced);
}
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert.bytes(msg);
        return hash(msg);
    };
}
// TODO(v3): switch away from node crypto, remove this unnecessary variable.
const utils_crypto = (() => {
    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

;// CONCATENATED MODULE: ../../node_modules/ethereum-cryptography/esm/keccak.js


const keccak224 = wrapHash(keccak_224);
const keccak256 = (() => {
    const k = wrapHash(keccak_256);
    k.create = keccak_256.create;
    return k;
})();
const keccak384 = wrapHash(keccak_384);
const keccak512 = wrapHash(keccak_512);

// EXTERNAL MODULE: ./src/constants.ts
var constants = __webpack_require__(706);
// EXTERNAL MODULE: ./src/utils.ts + 2 modules
var utils = __webpack_require__(816);
;// CONCATENATED MODULE: ./src/client.ts


/* eslint-disable no-console */






// TODO: create namespace for globals
if (globalThis.tss_clients === undefined) {
  // Cleanup leads to memory leaks with just an object. Should use a map instead.
  // TODO: This should be singular
  globalThis.tss_clients = new Map();
}
if (globalThis.js_read_msg === undefined) {
  globalThis.js_read_msg = async function (session, self_index, party, msg_type) {
    const tss_client = globalThis.tss_clients.get(session);
    tss_client.log(`reading msg, ${msg_type}`);
    if (msg_type === "ga1_worker_support") {
      return "unsupported";
    }
    const mm = tss_client.msgQueue.find(m => m.sender === party && m.recipient === self_index && m.msg_type === msg_type);
    if (!mm) {
      // It is very important that this promise can reject, since it is passed through to dkls library and awaited internally. If it cannot reject and a message is lost,
      // it will never resolve and hang indefinitely with no possibility of recovery.
      return new Promise((resolve, reject) => {
        let counter = 0;
        const timer = setInterval(() => {
          const found = tss_client.msgQueue.find(m => m.sender === party && m.recipient === self_index && m.msg_type === msg_type);
          if (found !== undefined) {
            clearInterval(timer);
            resolve(found.msg_data);
          }
          if (counter >= 1000) {
            clearInterval(timer);
            // TODO Fix wasm to handle error objects properly and then reject
            // with Error instead of string.
            //
            // eslint-disable-next-line prefer-promise-reject-errors
            reject("Message not received in a reasonable time");
          }
          counter++;
        }, 10);
      });
    }
    return mm.msg_data;
  };
}
if (globalThis.js_send_msg === undefined) {
  globalThis.js_send_msg = async function (session, self_index, party, msg_type, msg_data) {
    const tss_client = globalThis.tss_clients.get(session);
    tss_client.log(`sending msg, ${msg_type}`);
    if (msg_type.indexOf("ga1_data_unprocessed") > -1) {
      throw new Error("ga1_data_unprocessed should not be sent directly");
    }
    if (tss_client.websocketOnly) {
      const socket = tss_client.sockets[party];
      socket.emit("send_msg", {
        session,
        sender: self_index,
        recipient: party,
        msg_type,
        msg_data
      });
    } else {
      const sid = session.split(constants/* DELIMITERS */.l.Delimiter4)[1];
      const endpoint = tss_client.lookupEndpoint(session, party);
      fetch(`${endpoint}/send`, {
        method: "POST",
        headers: {
          [constants/* WEB3_SESSION_HEADER_KEY */.V]: sid,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session,
          sender: self_index,
          recipient: party,
          msg_type,
          msg_data
        })
      });
    }
    return true;
  };
}
class Client {
  // Note: create sockets externally before passing it in in the constructor to allow socket reuse
  constructor(_session, _index, _parties, _endpoints, _sockets, _share, _pubKey, _websocketOnly, _tssLib) {
    defineProperty_default()(this, "session", void 0);
    defineProperty_default()(this, "index", void 0);
    defineProperty_default()(this, "parties", void 0);
    defineProperty_default()(this, "msgQueue", []);
    defineProperty_default()(this, "sockets", void 0);
    defineProperty_default()(this, "endpoints", void 0);
    defineProperty_default()(this, "share", void 0);
    defineProperty_default()(this, "pubKey", void 0);
    defineProperty_default()(this, "websocketOnly", void 0);
    defineProperty_default()(this, "tssLib", void 0);
    defineProperty_default()(this, "_startPrecomputeTime", void 0);
    defineProperty_default()(this, "_endPrecomputeTime", void 0);
    defineProperty_default()(this, "_startSignTime", void 0);
    defineProperty_default()(this, "_endSignTime", void 0);
    defineProperty_default()(this, "log", void 0);
    defineProperty_default()(this, "_consumed", void 0);
    defineProperty_default()(this, "_sLessThanHalf", void 0);
    defineProperty_default()(this, "_precomputeComplete", []);
    defineProperty_default()(this, "_precomputeFailed", []);
    defineProperty_default()(this, "precomputed_value", null);
    defineProperty_default()(this, "_ready", false);
    defineProperty_default()(this, "_signer", void 0);
    defineProperty_default()(this, "_rng", void 0);
    // this is required due to precompute not being marked async
    defineProperty_default()(this, "_readyResolve", null);
    if (_parties.length !== _sockets.length) {
      throw new Error("parties and sockets length must be equal, add null for client if necessary");
    }
    if (_parties.length !== _endpoints.length) {
      throw new Error("parties and endpoints length must be equal, add null for client if necessary");
    }
    this.session = _session;
    this.index = _index;
    this.parties = _parties;
    this.endpoints = _endpoints;
    this.sockets = _sockets;
    this.share = _share;
    this.pubKey = _pubKey;
    this.websocketOnly = _websocketOnly;
    this.log = console.log;
    this._consumed = false;
    this._sLessThanHalf = true;
    this.tssLib = _tssLib;
    _sockets.forEach(socket => {
      if (socket) {
        if (socket.hasListeners("send")) {
          socket.off("send");
        }

        // Add listener for incoming messages
        socket.on("send", async (data, cb) => {
          const {
            session,
            sender,
            recipient,
            msg_type,
            msg_data
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this.msgQueue.push({
            session,
            sender,
            recipient,
            msg_type,
            msg_data
          });
          if (cb) cb();
        });
        // Add listener for completion
        socket.on("precompute_complete", async (data, cb) => {
          const {
            session,
            party
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this._precomputeComplete.push(party);
          if (cb) cb();
        });
        socket.on("precompute_failed", async (data, cb) => {
          const {
            session,
            party
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this._precomputeFailed.push(party);
          if (cb) cb();
        });
      }
    });
    globalThis.tss_clients.set(this.session, this);
  }
  get sid() {
    return this.session.split(constants/* DELIMITERS */.l.Delimiter4)[1];
  }
  async ready() {
    if (this._readyResolve != null) {
      await this._readyResolve;
    } else {
      throw new Error("Precompute needs to be called before ready");
    }

    // ensure that there were no failures and all peers are finished
    await new Promise((resolve, reject) => {
      let counter = 0;
      const timer = setInterval(() => {
        if (this._precomputeFailed.length === 0 && this._precomputeComplete.filter((x, i, a) => a.indexOf(x) === i).length === this.parties.length && this.precomputed_value != null) {
          clearInterval(timer);
          this._ready = true;
          resolve();
        } else if (this._precomputeFailed.length > 0) {
          reject(new Error("Peer failure detected, please try again"));
        }
        if (counter >= 500) {
          clearInterval(timer);
          reject(new Error("Client is not ready"));
        }
        counter++;
      }, 10);
    });
  }
  precompute(additionalParams) {
    // check if sockets have connected and have an id;
    this.sockets.forEach((socket, party) => {
      if (socket !== null) {
        if (socket.id === undefined) {
          throw new Error(`socket not connected yet, session: ${this.session}, party: ${party}`);
        }
      }
    });
    const precomputePromises = [];
    for (let i = 0; i < this.parties.length; i++) {
      const party = this.parties[i];
      if (party !== this.index) {
        precomputePromises.push(new Promise((resolve, reject) => {
          fetch(`${this.lookupEndpoint(this.session, party)}/precompute`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              [constants/* WEB3_SESSION_HEADER_KEY */.V]: this.sid
            },
            body: JSON.stringify(objectSpread2_default()({
              endpoints: this.endpoints.map((endpoint, j) => {
                if (j !== this.index) {
                  return endpoint;
                }
                // pass in different id for websocket connection for each server so that the server can communicate back
                return `websocket:${this.sockets[party].id}`;
              }),
              session: this.session,
              parties: this.parties,
              player_index: party,
              threshold: this.parties.length,
              pubkey: this.pubKey,
              notifyWebsocketId: this.sockets[party].id,
              sendWebsocket: this.sockets[party].id
            }, additionalParams))
          }).then(async resp => {
            const json = await resp.json();
            if (resp.status !== 200) {
              throw new Error(`precompute route failed on ${this.lookupEndpoint(this.session, party)} with status ${resp.status} \n ${JSON.stringify(json)} `);
            }
            return resolve(resp);
          }).catch(err => {
            reject(err);
          });
        }));
      }
    }

    // TODO: Refactor precompute to be async instead of using inline async here.
    const setupPrecompute = async () => {
      this._startPrecomputeTime = Date.now();
      await Promise.all(precomputePromises);
      this._signer = await this.tssLib.threshold_signer(this.session, this.index, this.parties.length, this.parties.length, this.share, this.pubKey);
      this._rng = await this.tssLib.random_generator(Buffer.from((0,eccrypto_namespaceObject.generatePrivate)()).toString("base64"));
      await this.tssLib.setup(this._signer, this._rng);
      const precomputeResult = await this.tssLib.precompute(new Uint8Array(this.parties), this._signer, this._rng);
      this.precomputed_value = precomputeResult;
      this._precomputeComplete.push(this.index);
      this._consumed = false;
      this._endPrecomputeTime = Date.now();
    };
    this._readyResolve = setupPrecompute().catch(e => {
      this._precomputeFailed.push(this.index);
      console.error(e);
    });
  }
  async sign(msg, hash_only, original_message, hash_algo, additionalParams) {
    if (this._consumed === true) {
      throw new Error("This instance has already signed a message and cannot be reused");
    }
    if (this._ready === false) {
      throw new Error("client is not ready");
    }

    // check message hashing
    if (!hash_only) {
      if (hash_algo === "keccak256") {
        if (Buffer.from(keccak256(Buffer.from(original_message))).toString("base64") !== msg) {
          throw new Error("hash of original message does not match msg");
        }
      } else {
        throw new Error(`hash algo ${hash_algo} not supported`);
      }
    }
    this._startSignTime = Date.now();
    const sigFragments = [];
    const fragmentPromises = [];
    for (let i = 0; i < this.parties.length; i++) {
      const party = i;
      if (party === this.index) {
        // create signature fragment for this client
        sigFragments.push(await this.tssLib.local_sign(msg, hash_only, this.precomputed_value));
      } else {
        // collect signature fragment from all peers
        fragmentPromises.push(new Promise((resolve, reject) => {
          const endpoint = this.lookupEndpoint(this.session, party);
          fetch(`${endpoint}/sign`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              [constants/* WEB3_SESSION_HEADER_KEY */.V]: this.sid
            },
            body: JSON.stringify(objectSpread2_default()({
              session: this.session,
              sender: this.index,
              recipient: party,
              msg,
              hash_only,
              original_message,
              hash_algo
            }, additionalParams))
          }).then(res => res.json()).then(res => resolve(res.sig)).catch(err => {
            reject(err);
          });
        }));
      }
    }
    const peerFragments = await Promise.all(fragmentPromises);
    peerFragments.forEach(fragment => {
      sigFragments.push(fragment);
    });
    const R = await this.tssLib.get_r_from_precompute(this.precomputed_value);
    const sig = await this.tssLib.local_verify(msg, hash_only, R, sigFragments, this.pubKey);
    this._endSignTime = Date.now();
    const sigHex = Buffer.from(sig, "base64").toString("hex");
    const r = new (external_bn_js_default())(sigHex.slice(0, 64), 16);
    let s = new (external_bn_js_default())(sigHex.slice(64), 16);
    let recoveryParam = Buffer.from(R, "base64")[63] % 2;
    if (this._sLessThanHalf) {
      const ec = (0,utils/* getEc */.$e)();
      const halfOfSecp256k1n = ec.n.div(new (external_bn_js_default())(2));
      if (s.gt(halfOfSecp256k1n)) {
        s = ec.n.sub(s);
        recoveryParam = (recoveryParam + 1) % 2;
      }
    }
    this._consumed = true;
    this._ready = false;
    this._readyResolve = null;
    return {
      r,
      s,
      recoveryParam
    };
  }
  lookupEndpoint(session, party) {
    if (session !== this.session) throw new Error("incorrect session when looking up endpoint");
    return this.endpoints[party];
  }
  async cleanup(additionalParams) {
    // free native objects
    this.tssLib.random_generator_free(this._rng);
    this.tssLib.threshold_signer_free(this._signer);

    // clear data for this client
    this._precomputeComplete = [];
    this._precomputeFailed = [];
    this.precomputed_value = null;
    this._endPrecomputeTime = null;
    this._startPrecomputeTime = null;
    this._endSignTime = null;
    this._startSignTime = null;
    this._consumed = false;
    this._ready = false;
    this._readyResolve = null;

    // remove references
    globalThis.tss_clients.delete(this.session);
    this.sockets.forEach(soc => {
      if (soc && soc.connected) {
        soc.close();
      }
    });
    await Promise.all(this.parties.map(async party => {
      if (party !== this.index) {
        await fetch(`${this.lookupEndpoint(this.session, party)}/cleanup`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            [constants/* WEB3_SESSION_HEADER_KEY */.V]: this.sid
          },
          body: JSON.stringify(objectSpread2_default()({
            session: this.session
          }, additionalParams))
        });
      }
      return Promise.resolve(true);
    }));
  }
}

/***/ }),

/***/ 706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   V: () => (/* binding */ WEB3_SESSION_HEADER_KEY),
/* harmony export */   l: () => (/* binding */ DELIMITERS)
/* harmony export */ });
const WEB3_SESSION_HEADER_KEY = "x-web3-session-id";
const DELIMITERS = {
  Delimiter1: "\u001c",
  Delimiter2: "\u0015",
  Delimiter3: "\u0016",
  Delimiter4: "\u0017"
};

/***/ }),

/***/ 689:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   N: () => (/* binding */ localStorageDB)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(990);
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);

// TODO: This should be removed, the client should not require any local storage.
// Client should only operate on data supplied to it.

class WebDb {
  constructor() {
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "get", key => {
      return new Promise(resolve => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          // r(memoryDB[key])
          const value = globalThis.localStorage.getItem(key);
          resolve(value);
        } else {
          chrome.storage.local.get(key, result => {
            resolve(result[key]);
            return result;
          });
        }
      });
    });
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "set", (key, value) => {
      return new Promise(resolve => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          globalThis.localStorage.setItem(key, value);
          // memoryDB[key] = value
          resolve();
        } else {
          chrome.storage.local.set({
            [key]: value
          }, () => {
            resolve();
          });
        }
      });
    });
    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, "delete", key => {
      return new Promise(resolve => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          // r(memoryDB[key])
          globalThis.localStorage.removeItem(key);
          resolve();
        } else {
          chrome.storage.local.remove(key);
          resolve();
        }
      });
    });
  }
}
const localStorageDB = new WebDb();

/***/ }),

/***/ 927:
/***/ (() => {



/***/ }),

/***/ 816:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Fq: () => (/* binding */ createSockets),
  jX: () => (/* binding */ ecPoint),
  uG: () => (/* binding */ generateEndpoints),
  i6: () => (/* binding */ getAdditiveCoeff),
  WW: () => (/* binding */ getDKLSCoeff),
  $g: () => (/* binding */ getDenormaliseCoeff),
  $e: () => (/* binding */ getEc),
  OW: () => (/* binding */ getLagrangeCoeffs),
  xO: () => (/* binding */ getTSSPubKey),
  q2: () => (/* binding */ setupSockets)
});

// EXTERNAL MODULE: external "bn.js"
var external_bn_js_ = __webpack_require__(415);
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_);
;// CONCATENATED MODULE: external "elliptic"
const external_elliptic_namespaceObject = require("elliptic");
;// CONCATENATED MODULE: external "socket.io-client"
const external_socket_io_client_namespaceObject = require("socket.io-client");
;// CONCATENATED MODULE: ./src/utils.ts



function getEc() {
  return new external_elliptic_namespaceObject.ec("secp256k1");
}
function getLagrangeCoeffs(_allIndexes, _myIndex) {
  let _target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const ec = getEc();
  const allIndexes = _allIndexes.map(i => new (external_bn_js_default())(i));
  const myIndex = new (external_bn_js_default())(_myIndex);
  const target = new (external_bn_js_default())(_target);
  let upper = new (external_bn_js_default())(1);
  let lower = new (external_bn_js_default())(1);
  for (let j = 0; j < allIndexes.length; j += 1) {
    if (myIndex.cmp(allIndexes[j]) !== 0) {
      let tempUpper = target.sub(allIndexes[j]);
      tempUpper = tempUpper.umod(ec.curve.n);
      upper = upper.mul(tempUpper);
      upper = upper.umod(ec.curve.n);
      let tempLower = myIndex.sub(allIndexes[j]);
      tempLower = tempLower.umod(ec.curve.n);
      lower = lower.mul(tempLower).umod(ec.curve.n);
    }
  }
  return upper.mul(lower.invm(ec.curve.n)).umod(ec.curve.n);
}
function ecPoint(p) {
  const ec = getEc();
  return ec.keyFromPublic({
    x: p.x.padStart(64, "0"),
    y: p.y.padStart(64, "0")
  }).getPublic();
}
const getAdditiveCoeff = (isUser, participatingServerIndexes, userTSSIndex, serverIndex) => {
  const ec = getEc();
  if (isUser) {
    return getLagrangeCoeffs([1, userTSSIndex], userTSSIndex);
  }
  // generate the lagrange coeff that converts the current server DKG share into an additive sharing
  const serverLagrangeCoeff = getLagrangeCoeffs(participatingServerIndexes, serverIndex);
  const masterLagrangeCoeff = getLagrangeCoeffs([1, userTSSIndex], 1);
  const additiveLagrangeCoeff = serverLagrangeCoeff.mul(masterLagrangeCoeff).umod(ec.curve.n);
  return additiveLagrangeCoeff;
};

// Note: this is only needed for DKLS and not for FROST
const getDenormaliseCoeff = (party, parties) => {
  if (parties.indexOf(party) === -1) throw new Error(`party ${party} not found in parties ${parties}`);
  const ec = getEc();
  // generate the lagrange coeff that denormalises the additive sharing into the shamir sharing that TSS is expecting
  const denormaliseLagrangeCoeff = getLagrangeCoeffs(parties, party).invm(ec.curve.n).umod(ec.curve.n);
  return denormaliseLagrangeCoeff;
};
const getDKLSCoeff = (isUser, participatingServerIndexes, userTSSIndex, serverIndex) => {
  const sortedServerIndexes = participatingServerIndexes.sort((a, b) => a - b);
  for (let i = 0; i < sortedServerIndexes.length; i++) {
    if (sortedServerIndexes[i] !== participatingServerIndexes[i]) throw new Error("server indexes must be sorted");
  }
  // generate denormalise coeff for DKLS
  const parties = [];

  // total number of parties for DKLS = total number of servers + 1 (user is the last party)
  // server party indexes
  let serverPartyIndex = 0;
  for (let i = 0; i < participatingServerIndexes.length; i++) {
    const currentPartyIndex = i + 1;
    parties.push(currentPartyIndex);
    if (participatingServerIndexes[i] === serverIndex) serverPartyIndex = currentPartyIndex;
  }
  const userPartyIndex = parties.length + 1;
  parties.push(userPartyIndex); // user party index
  if (isUser) {
    const additiveCoeff = getAdditiveCoeff(isUser, participatingServerIndexes, userTSSIndex, serverIndex);
    const denormaliseCoeff = getDenormaliseCoeff(userPartyIndex, parties);
    const ec = getEc();
    return denormaliseCoeff.mul(additiveCoeff).umod(ec.curve.n);
  }
  const additiveCoeff = getAdditiveCoeff(isUser, participatingServerIndexes, userTSSIndex, serverIndex);
  const denormaliseCoeff = getDenormaliseCoeff(serverPartyIndex, parties);
  const ec = getEc();
  const coeff = denormaliseCoeff.mul(additiveCoeff).umod(ec.curve.n);
  return coeff;
};
const createSockets = async (wsEndpoints, sessionId) => {
  return wsEndpoints.map(wsEndpoint => {
    if (wsEndpoint === null || wsEndpoint === undefined) {
      return null;
    }
    return (0,external_socket_io_client_namespaceObject.io)(wsEndpoint, {
      path: "/tss/socket.io",
      query: {
        sessionId
      },
      transports: ["websocket", "polling"],
      withCredentials: true,
      reconnectionDelayMax: 10000,
      reconnectionAttempts: 5
    });
  });
};
function getTSSPubKey(dkgPubKey, userSharePubKey, userTSSIndex) {
  const serverLagrangeCoeff = getLagrangeCoeffs([1, userTSSIndex], 1);
  const userLagrangeCoeff = getLagrangeCoeffs([1, userTSSIndex], userTSSIndex);
  const serverTerm = ecPoint(dkgPubKey).mul(serverLagrangeCoeff);
  const userTerm = ecPoint(userSharePubKey).mul(userLagrangeCoeff);
  return serverTerm.add(userTerm);
}
const generateEndpoints = (parties, clientIndex) => {
  const endpoints = [];
  const tssWSEndpoints = [];
  const partyIndexes = [];
  for (let i = 0; i < parties; i++) {
    partyIndexes.push(i);
    if (i === clientIndex) {
      endpoints.push(null);
      tssWSEndpoints.push(null);
    } else {
      endpoints.push(`https://sapphire-${i + 1}.auth.network/tss`);
      tssWSEndpoints.push(`https://sapphire-${i + 1}.auth.network`);
    }
  }
  return {
    endpoints,
    tssWSEndpoints,
    partyIndexes
  };
};
const setupSockets = async (tssWSEndpoints, sessionId) => {
  const sockets = await createSockets(tssWSEndpoints, sessionId);
  // wait for websockets to be connected
  await new Promise(resolve => {
    const checkConnectionTimer = setInterval(() => {
      for (let i = 0; i < sockets.length; i++) {
        if (sockets[i] !== null && !sockets[i].connected) return;
      }
      clearInterval(checkConnectionTimer);
      resolve(true);
    }, 100);
  });
  return sockets;
};

/***/ }),

/***/ 990:
/***/ ((module) => {

"use strict";
module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),

/***/ 415:
/***/ ((module) => {

"use strict";
module.exports = require("bn.js");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Client: () => (/* reexport safe */ _client__WEBPACK_IMPORTED_MODULE_0__.K),
/* harmony export */   DELIMITERS: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.l),
/* harmony export */   WEB3_SESSION_HEADER_KEY: () => (/* reexport safe */ _constants__WEBPACK_IMPORTED_MODULE_1__.V),
/* harmony export */   createSockets: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.Fq),
/* harmony export */   ecPoint: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.jX),
/* harmony export */   generateEndpoints: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.uG),
/* harmony export */   getAdditiveCoeff: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.i6),
/* harmony export */   getDKLSCoeff: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.WW),
/* harmony export */   getDenormaliseCoeff: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.$g),
/* harmony export */   getEc: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.$e),
/* harmony export */   getLagrangeCoeffs: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.OW),
/* harmony export */   getTSSPubKey: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.xO),
/* harmony export */   localStorageDB: () => (/* reexport safe */ _db__WEBPACK_IMPORTED_MODULE_2__.N),
/* harmony export */   setupSockets: () => (/* reexport safe */ _utils__WEBPACK_IMPORTED_MODULE_4__.q2)
/* harmony export */ });
/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(834);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(706);
/* harmony import */ var _db__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(689);
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(927);
/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_interfaces__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _interfaces__WEBPACK_IMPORTED_MODULE_3__) if(["default","Client","DELIMITERS","WEB3_SESSION_HEADER_KEY","localStorageDB"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _interfaces__WEBPACK_IMPORTED_MODULE_3__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(816);





})();

module.exports = __webpack_exports__;
/******/ })()
;