import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { secp256k1, stripHexPrefix, toPrivKeyEC } from '@tkey/common-types';
import { keccak256 } from '@toruslabs/torus.js';
import stringify from 'json-stable-stringify';
import CoreError from './errors.js';
import Metadata from './metadata.js';

class AuthMetadata {
  constructor(metadata, privKey) {
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "privKey", void 0);
    this.metadata = metadata;
    this.privKey = privKey;
  }
  static fromJSON(value) {
    const {
      data,
      sig
    } = value;
    if (!data) throw CoreError.metadataUndefined();
    const m = Metadata.fromJSON(data);
    if (!m.pubKey) throw CoreError.metadataPubKeyUnavailable();
    const keyPair = secp256k1.keyFromPublic(m.pubKey.toSEC1(secp256k1));
    if (!keyPair.verify(stripHexPrefix(keccak256(Buffer.from(stringify(data), "utf8"))), sig)) {
      throw CoreError.default("Signature not valid for returning metadata");
    }
    return new AuthMetadata(m);
  }
  toJSON() {
    const data = this.metadata;
    if (!this.privKey) throw CoreError.privKeyUnavailable();
    const k = toPrivKeyEC(this.privKey);
    const sig = k.sign(stripHexPrefix(keccak256(Buffer.from(stringify(data), "utf8"))));
    return {
      data,
      sig: sig.toDER("hex")
    };
  }
}
var AuthMetadata$1 = AuthMetadata;

export { AuthMetadata$1 as default };
