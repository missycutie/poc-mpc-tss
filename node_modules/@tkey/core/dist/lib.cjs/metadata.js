'use strict';

var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var commonTypes = require('@tkey/common-types');
var BN = require('bn.js');
var stringify = require('json-stable-stringify');
var errors = require('./errors.js');
var lagrangeInterpolatePolynomial = require('./lagrangeInterpolatePolynomial.js');

class Metadata {
  constructor(input) {
    _defineProperty(this, "pubKey", void 0);
    _defineProperty(this, "publicPolynomials", void 0);
    _defineProperty(this, "publicShares", void 0);
    // Tuple of PolyID and array of ShareIndexes
    _defineProperty(this, "polyIDList", void 0);
    _defineProperty(this, "generalStore", void 0);
    _defineProperty(this, "tkeyStore", void 0);
    _defineProperty(this, "scopedStore", void 0);
    _defineProperty(this, "nonce", void 0);
    _defineProperty(this, "tssKeyTypes", void 0);
    _defineProperty(this, "tssNonces", void 0);
    _defineProperty(this, "tssPolyCommits", void 0);
    _defineProperty(this, "factorPubs", void 0);
    _defineProperty(this, "factorEncs", void 0);
    this.publicPolynomials = {};
    this.publicShares = {};
    this.generalStore = {};
    this.tkeyStore = {};
    this.scopedStore = {};
    this.pubKey = input;
    this.polyIDList = [];
    this.nonce = 0;
    this.tssKeyTypes = {};
    this.tssPolyCommits = {};
    this.tssNonces = {};
    this.factorPubs = {};
    this.factorEncs = {};
  }
  static fromJSON(value) {
    const {
      pubKey,
      polyIDList,
      generalStore,
      tkeyStore,
      scopedStore,
      nonce,
      tssKeyTypes,
      tssPolyCommits,
      tssNonces,
      factorPubs,
      factorEncs
    } = value;
    const point = commonTypes.Point.fromSEC1(commonTypes.secp256k1, pubKey);
    const metadata = new Metadata(point);
    const unserializedPolyIDList = [];
    if (generalStore) metadata.generalStore = generalStore;
    if (tkeyStore) metadata.tkeyStore = tkeyStore;
    if (scopedStore) metadata.scopedStore = scopedStore;
    if (nonce) metadata.nonce = nonce;
    if (tssKeyTypes) {
      metadata.tssKeyTypes = {};
      for (const key in tssKeyTypes) {
        metadata.tssKeyTypes[key] = tssKeyTypes[key];
      }
    }
    if (tssPolyCommits) {
      metadata.tssPolyCommits = {};
      for (const key in tssPolyCommits) {
        metadata.tssPolyCommits[key] = tssPolyCommits[key].map(obj => new commonTypes.Point(obj.x, obj.y));
      }
    }
    if (tssNonces) {
      metadata.tssNonces = {};
      for (const key in tssNonces) {
        metadata.tssNonces[key] = tssNonces[key];
      }
    }
    if (factorPubs) {
      metadata.factorPubs = {};
      for (const key in factorPubs) {
        metadata.factorPubs[key] = factorPubs[key].map(obj => new commonTypes.Point(obj.x, obj.y));
      }
    }
    if (factorEncs) metadata.factorEncs = factorEncs;
    for (let i = 0; i < polyIDList.length; i += 1) {
      const serializedPolyID = polyIDList[i];
      const arrPolyID = serializedPolyID.split("|");
      const zeroIndex = arrPolyID.findIndex(v => v === "0x0");
      const firstHalf = arrPolyID.slice(0, zeroIndex);
      const secondHalf = arrPolyID.slice(zeroIndex + 1, arrPolyID.length);
      // for publicPolynomials
      const pubPolyID = firstHalf.join("|");
      const pointCommitments = [];
      firstHalf.forEach(compressedCommitment => {
        pointCommitments.push(commonTypes.Point.fromCompressedPub(compressedCommitment));
      });
      const publicPolynomial = new commonTypes.PublicPolynomial(pointCommitments);
      metadata.publicPolynomials[pubPolyID] = publicPolynomial;

      // for polyIDList
      unserializedPolyIDList.push([pubPolyID, secondHalf]);
    }
    metadata.polyIDList = unserializedPolyIDList;
    return metadata;
  }
  getShareIndexesForPolynomial(polyID) {
    const matchingPolyIDs = this.polyIDList.filter(tuple => tuple[0] === polyID);
    if (matchingPolyIDs.length < 1) {
      throw errors.default("there is no matching polyID");
    } else if (matchingPolyIDs.length > 1) {
      throw errors.default("there is more than one matching polyID");
    }
    return matchingPolyIDs[0][1];
  }
  getLatestPublicPolynomial() {
    return this.publicPolynomials[this.polyIDList[this.polyIDList.length - 1][0]];
  }
  addPublicShare(polynomialID, publicShare) {
    if (!(polynomialID in this.publicShares)) {
      this.publicShares[polynomialID] = {};
    }
    this.publicShares[polynomialID][publicShare.shareIndex.toString("hex")] = publicShare;
  }
  setGeneralStoreDomain(key, obj) {
    this.generalStore[key] = obj;
  }
  getGeneralStoreDomain(key) {
    return this.generalStore[key];
  }
  deleteGeneralStoreDomain(key) {
    delete this.generalStore[key];
  }
  setTkeyStoreDomain(key, arr) {
    this.tkeyStore[key] = arr;
  }
  getTkeyStoreDomain(key) {
    return this.tkeyStore[key];
  }

  // appends shares and public polynomial to metadata.
  // should represent a generation of share or edit of threshold
  addFromPolynomialAndShares(polynomial, shares) {
    const publicPolynomial = polynomial.getPublicPolynomial();
    const polyID = publicPolynomial.getPolynomialID();
    this.publicPolynomials[polyID] = publicPolynomial;
    const shareIndexArr = [];
    if (Array.isArray(shares)) {
      for (let i = 0; i < shares.length; i += 1) {
        this.addPublicShare(publicPolynomial.getPolynomialID(), shares[i].getPublicShare());
        shareIndexArr.push(shares[i].shareIndex.toString("hex"));
      }
    } else {
      for (const k in shares) {
        if (Object.prototype.hasOwnProperty.call(shares, k)) {
          this.addPublicShare(publicPolynomial.getPolynomialID(), shares[k].getPublicShare());
          shareIndexArr.push(shares[k].shareIndex.toString("hex"));
        }
      }
    }
    this.polyIDList.push([polyID, shareIndexArr]);
  }
  setScopedStore(domain, data) {
    this.scopedStore[domain] = data;
  }
  async getEncryptedShare(shareStore) {
    const pubShare = shareStore.share.getPublicShare();
    const encryptedShareStore = this.scopedStore.encryptedShares;
    if (!encryptedShareStore) {
      throw errors.encryptedShareStoreUnavailable(`${shareStore}`);
    }
    const encryptedShare = encryptedShareStore[pubShare.shareCommitment.x.toString("hex")];
    if (!encryptedShare) {
      throw errors.encryptedShareStoreUnavailable(`${shareStore}`);
    }
    const rawDecrypted = await commonTypes.decrypt(commonTypes.toPrivKeyECC(shareStore.share.share), encryptedShare);
    return commonTypes.ShareStore.fromJSON(JSON.parse(rawDecrypted.toString()));
  }
  getShareDescription() {
    return this.getGeneralStoreDomain("shareDescriptions");
  }
  addShareDescription(shareIndex, description) {
    const currentSD = this.getGeneralStoreDomain("shareDescriptions") || {};
    if (currentSD[shareIndex]) {
      currentSD[shareIndex].push(description);
    } else {
      currentSD[shareIndex] = [description];
    }
    this.setGeneralStoreDomain("shareDescriptions", currentSD);
  }
  deleteShareDescription(shareIndex, description) {
    const currentSD = this.getGeneralStoreDomain("shareDescriptions");
    const index = currentSD[shareIndex].indexOf(description);
    if (index > -1) {
      currentSD[shareIndex].splice(index, 1);
    } else {
      throw errors.default(`No share description found for the given shareIndex: ${shareIndex} 
        and description: ${description}`);
    }
  }
  updateShareDescription(shareIndex, oldDescription, newDescription) {
    const currentSD = this.getGeneralStoreDomain("shareDescriptions");
    const index = currentSD[shareIndex].indexOf(oldDescription);
    if (index > -1) {
      currentSD[shareIndex][index] = newDescription;
    } else {
      throw errors.default(`No share description found for the given shareIndex:
        ${shareIndex} and description: ${oldDescription}`);
    }
  }
  shareToShareStore(share) {
    const pubkey = commonTypes.getPubKeyPoint(share);
    for (let i = this.polyIDList.length - 1; i >= 0; i -= 1) {
      const el = this.polyIDList[i][0];
      for (let t = 0; t < this.polyIDList[i][1].length; t += 1) {
        const shareIndex = this.polyIDList[i][1][t];
        // find pubshare in cache if its there
        let pubShare;
        if (this.publicShares[el]) {
          if (this.publicShares[el][shareIndex]) {
            pubShare = this.publicShares[el][shareIndex];
          }
        }

        // if not reconstruct
        if (!pubShare) {
          pubShare = new commonTypes.PublicShare(shareIndex, lagrangeInterpolatePolynomial.polyCommitmentEval(this.publicPolynomials[el].polynomialCommitments, new BN(shareIndex, "hex")));
        }
        if (pubShare.shareCommitment.x.eq(pubkey.x) && pubShare.shareCommitment.y.eq(pubkey.y)) {
          const tempShare = new commonTypes.Share(pubShare.shareIndex, share);
          return new commonTypes.ShareStore(tempShare, el);
        }
      }
    }
    {
      throw errors.fromCode(1307);
    }
  }
  clone() {
    return Metadata.fromJSON(JSON.parse(stringify(this)));
  }
  toJSON() {
    // squash data to serialized polyID according to spec
    const serializedPolyIDList = [];
    for (let i = 0; i < this.polyIDList.length; i += 1) {
      const polyID = this.polyIDList[i][0];
      const shareIndexes = this.polyIDList[i][1];
      const sortedShareIndexes = shareIndexes.sort((a, b) => new BN(a, "hex").cmp(new BN(b, "hex")));
      const serializedPolyID = polyID.split(`|`).concat("0x0").concat(...sortedShareIndexes).join("|");
      serializedPolyIDList.push(serializedPolyID);
    }
    return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({
      pubKey: this.pubKey.toSEC1(commonTypes.secp256k1, true).toString("hex"),
      polyIDList: serializedPolyIDList,
      scopedStore: this.scopedStore,
      generalStore: this.generalStore,
      tkeyStore: this.tkeyStore,
      nonce: this.nonce
    }, this.tssKeyTypes && {
      tssKeyTypes: this.tssKeyTypes
    }), this.tssNonces && {
      tssNonces: this.tssNonces
    }), this.tssPolyCommits && {
      tssPolyCommits: this.tssPolyCommits
    }), this.factorPubs && {
      factorPubs: this.factorPubs
    }), this.factorEncs && {
      factorEncs: this.factorEncs
    });
  }

  /**
   * Updates the TSS metadata for the given tag.
   */
  updateTSSData(tssData) {
    const {
      tssKeyType,
      tssTag,
      tssNonce,
      tssPolyCommits,
      factorPubs,
      factorEncs
    } = tssData;
    if (tssKeyType) this.tssKeyTypes[tssTag] = tssKeyType;
    if (tssNonce !== undefined) this.tssNonces[tssTag] = tssNonce;
    if (tssPolyCommits) this.tssPolyCommits[tssTag] = tssPolyCommits;
    if (factorPubs) this.factorPubs[tssTag] = factorPubs;
    if (factorEncs) this.factorEncs[tssTag] = factorEncs;
  }
}
var Metadata$1 = Metadata;

module.exports = Metadata$1;
