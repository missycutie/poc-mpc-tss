'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var commonTypes = require('@tkey/common-types');
var torus_js = require('@toruslabs/torus.js');
var stringify = require('json-stable-stringify');
var errors = require('./errors.js');
var metadata = require('./metadata.js');

class AuthMetadata {
  constructor(metadata, privKey) {
    _defineProperty(this, "metadata", void 0);
    _defineProperty(this, "privKey", void 0);
    this.metadata = metadata;
    this.privKey = privKey;
  }
  static fromJSON(value) {
    const {
      data,
      sig
    } = value;
    if (!data) throw errors.metadataUndefined();
    const m = metadata.fromJSON(data);
    if (!m.pubKey) throw errors.metadataPubKeyUnavailable();
    const keyPair = commonTypes.secp256k1.keyFromPublic(m.pubKey.toSEC1(commonTypes.secp256k1));
    if (!keyPair.verify(commonTypes.stripHexPrefix(torus_js.keccak256(Buffer.from(stringify(data), "utf8"))), sig)) {
      throw errors.default("Signature not valid for returning metadata");
    }
    return new AuthMetadata(m);
  }
  toJSON() {
    const data = this.metadata;
    if (!this.privKey) throw errors.privKeyUnavailable();
    const k = commonTypes.toPrivKeyEC(this.privKey);
    const sig = k.sign(commonTypes.stripHexPrefix(torus_js.keccak256(Buffer.from(stringify(data), "utf8"))));
    return {
      data,
      sig: sig.toDER("hex")
    };
  }
}
var AuthMetadata$1 = AuthMetadata;

module.exports = AuthMetadata$1;
