import _defineProperty from '@babel/runtime/helpers/defineProperty';
import BN from 'bn.js';
import { secp256k1 } from '../utils.js';

class Point {
  constructor(x, y) {
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    this.x = new BN(x, "hex");
    this.y = new BN(y, "hex");
  }
  static fromScalar(s, ec) {
    const p = ec.g.mul(s);
    return Point.fromElliptic(p);
  }

  /**
   * @deprecated Use `fromSEC1` instead.
   */
  static fromCompressedPub(value) {
    const key = secp256k1.keyFromPublic(value, "hex");
    const pt = key.getPublic();
    return new Point(pt.getX(), pt.getY());
  }
  static fromJSON(value) {
    const {
      x,
      y
    } = value;
    return new Point(x, y);
  }
  static fromElliptic(p) {
    if (p.isInfinity()) {
      return new Point(null, null);
    }
    return new Point(p.getX(), p.getY());
  }

  /**
   * Construct a point from SEC1 format.
   */
  static fromSEC1(ec, encodedPoint) {
    // "elliptic"@6.5.4 can't decode identity.
    if (encodedPoint.length === 2 && encodedPoint === "00") {
      const identity = ec.g.mul(new BN(0));
      return Point.fromElliptic(identity);
    }
    const key = ec.keyFromPublic(encodedPoint, "hex");
    const pt = key.getPublic();
    return Point.fromElliptic(pt);
  }

  /**
   * @deprecated Use `toSEC1` instead.
   *
   * complies with EC and elliptic pub key types
   */
  encode(enc) {
    switch (enc) {
      case "arr":
        return Buffer.concat([Buffer.from("0x04", "hex"), Buffer.from(this.x.toString("hex"), "hex"), Buffer.from(this.y.toString("hex"), "hex")]);
      case "elliptic-compressed":
        {
          const ec = secp256k1;
          const key = ec.keyFromPublic({
            x: this.x.toString("hex"),
            y: this.y.toString("hex")
          }, "hex");
          return Buffer.from(key.getPublic(true, "hex"));
        }
      default:
        throw new Error("encoding doesnt exist in Point");
    }
  }
  toEllipticPoint(ec) {
    if (this.isIdentity()) {
      return ec.g.mul(new BN(0));
    }
    const keyPair = ec.keyFromPublic({
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    }, "hex");
    return keyPair.getPublic();
  }

  /**
   * Returns this point encoded in SEC1 format.
   * @param ec - Curve which point is on.
   * @param compressed - Whether to use compressed format.
   * @returns The SEC1-encoded point.
   */
  toSEC1(ec, compressed = false) {
    // "elliptic"@6.5.4 can't encode identity.
    if (this.isIdentity()) {
      return Buffer.from("00", "hex");
    }
    const p = this.toEllipticPoint(ec);
    return Buffer.from(p.encode("hex", compressed), "hex");
  }
  toJSON() {
    return {
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    };
  }
  isIdentity() {
    return this.x === null && this.y === null;
  }
  equals(p) {
    if (this.isIdentity()) {
      return p.isIdentity();
    }
    return this.x.eq(p.x) && this.y.eq(p.y);
  }
}
var Point$1 = Point;

export { Point$1 as default };
