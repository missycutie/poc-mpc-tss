'use strict';

var customauth = require('@toruslabs/customauth');
var eccrypto = require('@toruslabs/eccrypto');
var torus_js = require('@toruslabs/torus.js');
var BN = require('bn.js');
var elliptic = require('elliptic');

const secp256k1 = new elliptic.ec("secp256k1");

// Wrappers around ECC encrypt/decrypt to use the hex serialization
// TODO: refactor to take BN
async function encrypt(publicKey, msg) {
  const encryptedDetails = await eccrypto.encrypt(publicKey, msg);
  return {
    ciphertext: encryptedDetails.ciphertext.toString("hex"),
    ephemPublicKey: encryptedDetails.ephemPublicKey.toString("hex"),
    iv: encryptedDetails.iv.toString("hex"),
    mac: encryptedDetails.mac.toString("hex")
  };
}
async function decrypt(privKey, msg) {
  const bufferEncDetails = {
    ciphertext: Buffer.from(msg.ciphertext, "hex"),
    ephemPublicKey: Buffer.from(msg.ephemPublicKey, "hex"),
    iv: Buffer.from(msg.iv, "hex"),
    mac: Buffer.from(msg.mac, "hex")
  };
  return eccrypto.decrypt(privKey, bufferEncDetails);
}
function isEmptyObject(obj) {
  return Object.keys(obj).length === 0 && obj.constructor === Object;
}
const isErrorObj = err => err && err.stack && err.message !== "";
async function prettyPrintError(error) {
  if (isErrorObj(error)) {
    return error;
  }
  return customauth.serializeError(error);
}
function generateAddressFromPublicKey(publicKey) {
  const ethAddressLower = `0x${torus_js.keccak256(publicKey).slice(64 - 38)}`;
  return torus_js.toChecksumAddress(ethAddressLower);
}
function normalize(input) {
  if (!input) {
    return undefined;
  }
  let hexString;
  if (typeof input === "number") {
    hexString = input.toString(16);
    if (hexString.length % 2) {
      hexString = `0${hexString}`;
    }
  }
  if (typeof input === "string") {
    hexString = input.toLowerCase();
  }
  return `0x${hexString}`;
}
function generatePrivateExcludingIndexes(shareIndexes) {
  const key = new BN(eccrypto.generatePrivate());
  if (shareIndexes.find(el => el.eq(key))) {
    return generatePrivateExcludingIndexes(shareIndexes);
  }
  return key;
}
const KEY_NOT_FOUND = "KEY_NOT_FOUND";
const SHARE_DELETED = "SHARE_DELETED";
function derivePubKeyXFromPolyID(polyID) {
  return polyID.split("|")[0].slice(2);
}
function stripHexPrefix(str) {
  if (str.slice(0, 2) === "0x") return str.slice(2);
  return str;
}
function generateID() {
  // Math.random should be unique because of its seeding algorithm.
  // Convert it to base 36 (numbers + letters), and grab the first 9 characters
  // after the decimal.
  return `${Math.random().toString(36).substr(2, 9)}`;
}

exports.KEY_NOT_FOUND = KEY_NOT_FOUND;
exports.SHARE_DELETED = SHARE_DELETED;
exports.decrypt = decrypt;
exports.derivePubKeyXFromPolyID = derivePubKeyXFromPolyID;
exports.encrypt = encrypt;
exports.generateAddressFromPublicKey = generateAddressFromPublicKey;
exports.generateID = generateID;
exports.generatePrivateExcludingIndexes = generatePrivateExcludingIndexes;
exports.isEmptyObject = isEmptyObject;
exports.isErrorObj = isErrorObj;
exports.normalize = normalize;
exports.prettyPrintError = prettyPrintError;
exports.secp256k1 = secp256k1;
exports.stripHexPrefix = stripHexPrefix;
