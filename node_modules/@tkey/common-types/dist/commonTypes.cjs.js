/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  KEY_NOT_FOUND: () => (/* reexport */ KEY_NOT_FOUND),
  KeyType: () => (/* reexport */ KeyType),
  ONE_KEY_DELETE_NONCE: () => (/* reexport */ ONE_KEY_DELETE_NONCE),
  ONE_KEY_NAMESPACE: () => (/* reexport */ ONE_KEY_NAMESPACE),
  Point: () => (/* reexport */ base_Point),
  Polynomial: () => (/* reexport */ base_Polynomial),
  PublicPolynomial: () => (/* reexport */ base_PublicPolynomial),
  PublicShare: () => (/* reexport */ base_PublicShare),
  SHARE_DELETED: () => (/* reexport */ SHARE_DELETED),
  Share: () => (/* reexport */ base_Share),
  ShareStore: () => (/* reexport */ base_ShareStore),
  TkeyError: () => (/* reexport */ TkeyError),
  decrypt: () => (/* reexport */ decrypt),
  derivePubKeyXFromPolyID: () => (/* reexport */ derivePubKeyXFromPolyID),
  encrypt: () => (/* reexport */ encrypt),
  generateAddressFromPublicKey: () => (/* reexport */ generateAddressFromPublicKey),
  generateID: () => (/* reexport */ generateID),
  generatePrivateExcludingIndexes: () => (/* reexport */ generatePrivateExcludingIndexes),
  getPubKeyEC: () => (/* reexport */ getPubKeyEC),
  getPubKeyECC: () => (/* reexport */ getPubKeyECC),
  getPubKeyPoint: () => (/* reexport */ getPubKeyPoint),
  isEmptyObject: () => (/* reexport */ isEmptyObject),
  isErrorObj: () => (/* reexport */ isErrorObj),
  normalize: () => (/* reexport */ normalize),
  prettyPrintError: () => (/* reexport */ prettyPrintError),
  secp256k1: () => (/* reexport */ secp256k1),
  stripHexPrefix: () => (/* reexport */ stripHexPrefix),
  toPrivKeyEC: () => (/* reexport */ toPrivKeyEC),
  toPrivKeyECC: () => (/* reexport */ toPrivKeyECC)
});

;// CONCATENATED MODULE: external "@toruslabs/eccrypto"
const eccrypto_namespaceObject = require("@toruslabs/eccrypto");
;// CONCATENATED MODULE: external "bn.js"
const external_bn_js_namespaceObject = require("bn.js");
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_namespaceObject);
;// CONCATENATED MODULE: external "@toruslabs/customauth"
const customauth_namespaceObject = require("@toruslabs/customauth");
;// CONCATENATED MODULE: external "@toruslabs/torus.js"
const torus_js_namespaceObject = require("@toruslabs/torus.js");
;// CONCATENATED MODULE: external "elliptic"
const external_elliptic_namespaceObject = require("elliptic");
;// CONCATENATED MODULE: ./src/utils.ts





const secp256k1 = new external_elliptic_namespaceObject.ec("secp256k1");

// Wrappers around ECC encrypt/decrypt to use the hex serialization
// TODO: refactor to take BN
async function encrypt(publicKey, msg) {
  const encryptedDetails = await (0,eccrypto_namespaceObject.encrypt)(publicKey, msg);
  return {
    ciphertext: encryptedDetails.ciphertext.toString("hex"),
    ephemPublicKey: encryptedDetails.ephemPublicKey.toString("hex"),
    iv: encryptedDetails.iv.toString("hex"),
    mac: encryptedDetails.mac.toString("hex")
  };
}
async function decrypt(privKey, msg) {
  const bufferEncDetails = {
    ciphertext: Buffer.from(msg.ciphertext, "hex"),
    ephemPublicKey: Buffer.from(msg.ephemPublicKey, "hex"),
    iv: Buffer.from(msg.iv, "hex"),
    mac: Buffer.from(msg.mac, "hex")
  };
  return (0,eccrypto_namespaceObject.decrypt)(privKey, bufferEncDetails);
}
function isEmptyObject(obj) {
  return Object.keys(obj).length === 0 && obj.constructor === Object;
}
const isErrorObj = err => err && err.stack && err.message !== "";
async function prettyPrintError(error) {
  if (isErrorObj(error)) {
    return error;
  }
  return (0,customauth_namespaceObject.serializeError)(error);
}
function generateAddressFromPublicKey(publicKey) {
  const ethAddressLower = `0x${(0,torus_js_namespaceObject.keccak256)(publicKey).slice(64 - 38)}`;
  return (0,torus_js_namespaceObject.toChecksumAddress)(ethAddressLower);
}
function normalize(input) {
  if (!input) {
    return undefined;
  }
  let hexString;
  if (typeof input === "number") {
    hexString = input.toString(16);
    if (hexString.length % 2) {
      hexString = `0${hexString}`;
    }
  }
  if (typeof input === "string") {
    hexString = input.toLowerCase();
  }
  return `0x${hexString}`;
}
function generatePrivateExcludingIndexes(shareIndexes) {
  const key = new (external_bn_js_default())((0,eccrypto_namespaceObject.generatePrivate)());
  if (shareIndexes.find(el => el.eq(key))) {
    return generatePrivateExcludingIndexes(shareIndexes);
  }
  return key;
}
const KEY_NOT_FOUND = "KEY_NOT_FOUND";
const SHARE_DELETED = "SHARE_DELETED";
function derivePubKeyXFromPolyID(polyID) {
  return polyID.split("|")[0].slice(2);
}
function stripHexPrefix(str) {
  if (str.slice(0, 2) === "0x") return str.slice(2);
  return str;
}
function generateID() {
  // Math.random should be unique because of its seeding algorithm.
  // Convert it to base 36 (numbers + letters), and grab the first 9 characters
  // after the decimal.
  return `${Math.random().toString(36).substr(2, 9)}`;
}
;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: ./src/base/Point.ts



class Point {
  constructor(x, y) {
    defineProperty_default()(this, "x", void 0);
    defineProperty_default()(this, "y", void 0);
    this.x = new (external_bn_js_default())(x, "hex");
    this.y = new (external_bn_js_default())(y, "hex");
  }
  static fromScalar(s, ec) {
    const p = ec.g.mul(s);
    return Point.fromElliptic(p);
  }

  /**
   * @deprecated Use `fromSEC1` instead.
   */
  static fromCompressedPub(value) {
    const key = secp256k1.keyFromPublic(value, "hex");
    const pt = key.getPublic();
    return new Point(pt.getX(), pt.getY());
  }
  static fromJSON(value) {
    const {
      x,
      y
    } = value;
    return new Point(x, y);
  }
  static fromElliptic(p) {
    if (p.isInfinity()) {
      return new Point(null, null);
    }
    return new Point(p.getX(), p.getY());
  }

  /**
   * Construct a point from SEC1 format.
   */
  static fromSEC1(ec, encodedPoint) {
    // "elliptic"@6.5.4 can't decode identity.
    if (encodedPoint.length === 2 && encodedPoint === "00") {
      const identity = ec.g.mul(new (external_bn_js_default())(0));
      return Point.fromElliptic(identity);
    }
    const key = ec.keyFromPublic(encodedPoint, "hex");
    const pt = key.getPublic();
    return Point.fromElliptic(pt);
  }

  /**
   * @deprecated Use `toSEC1` instead.
   *
   * complies with EC and elliptic pub key types
   */
  encode(enc) {
    switch (enc) {
      case "arr":
        return Buffer.concat([Buffer.from("0x04", "hex"), Buffer.from(this.x.toString("hex"), "hex"), Buffer.from(this.y.toString("hex"), "hex")]);
      case "elliptic-compressed":
        {
          const ec = secp256k1;
          const key = ec.keyFromPublic({
            x: this.x.toString("hex"),
            y: this.y.toString("hex")
          }, "hex");
          return Buffer.from(key.getPublic(true, "hex"));
        }
      default:
        throw new Error("encoding doesnt exist in Point");
    }
  }
  toEllipticPoint(ec) {
    if (this.isIdentity()) {
      return ec.g.mul(new (external_bn_js_default())(0));
    }
    const keyPair = ec.keyFromPublic({
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    }, "hex");
    return keyPair.getPublic();
  }

  /**
   * Returns this point encoded in SEC1 format.
   * @param ec - Curve which point is on.
   * @param compressed - Whether to use compressed format.
   * @returns The SEC1-encoded point.
   */
  toSEC1(ec, compressed = false) {
    // "elliptic"@6.5.4 can't encode identity.
    if (this.isIdentity()) {
      return Buffer.from("00", "hex");
    }
    const p = this.toEllipticPoint(ec);
    return Buffer.from(p.encode("hex", compressed), "hex");
  }
  toJSON() {
    return {
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    };
  }
  isIdentity() {
    return this.x === null && this.y === null;
  }
  equals(p) {
    if (this.isIdentity()) {
      return p.isIdentity();
    }
    return this.x.eq(p.x) && this.y.eq(p.y);
  }
}
/* harmony default export */ const base_Point = (Point);
;// CONCATENATED MODULE: ./src/base/BNUtils.ts





// These functions are here because BN can't be extended
const toPrivKeyEC = bn => secp256k1.keyFromPrivate(bn.toString("hex", 64));
const toPrivKeyECC = bn => {
  const tmp = new (external_bn_js_default())(bn, "hex");
  return Buffer.from(tmp.toString("hex", 64), "hex");
};
const getPubKeyEC = bn => secp256k1.keyFromPrivate(bn.toString("hex", 64)).getPublic();
const getPubKeyECC = bn => (0,eccrypto_namespaceObject.getPublic)(toPrivKeyECC(bn));
const getPubKeyPoint = bn => {
  const pubKeyEc = getPubKeyEC(bn);
  return new base_Point(pubKeyEc.getX().toString("hex"), pubKeyEc.getY().toString("hex"));
};
;// CONCATENATED MODULE: external "ts-custom-error"
const external_ts_custom_error_namespaceObject = require("ts-custom-error");
;// CONCATENATED MODULE: ./src/base/Error.ts



// @flow

class TkeyError extends external_ts_custom_error_namespaceObject.CustomError {
  constructor(code, message) {
    // takes care of stack and proto
    super(message);
    defineProperty_default()(this, "code", void 0);
    defineProperty_default()(this, "message", void 0);
    this.code = code;
    this.message = message || "";
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "TkeyError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
;// CONCATENATED MODULE: ./src/base/OneKey.ts
const ONE_KEY_DELETE_NONCE = "__ONE_KEY_DELETE_NONCE__";
const ONE_KEY_NAMESPACE = "noncev2";
;// CONCATENATED MODULE: ./src/base/PublicPolynomial.ts


class PublicPolynomial {
  constructor(polynomialCommitments) {
    defineProperty_default()(this, "polynomialCommitments", void 0);
    defineProperty_default()(this, "polynomialId", void 0);
    this.polynomialCommitments = polynomialCommitments;
  }
  static fromJSON(value) {
    const points = value.polynomialCommitments.map(x => base_Point.fromJSON(x));
    return new PublicPolynomial(points);
  }
  getThreshold() {
    return this.polynomialCommitments.length;
  }
  getPolynomialID() {
    let idSeed = "";
    for (let i = 0; i < this.polynomialCommitments.length; i += 1) {
      let nextChunk = this.polynomialCommitments[i].encode("elliptic-compressed").toString();
      if (i !== 0) {
        nextChunk = `|${nextChunk}`;
      }
      idSeed += nextChunk;
    }
    this.polynomialId = idSeed;
    return this.polynomialId;
  }
  toJSON() {
    return {
      polynomialCommitments: this.polynomialCommitments
    };
  }
}

// @flow

/* harmony default export */ const base_PublicPolynomial = (PublicPolynomial);
;// CONCATENATED MODULE: ./src/base/PublicShare.ts



class PublicShare {
  constructor(shareIndex, shareCommitment) {
    defineProperty_default()(this, "shareCommitment", void 0);
    defineProperty_default()(this, "shareIndex", void 0);
    this.shareCommitment = new base_Point(shareCommitment.x, shareCommitment.y);
    this.shareIndex = new (external_bn_js_default())(shareIndex, "hex");
  }
  static fromJSON(value) {
    const {
      shareCommitment,
      shareIndex
    } = value;
    return new PublicShare(shareIndex, base_Point.fromJSON(shareCommitment));
  }
  toJSON() {
    return {
      shareCommitment: this.shareCommitment,
      shareIndex: this.shareIndex.toString("hex")
    };
  }
}
/* harmony default export */ const base_PublicShare = (PublicShare);

// @flow
;// CONCATENATED MODULE: ./src/base/Share.ts




class Share {
  constructor(shareIndex, share) {
    defineProperty_default()(this, "share", void 0);
    defineProperty_default()(this, "shareIndex", void 0);
    this.share = new (external_bn_js_default())(share, "hex");
    this.shareIndex = new (external_bn_js_default())(shareIndex, "hex");
  }
  static fromJSON(value) {
    const {
      share,
      shareIndex
    } = value;
    return new Share(shareIndex, share);
  }
  getPublicShare() {
    return new base_PublicShare(this.shareIndex, getPubKeyPoint(this.share));
  }
  toJSON() {
    return {
      share: this.share.toString("hex"),
      shareIndex: this.shareIndex.toString("hex")
    };
  }
}
/* harmony default export */ const base_Share = (Share);
;// CONCATENATED MODULE: ./src/base/Polynomial.ts







// @flow

class Polynomial {
  constructor(polynomial) {
    defineProperty_default()(this, "polynomial", void 0);
    defineProperty_default()(this, "publicPolynomial", void 0);
    this.polynomial = polynomial;
  }
  static fromJSON(value) {
    const {
      polynomial
    } = value;
    return new Polynomial(polynomial.map(x => new (external_bn_js_default())(x, "hex")));
  }
  getThreshold() {
    return this.polynomial.length;
  }
  polyEval(x) {
    const tmpX = new (external_bn_js_default())(x, "hex");
    let xi = new (external_bn_js_default())(tmpX);
    let sum = new (external_bn_js_default())(0);
    sum = sum.add(this.polynomial[0]);
    for (let i = 1; i < this.polynomial.length; i += 1) {
      const tmp = xi.mul(this.polynomial[i]);
      sum = sum.add(tmp);
      sum = sum.umod(secp256k1.curve.n);
      xi = xi.mul(new (external_bn_js_default())(tmpX));
      xi = xi.umod(secp256k1.curve.n);
    }
    return sum;
  }
  generateShares(shareIndexes) {
    const newShareIndexes = shareIndexes.map(index => {
      if (typeof index === "number") {
        return new (external_bn_js_default())(index);
      }
      if (index instanceof (external_bn_js_default())) {
        return index;
      }
      if (typeof index === "string") {
        return new (external_bn_js_default())(index, "hex");
      }
      return index;
    });
    const shares = {};
    for (let x = 0; x < newShareIndexes.length; x += 1) {
      shares[newShareIndexes[x].toString("hex")] = new base_Share(newShareIndexes[x], this.polyEval(newShareIndexes[x]));
    }
    return shares;
  }
  getPublicPolynomial() {
    const polynomialCommitments = [];
    for (let i = 0; i < this.polynomial.length; i += 1) {
      polynomialCommitments.push(getPubKeyPoint(this.polynomial[i]));
    }
    this.publicPolynomial = new base_PublicPolynomial(polynomialCommitments);
    return this.publicPolynomial;
  }
  getPolynomialID() {
    return this.publicPolynomial.polynomialId;
  }
  toJSON() {
    return {
      polynomial: this.polynomial.map(x => x.toString("hex"))
    };
  }
}
/* harmony default export */ const base_Polynomial = (Polynomial);
;// CONCATENATED MODULE: ./src/base/ShareStore.ts


class ShareStore {
  constructor(share, polynomialID) {
    defineProperty_default()(this, "share", void 0);
    defineProperty_default()(this, "polynomialID", void 0);
    this.share = share;
    this.polynomialID = polynomialID;
  }
  static fromJSON(value) {
    const {
      share,
      polynomialID
    } = value;
    return new ShareStore(base_Share.fromJSON(share), polynomialID);
  }
  toJSON() {
    return {
      share: this.share,
      polynomialID: this.polynomialID.toString()
    };
  }
}

// @flow

/* harmony default export */ const base_ShareStore = (ShareStore);
;// CONCATENATED MODULE: ./src/base/index.ts













;// CONCATENATED MODULE: ./src/baseTypes/commonTypes.ts
// @flow

// eslint-disable-next-line @typescript-eslint/no-explicit-any

let KeyType = /*#__PURE__*/function (KeyType) {
  KeyType["secp256k1"] = "secp256k1";
  KeyType["ed25519"] = "ed25519";
  return KeyType;
}({});
;// CONCATENATED MODULE: ./src/index.ts




module.exports = __webpack_exports__;
/******/ })()
;