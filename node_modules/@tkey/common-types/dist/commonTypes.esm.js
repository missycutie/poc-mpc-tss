import { serializeError } from '@toruslabs/customauth';
import { encrypt as encrypt$1, decrypt as decrypt$1, generatePrivate, getPublic } from '@toruslabs/eccrypto';
import { keccak256, toChecksumAddress } from '@toruslabs/torus.js';
import BN from 'bn.js';
import { ec } from 'elliptic';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { CustomError } from 'ts-custom-error';

const secp256k1 = new ec("secp256k1");

// Wrappers around ECC encrypt/decrypt to use the hex serialization
// TODO: refactor to take BN
async function encrypt(publicKey, msg) {
  const encryptedDetails = await encrypt$1(publicKey, msg);
  return {
    ciphertext: encryptedDetails.ciphertext.toString("hex"),
    ephemPublicKey: encryptedDetails.ephemPublicKey.toString("hex"),
    iv: encryptedDetails.iv.toString("hex"),
    mac: encryptedDetails.mac.toString("hex")
  };
}
async function decrypt(privKey, msg) {
  const bufferEncDetails = {
    ciphertext: Buffer.from(msg.ciphertext, "hex"),
    ephemPublicKey: Buffer.from(msg.ephemPublicKey, "hex"),
    iv: Buffer.from(msg.iv, "hex"),
    mac: Buffer.from(msg.mac, "hex")
  };
  return decrypt$1(privKey, bufferEncDetails);
}
function isEmptyObject(obj) {
  return Object.keys(obj).length === 0 && obj.constructor === Object;
}
const isErrorObj = err => err && err.stack && err.message !== "";
async function prettyPrintError(error) {
  if (isErrorObj(error)) {
    return error;
  }
  return serializeError(error);
}
function generateAddressFromPublicKey(publicKey) {
  const ethAddressLower = `0x${keccak256(publicKey).slice(64 - 38)}`;
  return toChecksumAddress(ethAddressLower);
}
function normalize(input) {
  if (!input) {
    return undefined;
  }
  let hexString;
  if (typeof input === "number") {
    hexString = input.toString(16);
    if (hexString.length % 2) {
      hexString = `0${hexString}`;
    }
  }
  if (typeof input === "string") {
    hexString = input.toLowerCase();
  }
  return `0x${hexString}`;
}
function generatePrivateExcludingIndexes(shareIndexes) {
  const key = new BN(generatePrivate());
  if (shareIndexes.find(el => el.eq(key))) {
    return generatePrivateExcludingIndexes(shareIndexes);
  }
  return key;
}
const KEY_NOT_FOUND = "KEY_NOT_FOUND";
const SHARE_DELETED = "SHARE_DELETED";
function derivePubKeyXFromPolyID(polyID) {
  return polyID.split("|")[0].slice(2);
}
function stripHexPrefix(str) {
  if (str.slice(0, 2) === "0x") return str.slice(2);
  return str;
}
function generateID() {
  // Math.random should be unique because of its seeding algorithm.
  // Convert it to base 36 (numbers + letters), and grab the first 9 characters
  // after the decimal.
  return `${Math.random().toString(36).substr(2, 9)}`;
}

class Point {
  constructor(x, y) {
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    this.x = new BN(x, "hex");
    this.y = new BN(y, "hex");
  }
  static fromScalar(s, ec) {
    const p = ec.g.mul(s);
    return Point.fromElliptic(p);
  }

  /**
   * @deprecated Use `fromSEC1` instead.
   */
  static fromCompressedPub(value) {
    const key = secp256k1.keyFromPublic(value, "hex");
    const pt = key.getPublic();
    return new Point(pt.getX(), pt.getY());
  }
  static fromJSON(value) {
    const {
      x,
      y
    } = value;
    return new Point(x, y);
  }
  static fromElliptic(p) {
    if (p.isInfinity()) {
      return new Point(null, null);
    }
    return new Point(p.getX(), p.getY());
  }

  /**
   * Construct a point from SEC1 format.
   */
  static fromSEC1(ec, encodedPoint) {
    // "elliptic"@6.5.4 can't decode identity.
    if (encodedPoint.length === 2 && encodedPoint === "00") {
      const identity = ec.g.mul(new BN(0));
      return Point.fromElliptic(identity);
    }
    const key = ec.keyFromPublic(encodedPoint, "hex");
    const pt = key.getPublic();
    return Point.fromElliptic(pt);
  }

  /**
   * @deprecated Use `toSEC1` instead.
   *
   * complies with EC and elliptic pub key types
   */
  encode(enc) {
    switch (enc) {
      case "arr":
        return Buffer.concat([Buffer.from("0x04", "hex"), Buffer.from(this.x.toString("hex"), "hex"), Buffer.from(this.y.toString("hex"), "hex")]);
      case "elliptic-compressed":
        {
          const ec = secp256k1;
          const key = ec.keyFromPublic({
            x: this.x.toString("hex"),
            y: this.y.toString("hex")
          }, "hex");
          return Buffer.from(key.getPublic(true, "hex"));
        }
      default:
        throw new Error("encoding doesnt exist in Point");
    }
  }
  toEllipticPoint(ec) {
    if (this.isIdentity()) {
      return ec.g.mul(new BN(0));
    }
    const keyPair = ec.keyFromPublic({
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    }, "hex");
    return keyPair.getPublic();
  }

  /**
   * Returns this point encoded in SEC1 format.
   * @param ec - Curve which point is on.
   * @param compressed - Whether to use compressed format.
   * @returns The SEC1-encoded point.
   */
  toSEC1(ec, compressed = false) {
    // "elliptic"@6.5.4 can't encode identity.
    if (this.isIdentity()) {
      return Buffer.from("00", "hex");
    }
    const p = this.toEllipticPoint(ec);
    return Buffer.from(p.encode("hex", compressed), "hex");
  }
  toJSON() {
    return {
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    };
  }
  isIdentity() {
    return this.x === null && this.y === null;
  }
  equals(p) {
    if (this.isIdentity()) {
      return p.isIdentity();
    }
    return this.x.eq(p.x) && this.y.eq(p.y);
  }
}
var Point$1 = Point;

// These functions are here because BN can't be extended
const toPrivKeyEC = bn => secp256k1.keyFromPrivate(bn.toString("hex", 64));
const toPrivKeyECC = bn => {
  const tmp = new BN(bn, "hex");
  return Buffer.from(tmp.toString("hex", 64), "hex");
};
const getPubKeyEC = bn => secp256k1.keyFromPrivate(bn.toString("hex", 64)).getPublic();
const getPubKeyECC = bn => getPublic(toPrivKeyECC(bn));
const getPubKeyPoint = bn => {
  const pubKeyEc = getPubKeyEC(bn);
  return new Point$1(pubKeyEc.getX().toString("hex"), pubKeyEc.getY().toString("hex"));
};

// @flow

class TkeyError extends CustomError {
  constructor(code, message) {
    // takes care of stack and proto
    super(message);
    _defineProperty(this, "code", void 0);
    _defineProperty(this, "message", void 0);
    this.code = code;
    this.message = message || "";
    // Set name explicitly as minification can mangle class names
    Object.defineProperty(this, "name", {
      value: "TkeyError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}

const ONE_KEY_DELETE_NONCE = "__ONE_KEY_DELETE_NONCE__";
const ONE_KEY_NAMESPACE = "noncev2";

class PublicPolynomial {
  constructor(polynomialCommitments) {
    _defineProperty(this, "polynomialCommitments", void 0);
    _defineProperty(this, "polynomialId", void 0);
    this.polynomialCommitments = polynomialCommitments;
  }
  static fromJSON(value) {
    const points = value.polynomialCommitments.map(x => Point$1.fromJSON(x));
    return new PublicPolynomial(points);
  }
  getThreshold() {
    return this.polynomialCommitments.length;
  }
  getPolynomialID() {
    let idSeed = "";
    for (let i = 0; i < this.polynomialCommitments.length; i += 1) {
      let nextChunk = this.polynomialCommitments[i].encode("elliptic-compressed").toString();
      if (i !== 0) {
        nextChunk = `|${nextChunk}`;
      }
      idSeed += nextChunk;
    }
    this.polynomialId = idSeed;
    return this.polynomialId;
  }
  toJSON() {
    return {
      polynomialCommitments: this.polynomialCommitments
    };
  }
}

// @flow

var PublicPolynomial$1 = PublicPolynomial;

class PublicShare {
  constructor(shareIndex, shareCommitment) {
    _defineProperty(this, "shareCommitment", void 0);
    _defineProperty(this, "shareIndex", void 0);
    this.shareCommitment = new Point$1(shareCommitment.x, shareCommitment.y);
    this.shareIndex = new BN(shareIndex, "hex");
  }
  static fromJSON(value) {
    const {
      shareCommitment,
      shareIndex
    } = value;
    return new PublicShare(shareIndex, Point$1.fromJSON(shareCommitment));
  }
  toJSON() {
    return {
      shareCommitment: this.shareCommitment,
      shareIndex: this.shareIndex.toString("hex")
    };
  }
}
var PublicShare$1 = PublicShare;

// @flow

class Share {
  constructor(shareIndex, share) {
    _defineProperty(this, "share", void 0);
    _defineProperty(this, "shareIndex", void 0);
    this.share = new BN(share, "hex");
    this.shareIndex = new BN(shareIndex, "hex");
  }
  static fromJSON(value) {
    const {
      share,
      shareIndex
    } = value;
    return new Share(shareIndex, share);
  }
  getPublicShare() {
    return new PublicShare$1(this.shareIndex, getPubKeyPoint(this.share));
  }
  toJSON() {
    return {
      share: this.share.toString("hex"),
      shareIndex: this.shareIndex.toString("hex")
    };
  }
}
var Share$1 = Share;

// @flow

class Polynomial {
  constructor(polynomial) {
    _defineProperty(this, "polynomial", void 0);
    _defineProperty(this, "publicPolynomial", void 0);
    this.polynomial = polynomial;
  }
  static fromJSON(value) {
    const {
      polynomial
    } = value;
    return new Polynomial(polynomial.map(x => new BN(x, "hex")));
  }
  getThreshold() {
    return this.polynomial.length;
  }
  polyEval(x) {
    const tmpX = new BN(x, "hex");
    let xi = new BN(tmpX);
    let sum = new BN(0);
    sum = sum.add(this.polynomial[0]);
    for (let i = 1; i < this.polynomial.length; i += 1) {
      const tmp = xi.mul(this.polynomial[i]);
      sum = sum.add(tmp);
      sum = sum.umod(secp256k1.curve.n);
      xi = xi.mul(new BN(tmpX));
      xi = xi.umod(secp256k1.curve.n);
    }
    return sum;
  }
  generateShares(shareIndexes) {
    const newShareIndexes = shareIndexes.map(index => {
      if (typeof index === "number") {
        return new BN(index);
      }
      if (index instanceof BN) {
        return index;
      }
      if (typeof index === "string") {
        return new BN(index, "hex");
      }
      return index;
    });
    const shares = {};
    for (let x = 0; x < newShareIndexes.length; x += 1) {
      shares[newShareIndexes[x].toString("hex")] = new Share$1(newShareIndexes[x], this.polyEval(newShareIndexes[x]));
    }
    return shares;
  }
  getPublicPolynomial() {
    const polynomialCommitments = [];
    for (let i = 0; i < this.polynomial.length; i += 1) {
      polynomialCommitments.push(getPubKeyPoint(this.polynomial[i]));
    }
    this.publicPolynomial = new PublicPolynomial$1(polynomialCommitments);
    return this.publicPolynomial;
  }
  getPolynomialID() {
    return this.publicPolynomial.polynomialId;
  }
  toJSON() {
    return {
      polynomial: this.polynomial.map(x => x.toString("hex"))
    };
  }
}
var Polynomial$1 = Polynomial;

class ShareStore {
  constructor(share, polynomialID) {
    _defineProperty(this, "share", void 0);
    _defineProperty(this, "polynomialID", void 0);
    this.share = share;
    this.polynomialID = polynomialID;
  }
  static fromJSON(value) {
    const {
      share,
      polynomialID
    } = value;
    return new ShareStore(Share$1.fromJSON(share), polynomialID);
  }
  toJSON() {
    return {
      share: this.share,
      polynomialID: this.polynomialID.toString()
    };
  }
}

// @flow

var ShareStore$1 = ShareStore;

// @flow

// eslint-disable-next-line @typescript-eslint/no-explicit-any

let KeyType = /*#__PURE__*/function (KeyType) {
  KeyType["secp256k1"] = "secp256k1";
  KeyType["ed25519"] = "ed25519";
  return KeyType;
}({});

export { KEY_NOT_FOUND, KeyType, ONE_KEY_DELETE_NONCE, ONE_KEY_NAMESPACE, Point$1 as Point, Polynomial$1 as Polynomial, PublicPolynomial$1 as PublicPolynomial, PublicShare$1 as PublicShare, SHARE_DELETED, Share$1 as Share, ShareStore$1 as ShareStore, TkeyError, decrypt, derivePubKeyXFromPolyID, encrypt, generateAddressFromPublicKey, generateID, generatePrivateExcludingIndexes, getPubKeyEC, getPubKeyECC, getPubKeyPoint, isEmptyObject, isErrorObj, normalize, prettyPrintError, secp256k1, stripHexPrefix, toPrivKeyEC, toPrivKeyECC };
