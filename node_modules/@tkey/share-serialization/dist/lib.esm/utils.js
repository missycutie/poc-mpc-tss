import { sha256 } from 'ethereum-cryptography/sha256';
import ShareSerializationError from './errors.js';

function normalize(str) {
  return (str || "").normalize("NFKD");
}
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function lpad(str, padString, length) {
  let string = str;
  while (string.length < length) {
    string = padString + string;
  }
  return string;
}
function bytesToBinary(bytes) {
  return bytes.map(x => lpad(x.toString(2), "0", 8)).join("");
}
function deriveChecksumBits(entropyBuffer) {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash = sha256(entropyBuffer);
  return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function entropyToMnemonic(entropy, english) {
  let newEntropy;
  if (!Buffer.isBuffer(entropy)) {
    newEntropy = Buffer.from(entropy, "hex");
  }

  // 128 <= ENT <= 256
  if (newEntropy.length < 16) {
    throw ShareSerializationError.invalidEntropy();
  }
  if (newEntropy.length > 32) {
    throw ShareSerializationError.invalidEntropy();
  }
  if (newEntropy.length % 4 !== 0) {
    throw ShareSerializationError.invalidEntropy();
  }
  const entropyBits = bytesToBinary(Array.from(newEntropy));
  const checksumBits = deriveChecksumBits(newEntropy);
  const bits = entropyBits + checksumBits;
  const chunks = bits.match(/(.{1,11})/g);
  const words = chunks.map(binary => {
    const index = binaryToByte(binary);
    return english[index];
  });
  return english[0] === "\u3042\u3044\u3053\u304f\u3057\u3093" // Japanese wordlist
  ? words.join("\u3000") : words.join(" ");
}
function mnemonicToEntropy(mnemonic, english) {
  const words = normalize(mnemonic).split(" ");
  if (words.length % 3 !== 0) {
    throw ShareSerializationError.invalidMnemonic();
  }

  // convert word indices to 11 bit binary strings
  const bits = words.map(word => {
    const index = english.indexOf(word);
    if (index === -1) {
      throw ShareSerializationError.invalidMnemonic();
    }
    return lpad(index.toString(2), "0", 11);
  }).join("");

  // split the binary string into ENT/CS
  const dividerIndex = Math.floor(bits.length / 33) * 32;
  const entropyBits = bits.slice(0, dividerIndex);
  const checksumBits = bits.slice(dividerIndex);

  // calculate the checksum and compare
  const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
  if (entropyBytes.length < 16) {
    throw ShareSerializationError.invalidEntropy();
  }
  if (entropyBytes.length > 32) {
    throw ShareSerializationError.invalidEntropy();
  }
  if (entropyBytes.length % 4 !== 0) {
    throw ShareSerializationError.invalidEntropy();
  }
  const entropy = Buffer.from(entropyBytes);
  const newChecksum = deriveChecksumBits(entropy);
  if (newChecksum !== checksumBits) {
    throw ShareSerializationError.invalidChecksum();
  }
  return entropy.toString("hex");
}

export { binaryToByte, bytesToBinary, deriveChecksumBits, entropyToMnemonic, lpad, mnemonicToEntropy, normalize };
