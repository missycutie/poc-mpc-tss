'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var commonTypes = require('@tkey/common-types');
var httpHelpers = require('@toruslabs/http-helpers');
var base64url = require('base64url');
var BN = require('bn.js');
var keccak = require('ethereum-cryptography/keccak');
var stringify = require('json-stable-stringify');

function signDataWithPrivKey(data, privKey) {
  const sig = commonTypes.secp256k1.sign(keccak.keccak256(Buffer.from(stringify(data), "utf8")), commonTypes.toPrivKeyECC(privKey), "utf-8");
  return sig.toDER("hex");
}
class TorusStorageLayer {
  constructor({
    enableLogging = false,
    hostUrl = "http://localhost:5051",
    serverTimeOffset = 0
  }) {
    _defineProperty(this, "enableLogging", void 0);
    _defineProperty(this, "hostUrl", void 0);
    _defineProperty(this, "storageLayerName", void 0);
    _defineProperty(this, "serverTimeOffset", void 0);
    this.enableLogging = enableLogging;
    this.hostUrl = hostUrl;
    this.storageLayerName = "TorusStorageLayer";
    this.serverTimeOffset = serverTimeOffset;
  }
  static async serializeMetadataParamsInput(el, serviceProvider, privKey) {
    if (typeof el === "object") {
      // Allow using of special message as command, in which case, do not encrypt
      const obj = el;
      const isCommandMessage = obj.message === commonTypes.ONE_KEY_DELETE_NONCE;
      if (isCommandMessage) return obj.message;
    }

    // General case, encrypt message
    const bufferMetadata = Buffer.from(stringify(el));
    let encryptedDetails;
    if (privKey) {
      encryptedDetails = await commonTypes.encrypt(commonTypes.getPubKeyECC(privKey), bufferMetadata);
    } else {
      encryptedDetails = await serviceProvider.encrypt(bufferMetadata);
    }
    const serializedEncryptedDetails = base64url.encode(stringify(encryptedDetails));
    return serializedEncryptedDetails;
  }
  static fromJSON(value) {
    const {
      enableLogging,
      hostUrl,
      storageLayerName,
      serverTimeOffset = 0
    } = value;
    if (storageLayerName !== "TorusStorageLayer") return undefined;
    return new TorusStorageLayer({
      enableLogging,
      hostUrl,
      serverTimeOffset
    });
  }

  /**
   *  Get metadata for a key
   * @param privKey - If not provided, it will use service provider's share for decryption
   */
  async getMetadata(params) {
    const {
      serviceProvider,
      privKey
    } = params;
    const keyDetails = this.generateMetadataParams({}, serviceProvider, privKey);
    const metadataResponse = await httpHelpers.post(`${this.hostUrl}/get`, keyDetails);
    // returns empty object if object
    if (metadataResponse.message === "") {
      return {
        message: commonTypes.KEY_NOT_FOUND
      };
    }
    const encryptedMessage = JSON.parse(base64url.decode(metadataResponse.message));
    let decrypted;
    if (privKey) {
      decrypted = await commonTypes.decrypt(commonTypes.toPrivKeyECC(privKey), encryptedMessage);
    } else {
      decrypted = await serviceProvider.decrypt(encryptedMessage);
    }
    return JSON.parse(decrypted.toString());
  }

  /**
   * Set Metadata for a key
   * @param input - data to post
   * @param privKey - If not provided, it will use service provider's share for encryption
   */
  async setMetadata(params) {
    try {
      const {
        serviceProvider,
        privKey,
        input
      } = params;
      const metadataParams = this.generateMetadataParams(await TorusStorageLayer.serializeMetadataParamsInput(input, serviceProvider, privKey), serviceProvider, privKey);
      return await httpHelpers.post(`${this.hostUrl}/set`, metadataParams);
    } catch (error) {
      const prettyError = await commonTypes.prettyPrintError(error);
      throw prettyError;
    }
  }
  async setMetadataStream(params) {
    try {
      const {
        serviceProvider,
        privKey,
        input
      } = params;
      const newInput = input;
      const finalMetadataParams = await Promise.all(newInput.map(async (el, i) => this.generateMetadataParams(await TorusStorageLayer.serializeMetadataParamsInput(el, serviceProvider, privKey[i]), serviceProvider, privKey[i])));
      const FD = new FormData();
      finalMetadataParams.forEach((el, index) => {
        FD.append(index.toString(), JSON.stringify(el));
      });
      const options = {
        mode: "cors",
        method: "POST",
        headers: {
          // don't set ContentType header here. it's handled in http-helpers
        }
      };
      const customOptions = {
        isUrlEncodedData: true,
        timeout: 600 * 1000 // 10 mins of timeout for excessive shares case
      };
      return await httpHelpers.post(`${this.hostUrl}/bulk_set_stream`, FD, options, customOptions);
    } catch (error) {
      const prettyError = await commonTypes.prettyPrintError(error);
      throw prettyError;
    }
  }
  generateMetadataParams(message, serviceProvider, privKey) {
    let sig;
    let pubX;
    let pubY;
    let namespace = "tkey";
    const setTKeyStore = {
      data: message,
      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)
    };

    // Overwrite bulk_set to allow deleting nonce v2 together with creating tKey.
    // This is a workaround, a better solution is allow upstream API to set tableName/namespace of metadata params
    if (message === commonTypes.ONE_KEY_DELETE_NONCE) {
      namespace = commonTypes.ONE_KEY_NAMESPACE;
      setTKeyStore.data = "<deleted>";
    }
    const hash = keccak.keccak256(Buffer.from(stringify(setTKeyStore), "utf8"));
    if (privKey) {
      const unparsedSig = commonTypes.toPrivKeyEC(privKey).sign(hash);
      sig = Buffer.from(unparsedSig.r.toString(16, 64) + unparsedSig.s.toString(16, 64) + new BN(0).toString(16, 2), "hex").toString("base64");
      const pubK = commonTypes.getPubKeyPoint(privKey);
      pubX = pubK.x.toString("hex");
      pubY = pubK.y.toString("hex");
    } else {
      const point = serviceProvider.retrievePubKeyPoint();
      sig = serviceProvider.sign(new BN(hash));
      pubX = point.getX().toString("hex");
      pubY = point.getY().toString("hex");
    }
    return {
      pub_key_X: pubX,
      pub_key_Y: pubY,
      set_data: setTKeyStore,
      signature: sig,
      namespace
    };
  }
  async acquireWriteLock(params) {
    const {
      serviceProvider,
      privKey
    } = params;
    const data = {
      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000)
    };
    let signature;
    if (privKey) {
      signature = signDataWithPrivKey(data, privKey);
    } else {
      signature = serviceProvider.sign(new BN(keccak.keccak256(Buffer.from(stringify(data), "utf8"))));
    }
    const metadataParams = {
      key: commonTypes.toPrivKeyEC(privKey).getPublic("hex"),
      data,
      signature
    };
    return httpHelpers.post(`${this.hostUrl}/acquireLock`, metadataParams);
  }
  async releaseWriteLock(params) {
    const {
      serviceProvider,
      privKey,
      id
    } = params;
    const data = {
      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000)
    };
    let signature;
    if (privKey) {
      signature = signDataWithPrivKey(data, privKey);
    } else {
      signature = serviceProvider.sign(new BN(keccak.keccak256(Buffer.from(stringify(data), "utf8"))));
    }
    const metadataParams = {
      key: commonTypes.toPrivKeyEC(privKey).getPublic("hex"),
      data,
      signature,
      id
    };
    return httpHelpers.post(`${this.hostUrl}/releaseLock`, metadataParams);
  }
  toJSON() {
    return {
      enableLogging: this.enableLogging,
      hostUrl: this.hostUrl,
      storageLayerName: this.storageLayerName
    };
  }
}
var TorusStorageLayer$1 = TorusStorageLayer;

module.exports = TorusStorageLayer$1;
