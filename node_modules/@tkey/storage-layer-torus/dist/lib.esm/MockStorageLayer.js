import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { getPubKeyPoint, KEY_NOT_FOUND, generateID } from '@tkey/common-types';
import stringify from 'json-stable-stringify';

class MockStorageLayer {
  constructor({
    dataMap,
    lockMap
  } = {
    dataMap: {},
    lockMap: {}
  }) {
    _defineProperty(this, "dataMap", void 0);
    _defineProperty(this, "storageLayerName", void 0);
    _defineProperty(this, "lockMap", void 0);
    _defineProperty(this, "serviceProvider", void 0);
    this.dataMap = dataMap || {};
    this.lockMap = lockMap || {};
    this.storageLayerName = "MockStorageLayer";
  }
  static fromJSON(value) {
    const {
      dataMap,
      lockMap,
      storageLayerName
    } = value;
    if (storageLayerName !== "MockStorageLayer") return undefined;
    return new MockStorageLayer({
      dataMap,
      lockMap
    });
  }

  /**
   *  Get metadata for a key
   * @param privKey - If not provided, it will use service provider's share for decryption
   */
  async getMetadata(params) {
    const {
      serviceProvider,
      privKey
    } = params;
    let usedKey;
    if (!privKey) usedKey = serviceProvider.retrievePubKeyPoint().getX();else usedKey = getPubKeyPoint(privKey).x;
    const fromMap = this.dataMap[usedKey.toString("hex")];
    if (!fromMap) {
      return {
        message: KEY_NOT_FOUND
      };
    }
    return JSON.parse(this.dataMap[usedKey.toString("hex")]);
  }

  /**
   * Set Metadata for a key
   * @param input - data to post
   * @param privKey - If not provided, it will use service provider's share for encryption
   */
  async setMetadata(params) {
    const {
      serviceProvider,
      privKey,
      input
    } = params;
    let usedKey;
    if (!privKey) usedKey = serviceProvider.retrievePubKeyPoint().getX();else usedKey = getPubKeyPoint(privKey).x;
    this.dataMap[usedKey.toString("hex")] = stringify(input);
    return {
      message: "success"
    };
  }
  async setMetadataStream(params) {
    const {
      serviceProvider,
      privKey,
      input
    } = params;
    input.forEach((el, index) => {
      let usedKey;
      if (!privKey || !privKey[index]) usedKey = serviceProvider.retrievePubKeyPoint().getX();else usedKey = getPubKeyPoint(privKey[index]).x;
      this.dataMap[usedKey.toString("hex")] = stringify(el);
    });
    return {
      message: "success"
    };
  }
  async acquireWriteLock(params) {
    const {
      serviceProvider,
      privKey
    } = params;
    let usedKey;
    if (!privKey) usedKey = serviceProvider.retrievePubKeyPoint().getX();else usedKey = getPubKeyPoint(privKey).x;
    if (this.lockMap[usedKey.toString("hex")]) return {
      status: 0
    };
    const id = generateID();
    this.lockMap[usedKey.toString("hex")] = id;
    return {
      status: 1,
      id
    };
  }
  async releaseWriteLock(params) {
    const {
      serviceProvider,
      privKey,
      id
    } = params;
    let usedKey;
    if (!privKey) usedKey = serviceProvider.retrievePubKeyPoint().getX();else usedKey = getPubKeyPoint(privKey).x;
    if (!this.lockMap[usedKey.toString("hex")]) return {
      status: 0
    };
    if (id !== this.lockMap[usedKey.toString("hex")]) return {
      status: 2
    };
    this.lockMap[usedKey.toString("hex")] = null;
    return {
      status: 1
    };
  }
  toJSON() {
    return {
      dataMap: this.dataMap,
      serviceProvider: this.serviceProvider,
      storageLayerName: this.storageLayerName
    };
  }
}
var MockStorageLayer$1 = MockStorageLayer;

export { MockStorageLayer$1 as default };
