/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  DELIMITERS: () => (/* reexport */ DELIMITERS),
  FACTOR_KEY_TYPE: () => (/* reexport */ FACTOR_KEY_TYPE),
  LEGACY_KEY_TYPE: () => (/* reexport */ LEGACY_KEY_TYPE),
  TKeyTSS: () => (/* reexport */ TKeyTSS),
  TSSTorusServiceProvider: () => (/* reexport */ TSSTorusServiceProvider),
  TSS_MODULE: () => (/* reexport */ TSS_MODULE),
  TSS_TAG_DEFAULT: () => (/* reexport */ TSS_TAG_DEFAULT),
  factorKeyCurve: () => (/* reexport */ factorKeyCurve),
  generateSalt: () => (/* reexport */ generateSalt),
  getEd25519SeedStoreDomainKey: () => (/* reexport */ getEd25519SeedStoreDomainKey),
  getExtendedVerifierId: () => (/* reexport */ getExtendedVerifierId),
  getLagrangeCoeffs: () => (/* reexport */ getLagrangeCoeffs),
  getPubKeyPoint: () => (/* reexport */ getPubKeyPoint),
  kCombinations: () => (/* reexport */ kCombinations),
  lagrangeInterpolation: () => (/* reexport */ lagrangeInterpolation),
  pointToHex: () => (/* reexport */ pointToHex),
  randomSelection: () => (/* reexport */ rss_client_namespaceObject.randomSelection)
});

;// CONCATENATED MODULE: external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// CONCATENATED MODULE: external "@tkey/common-types"
const common_types_namespaceObject = require("@tkey/common-types");
;// CONCATENATED MODULE: external "@tkey/service-provider-torus"
const service_provider_torus_namespaceObject = require("@tkey/service-provider-torus");
;// CONCATENATED MODULE: external "bn.js"
const external_bn_js_namespaceObject = require("bn.js");
var external_bn_js_default = /*#__PURE__*/__webpack_require__.n(external_bn_js_namespaceObject);
;// CONCATENATED MODULE: ./src/util.ts


const kCombinations = (s, k) => {
  let set = s;
  if (typeof set === "number") {
    set = Array.from({
      length: set
    }, (_, i) => i);
  }
  if (k > set.length || k <= 0) {
    return [];
  }
  if (k === set.length) {
    return [set];
  }
  if (k === 1) {
    return set.reduce((acc, cur) => [...acc, [cur]], []);
  }
  const combs = [];
  let tailCombs = [];
  for (let i = 0; i <= set.length - k + 1; i += 1) {
    tailCombs = kCombinations(set.slice(i + 1), k - 1);
    for (let j = 0; j < tailCombs.length; j += 1) {
      combs.push([set[i], ...tailCombs[j]]);
    }
  }
  return combs;
};
function generateSalt(ec) {
  return ec.genKeyPair().getPrivate().toString("hex", 64);
}
function getLagrangeCoeffs(ecCurve, _allIndexes, _myIndex, _target = 0) {
  const allIndexes = _allIndexes.map(i => new (external_bn_js_default())(i));
  const myIndex = new (external_bn_js_default())(_myIndex);
  const target = new (external_bn_js_default())(_target);
  let upper = new (external_bn_js_default())(1);
  let lower = new (external_bn_js_default())(1);
  for (let j = 0; j < allIndexes.length; j += 1) {
    if (myIndex.cmp(allIndexes[j]) !== 0) {
      let tempUpper = target.sub(allIndexes[j]);
      tempUpper = tempUpper.umod(ecCurve.curve.n);
      upper = upper.mul(tempUpper);
      upper = upper.umod(ecCurve.curve.n);
      let tempLower = myIndex.sub(allIndexes[j]);
      tempLower = tempLower.umod(ecCurve.curve.n);
      lower = lower.mul(tempLower).umod(ecCurve.curve.n);
    }
  }
  return upper.mul(lower.invm(ecCurve.curve.n)).umod(ecCurve.curve.n);
}
function lagrangeInterpolation(ecCurve, shares, nodeIndex) {
  if (shares.length !== nodeIndex.length) {
    return null;
  }
  let secret = new (external_bn_js_default())(0);
  for (let i = 0; i < shares.length; i += 1) {
    let upper = new (external_bn_js_default())(1);
    let lower = new (external_bn_js_default())(1);
    for (let j = 0; j < shares.length; j += 1) {
      if (i !== j) {
        upper = upper.mul(nodeIndex[j].neg());
        upper = upper.umod(ecCurve.curve.n);
        let temp = nodeIndex[i].sub(nodeIndex[j]);
        temp = temp.umod(ecCurve.curve.n);
        lower = lower.mul(temp).umod(ecCurve.curve.n);
      }
    }
    let delta = upper.mul(lower.invm(ecCurve.curve.n)).umod(ecCurve.curve.n);
    delta = delta.mul(shares[i]).umod(ecCurve.curve.n);
    secret = secret.add(delta);
  }
  return secret.umod(ecCurve.curve.n);
}
function pointToHex(p) {
  return {
    x: p.x.toString(16, 64),
    y: p.y.toString(16, 64)
  };
}
function getPubKeyPoint(s, ec) {
  const p = ec.g.mul(s);
  return common_types_namespaceObject.Point.fromElliptic(p);
}
const DELIMITERS = {
  Delimiter1: "\u001c",
  Delimiter2: "\u0015",
  Delimiter3: "\u0016",
  Delimiter4: "\u0017"
};
function getExtendedVerifierId(verifierId, tssTag, tssNonce) {
  return `${verifierId}${DELIMITERS.Delimiter2}${tssTag}${DELIMITERS.Delimiter3}${tssNonce}`;
}
function getEd25519SeedStoreDomainKey(tssTag) {
  return tssTag ? `ed25519Seed/${tssTag}` : "ed25519Seed";
}
;// CONCATENATED MODULE: ./src/provider.ts




class TSSTorusServiceProvider extends service_provider_torus_namespaceObject.TorusServiceProvider {
  constructor(...args) {
    super(...args);
    defineProperty_default()(this, "verifierName", void 0);
    defineProperty_default()(this, "verifierId", void 0);
  }
  async getRSSNodeDetails() {
    if (!this.verifierId) throw new Error("no verifierId, not logged in");
    if (!this.verifierName) throw new Error("no verifierName, not logged in");
    const {
      torusNodeRSSEndpoints: tssNodeEndpoints,
      torusNodePub: torusPubKeys
    } = await this.customAuthInstance.nodeDetailManager.getNodeDetails({
      verifier: this.verifierName,
      verifierId: this.verifierId
    });
    return {
      serverEndpoints: tssNodeEndpoints,
      serverPubKeys: torusPubKeys.map(key => {
        return {
          x: key.X,
          y: key.Y
        };
      }),
      serverThreshold: Math.ceil(tssNodeEndpoints.length / 2)
    };
  }
  async getTSSPubKey(tssTag, tssNonce) {
    if (!this.verifierName || !this.verifierId) throw new Error("verifier userinfo not found, not logged in yet");
    const nodeDetails = await this.customAuthInstance.nodeDetailManager.getNodeDetails({
      verifier: this.verifierName,
      verifierId: this.verifierId
    });
    const tssServerPub = await this.customAuthInstance.torus.getPublicAddress(nodeDetails.torusNodeSSSEndpoints, nodeDetails.torusNodePub, {
      verifier: this.verifierName,
      verifierId: this.verifierId,
      extendedVerifierId: getExtendedVerifierId(this.verifierId, tssTag, tssNonce)
    });
    return {
      pubKey: new common_types_namespaceObject.Point(tssServerPub.finalKeyData.X, tssServerPub.finalKeyData.Y),
      nodeIndexes: tssServerPub.nodesData.nodeIndexes || []
    };
  }
  getVerifierNameVerifierId() {
    return `${this.verifierName}\u001c${this.verifierId}`;
  }
  async triggerLogin(params) {
    const obj = await super.triggerLogin(params);
    if (obj) {
      const {
        verifier,
        verifierId
      } = obj.userInfo;
      this.verifierName = verifier;
      this.verifierId = verifierId;
    }
    return obj;
  }
  async triggerAggregateLogin(params) {
    const obj = await super.triggerAggregateLogin(params);
    if (obj) {
      const {
        verifier,
        verifierId
      } = obj.userInfo[0];
      this.verifierName = verifier;
      this.verifierId = verifierId;
    }
    return obj;
  }
}
;// CONCATENATED MODULE: external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// CONCATENATED MODULE: external "@tkey/core"
const core_namespaceObject = require("@tkey/core");
;// CONCATENATED MODULE: external "@toruslabs/rss-client"
const rss_client_namespaceObject = require("@toruslabs/rss-client");
;// CONCATENATED MODULE: external "@toruslabs/torus.js"
const torus_js_namespaceObject = require("@toruslabs/torus.js");
;// CONCATENATED MODULE: external "elliptic"
const external_elliptic_namespaceObject = require("elliptic");
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/_assert.js
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
}
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`boolean expected, not ${b}`);
}
// copied from utils
function isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
function bytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function hash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(h.outputLen);
    number(h.blockLen);
}
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}

const assert = { number, bool, bytes, hash, exists, output };
/* harmony default export */ const _assert = (assert);
//# sourceMappingURL=_assert.js.map
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/_u64.js
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
const rotr32L = (h, _l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore

// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
/* harmony default export */ const _u64 = ((/* unused pure expression or super */ null && (u64)));
//# sourceMappingURL=_u64.js.map
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/utils.js
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.


// export { isBytes } from './_assert.js';
// We can't reuse isBytes from _assert, because somehow this causes huge perf issues
function utils_isBytes(a) {
    return (a instanceof Uint8Array ||
        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));
}
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// The byte swap operation for uint32
const byteSwap = (word) => ((word << 24) & 0xff000000) |
    ((word << 8) & 0xff0000) |
    ((word >>> 8) & 0xff00) |
    ((word >>> 24) & 0xff);
// Conditionally byte swap if on a big-endian platform
const byteSwapIfBE = (/* unused pure expression or super */ null && (isLE ? (n) => n : (n) => byteSwap(n)));
// In place byte swap for Uint32Array
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
    if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
    return;
}
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await nextTick();
        ts += diff;
    }
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    bytes(data);
    return data;
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function utils_wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto && typeof crypto.getRandomValues === 'function') {
        return crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map
;// CONCATENATED MODULE: ../../node_modules/@noble/hashes/esm/sha3.js



// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        if (!isLE)
            byteSwap32(this.state32);
        keccakP(this.state32, this.rounds);
        if (!isLE)
            byteSwap32(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        exists(this);
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        exists(this, false);
        bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
const sha3_224 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 144, 224 / 8)));
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
const sha3_256 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 136, 256 / 8)));
const sha3_384 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 104, 384 / 8)));
const sha3_512 = /* @__PURE__ */ (/* unused pure expression or super */ null && (gen(0x06, 72, 512 / 8)));
const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);
const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);
const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
const shake128 = /* @__PURE__ */ (/* unused pure expression or super */ null && (genShake(0x1f, 168, 128 / 8)));
const shake256 = /* @__PURE__ */ (/* unused pure expression or super */ null && (genShake(0x1f, 136, 256 / 8)));
//# sourceMappingURL=sha3.js.map
;// CONCATENATED MODULE: ../../node_modules/ethereum-cryptography/esm/utils.js


const assertBool = _assert.bool;
const assertBytes = _assert.bytes;


// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
function utils_hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return _hexToBytes(sliced);
}
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert.bytes(msg);
        return hash(msg);
    };
}
// TODO(v3): switch away from node crypto, remove this unnecessary variable.
const utils_crypto = (() => {
    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

;// CONCATENATED MODULE: ../../node_modules/ethereum-cryptography/esm/keccak.js


const keccak224 = wrapHash(keccak_224);
const keccak256 = (() => {
    const k = wrapHash(keccak_256);
    k.create = keccak_256.create;
    return k;
})();
const keccak384 = wrapHash(keccak_384);
const keccak512 = wrapHash(keccak_512);

;// CONCATENATED MODULE: ./src/tss.ts










const TSS_MODULE = "tssModule";
const TSS_TAG_DEFAULT = "default";
const FACTOR_KEY_TYPE = "secp256k1";
const factorKeyCurve = new external_elliptic_namespaceObject.ec(FACTOR_KEY_TYPE);
const LEGACY_KEY_TYPE = "secp256k1";
class TKeyTSS extends core_namespaceObject.TKey {
  /**
   * Constructs a new TKeyTSS instance using the given parameters.
   */
  constructor(args) {
    super(args);
    defineProperty_default()(this, "serviceProvider", null);
    defineProperty_default()(this, "_tssKeyType", void 0);
    defineProperty_default()(this, "_tssCurve", void 0);
    defineProperty_default()(this, "_tssTag", void 0);
    defineProperty_default()(this, "_accountSalt", void 0);
    const {
      serviceProvider,
      storageLayer,
      tssTag = "default",
      tssKeyType
    } = args;
    if (serviceProvider.customAuthArgs.keyType !== tssKeyType) {
      throw core_namespaceObject.CoreError.default(`service provider keyType mismatch: ${serviceProvider.customAuthArgs.keyType} !== ${tssKeyType}`);
    }
    this.serviceProvider = serviceProvider;
    this.storageLayer = storageLayer;
    this._tssTag = tssTag;
    this._tssKeyType = tssKeyType;
    this._tssCurve = new external_elliptic_namespaceObject.ec(tssKeyType);
  }
  get tssTag() {
    return this._tssTag;
  }
  get tssKeyType() {
    return this._tssKeyType;
  }
  get tssCurve() {
    return this._tssCurve;
  }
  set tssTag(tag) {
    if ((this.metadata.tssKeyTypes[this.tssTag] || LEGACY_KEY_TYPE) !== this.tssKeyType) {
      throw core_namespaceObject.CoreError.default(`tssKeyType mismatch: ${this.metadata.tssKeyTypes[this.tssTag]} !== ${this.tssKeyType}`);
    }
    this._tssTag = tag;
  }

  /**
   * Initializes this instance. If a TSS account does not exist, creates one
   * under the given factor key. `skipTssInit` skips TSS account creation and
   * can be used with `importTssKey` to just import an existing account instead.
   * @returns The key details of TKey core.
   */
  async initialize(params) {
    const keyDetails = await super.initialize(params);
    if (!this.metadata.tssPolyCommits[this.tssTag] && !(params !== null && params !== void 0 && params.skipTssInit || params !== null && params !== void 0 && params.neverInitializeNewKey)) {
      // if tss shares have not been created for this tssTag, create new tss sharing
      const {
        factorEncs,
        factorPubs,
        tssPolyCommits
      } = await this._initializeNewTSSKey(this.tssTag, params.deviceTSSShare, params.factorPub, params.deviceTSSIndex);
      this.metadata.updateTSSData({
        tssKeyType: this._tssKeyType,
        tssTag: this.tssTag,
        tssNonce: 0,
        tssPolyCommits,
        factorPubs,
        factorEncs
      });
      const accountSalt = generateSalt(this._tssCurve);
      await this._setTKeyStoreItem(TSS_MODULE, {
        id: "accountSalt",
        value: accountSalt
      });
      this._accountSalt = accountSalt;
    }
    if (this.metadata.tssPolyCommits[this.tssTag] && (this.metadata.tssKeyTypes[this.tssTag] || LEGACY_KEY_TYPE) !== this.tssKeyType) {
      throw core_namespaceObject.CoreError.default(`tssKeyType mismatch: ${this.metadata.tssKeyTypes[this.tssTag]} !== ${this.tssKeyType}`);
    }
    return keyDetails;
  }

  /**
   * Returns the encrypted data associated with the given factor public key.
   */
  getFactorEncs(factorPub) {
    if (!this.metadata) throw core_namespaceObject.CoreError.metadataUndefined();
    if (!this.metadata.factorEncs) throw core_namespaceObject.CoreError.default("no factor encs mapping");
    if (!this.metadata.factorPubs) throw core_namespaceObject.CoreError.default("no factor pubs mapping");
    const factorPubs = this.metadata.factorPubs[this.tssTag];
    if (!factorPubs) throw core_namespaceObject.CoreError.default(`no factor pubs for this tssTag ${this.tssTag}`);
    if (factorPubs.filter(f => f.x.cmp(factorPub.x) === 0 && f.y.cmp(factorPub.y) === 0).length === 0) throw core_namespaceObject.CoreError.default(`factor pub ${factorPub} not found for tssTag ${this.tssTag}`);
    if (!this.metadata.factorEncs[this.tssTag]) throw core_namespaceObject.CoreError.default(`no factor encs for tssTag ${this.tssTag}`);
    const factorPubID = factorPub.x.toString(16, 64);
    return this.metadata.factorEncs[this.tssTag][factorPubID];
  }

  /**
   * Returns the TSS share associated with the given factor private key.
   */
  async getTSSShare(factorKey, opts) {
    const factorPub = getPubKeyPoint(factorKey, factorKeyCurve);
    const factorEncs = this.getFactorEncs(factorPub);
    const {
      userEnc,
      serverEncs,
      tssIndex,
      type
    } = factorEncs;
    const userDecryption = await (0,common_types_namespaceObject.decrypt)(Buffer.from(factorKey.toString(16, 64), "hex"), userEnc);
    const serverDecryptions = await Promise.all(serverEncs.map(factorEnc => {
      if (factorEnc === null) return null;
      return (0,common_types_namespaceObject.decrypt)(Buffer.from(factorKey.toString(16, 64), "hex"), factorEnc);
    }));
    const tssShareBufs = [userDecryption].concat(serverDecryptions);
    const tssShareBNs = tssShareBufs.map(buf => {
      if (buf === null) return null;
      return new (external_bn_js_default())(buf);
    });
    const ec = this._tssCurve;
    const tssCommits = this.getTSSCommits().map(p => {
      return ec.keyFromPublic({
        x: p.x.toString(16, 64),
        y: p.y.toString(16, 64)
      }).getPublic();
    });
    const userDec = tssShareBNs[0];
    const accountIndex = (opts === null || opts === void 0 ? void 0 : opts.accountIndex) || 0;
    const coefficient = (opts === null || opts === void 0 ? void 0 : opts.coefficient) || new (external_bn_js_default())(1);
    if (type === "direct") {
      const tssSharePub = ec.g.mul(userDec);
      const tssCommitA0 = tssCommits[0];
      const tssCommitA1 = tssCommits[1];
      const _tssSharePub = tssCommitA0.add(tssCommitA1.mul(new (external_bn_js_default())(tssIndex)));
      if (tssSharePub.eq(_tssSharePub)) {
        const adjustedShare = this.adjustTssShare(userDec, accountIndex, coefficient);
        return {
          tssIndex,
          tssShare: adjustedShare
        };
      }
      throw new Error("user decryption does not match tss commitments...");
    }

    // if type === "hierarchical"
    const serverDecs = tssShareBNs.slice(1); // 5 elems
    const serverIndexes = new Array(serverDecs.length).fill(null).map((_, i) => i + 1);
    const threshold = (opts === null || opts === void 0 ? void 0 : opts.threshold) || Math.ceil(serverDecs.length / 2);
    const combis = kCombinations(serverDecs.length, threshold);
    for (let i = 0; i < combis.length; i++) {
      const combi = combis[i];
      const selectedServerDecs = serverDecs.filter((_, j) => combi.indexOf(j) > -1);
      if (selectedServerDecs.includes(null)) continue;
      const selectedServerIndexes = serverIndexes.filter((_, j) => combi.indexOf(j) > -1);
      const serverLagrangeCoeffs = selectedServerIndexes.map(x => getLagrangeCoeffs(ec, selectedServerIndexes, x));
      const serverInterpolated = (0,rss_client_namespaceObject.dotProduct)(serverLagrangeCoeffs, selectedServerDecs, ec.n);
      const lagrangeCoeffs = [getLagrangeCoeffs(ec, [1, 99], 1), getLagrangeCoeffs(ec, [1, 99], 99)];
      const tssShare = (0,rss_client_namespaceObject.dotProduct)(lagrangeCoeffs, [serverInterpolated, userDec], ec.n);
      const tssSharePub = ec.g.mul(tssShare);
      const tssCommitA0 = tssCommits[0];
      const tssCommitA1 = tssCommits[1];
      let _tssSharePub = tssCommitA0;
      for (let j = 0; j < tssIndex; j++) {
        _tssSharePub = _tssSharePub.add(tssCommitA1);
      }
      if (tssSharePub.eq(_tssSharePub)) {
        const adjustedShare = this.adjustTssShare(tssShare, accountIndex, coefficient);
        return {
          tssIndex,
          tssShare: adjustedShare
        };
      }
    }
    throw new Error("could not find any combination of server decryptions that match tss commitments...");
  }

  /**
   * Returns the TSS public key and the curve points corresponding to secret key
   * shares, as stored in Metadata.
   */
  getTSSCommits() {
    if (!this.metadata) throw core_namespaceObject.CoreError.metadataUndefined();
    const tssPolyCommits = this.metadata.tssPolyCommits[this.tssTag];
    if (!tssPolyCommits) throw core_namespaceObject.CoreError.default(`tss poly commits not found for tssTag ${this.tssTag}`);
    if (tssPolyCommits.length === 0) throw core_namespaceObject.CoreError.default("tss poly commits is empty");
    return tssPolyCommits;
  }

  /**
   * Returns the TSS public key.
   */
  getTSSPub(accountIndex) {
    const ec = this._tssCurve;
    const tssCommits = this.getTSSCommits();
    if (accountIndex && accountIndex > 0) {
      // Add account nonce to pub key.
      const nonce = this.computeAccountNonce(accountIndex);
      const noncePub = ec.keyFromPrivate(nonce.toString("hex")).getPublic();
      const pubKeyPoint = tssCommits[0].toEllipticPoint(ec);
      const devicePubKeyPoint = pubKeyPoint.add(noncePub);
      return common_types_namespaceObject.Point.fromElliptic(devicePubKeyPoint);
    }
    return tssCommits[0];
  }

  /**
   * Returns the node details for RSS.
   */
  async _getRssNodeDetails() {
    const {
      serverEndpoints,
      serverPubKeys,
      serverThreshold
    } = await this.serviceProvider.getRSSNodeDetails();
    if (!Array.isArray(serverEndpoints) || serverEndpoints.length === 0) throw new Error("service provider tss server endpoints are missing");
    if (!Array.isArray(serverPubKeys) || serverPubKeys.length === 0) throw new Error("service provider pub keys are missing");
    return {
      serverEndpoints,
      serverPubKeys,
      serverThreshold: serverThreshold || Math.floor(serverEndpoints.length / 2) + 1
    };
  }

  /**
   * Imports an existing private key for threshold signing. A corresponding user
   * key share will be stored under the specified factor key.
   */
  async importTssKey(params, serverOpts) {
    const ec = this._tssCurve;
    if (!this.secp256k1Key) throw core_namespaceObject.CoreError.privateKeyUnavailable();
    if (!this.metadata) {
      throw core_namespaceObject.CoreError.metadataUndefined();
    }
    const {
      importKey,
      factorPub,
      newTSSIndex,
      tag
    } = params;
    const oldTag = this.tssTag;
    this._tssTag = tag;
    try {
      const {
        selectedServers = [],
        authSignatures = []
      } = serverOpts || {};
      if (!tag) throw core_namespaceObject.CoreError.default(`invalid param, tag is required`);
      if (!factorPub) throw core_namespaceObject.CoreError.default(`invalid param, newFactorPub is required`);
      if (!newTSSIndex) throw core_namespaceObject.CoreError.default(`invalid param, newTSSIndex is required`);
      if (authSignatures.length === 0) throw core_namespaceObject.CoreError.default(`invalid param, authSignatures is required`);
      const existingFactorPubs = this.metadata.factorPubs[tag];
      if ((existingFactorPubs === null || existingFactorPubs === void 0 ? void 0 : existingFactorPubs.length) > 0) {
        throw core_namespaceObject.CoreError.default(`Duplicate account tag, please use a unique tag for importing key`);
      }
      const factorPubs = [factorPub];
      const importScalar = await (async () => {
        if (this._tssKeyType === common_types_namespaceObject.KeyType.secp256k1) {
          return new (external_bn_js_default())(importKey);
        } else if (this._tssKeyType === common_types_namespaceObject.KeyType.ed25519) {
          // Store seed in metadata.
          const domainKey = getEd25519SeedStoreDomainKey(this.tssTag || TSS_TAG_DEFAULT);
          const result = this.metadata.getGeneralStoreDomain(domainKey);
          if (result) {
            throw new Error("Seed already exists");
          }
          const {
            scalar
          } = (0,torus_js_namespaceObject.getEd25519ExtendedPublicKey)(importKey);
          const encKey = Buffer.from((0,torus_js_namespaceObject.getSecpKeyFromEd25519)(scalar).point.encodeCompressed("hex"), "hex");
          const msg = await (0,common_types_namespaceObject.encrypt)(encKey, importKey);
          this.metadata.setGeneralStoreDomain(domainKey, {
            message: msg
          });
          return scalar;
        }
        throw new Error("Invalid key type");
      })();
      if (!importScalar || importScalar.eq(new (external_bn_js_default())("0"))) {
        throw new Error("Invalid importedKey");
      }
      const tssIndexes = [newTSSIndex];
      const existingNonce = this.metadata.tssNonces[this.tssTag];
      const newTssNonce = existingNonce && existingNonce > 0 ? existingNonce + 1 : 0;
      const verifierAndVerifierID = this.serviceProvider.getVerifierNameVerifierId();
      const label = `${verifierAndVerifierID}\u0015${this.tssTag}\u0016${newTssNonce}`;
      const tssPubKey = (0,rss_client_namespaceObject.hexPoint)(ec.g.mul(importScalar));
      const rssNodeDetails = await this._getRssNodeDetails();
      const {
        pubKey: newTSSServerPub,
        nodeIndexes
      } = await this.serviceProvider.getTSSPubKey(this.tssTag, newTssNonce);
      let finalSelectedServers = selectedServers;
      if ((nodeIndexes === null || nodeIndexes === void 0 ? void 0 : nodeIndexes.length) > 0) {
        if (selectedServers.length) {
          finalSelectedServers = nodeIndexes.slice(0, Math.min(selectedServers.length, nodeIndexes.length));
        } else {
          finalSelectedServers = nodeIndexes.slice(0, 3);
        }
      } else if ((selectedServers === null || selectedServers === void 0 ? void 0 : selectedServers.length) === 0) {
        finalSelectedServers = (0,rss_client_namespaceObject.randomSelection)(new Array(rssNodeDetails.serverEndpoints.length).fill(null).map((_, i) => i + 1), Math.ceil(rssNodeDetails.serverEndpoints.length / 2));
      }
      const {
        serverEndpoints,
        serverPubKeys,
        serverThreshold
      } = rssNodeDetails;
      const rssClient = new rss_client_namespaceObject.RSSClient({
        serverEndpoints,
        serverPubKeys,
        serverThreshold,
        tssPubKey,
        keyType: this._tssKeyType
      });
      const refreshResponses = await rssClient.import({
        importKey: importScalar,
        dkgNewPub: pointToHex(newTSSServerPub),
        selectedServers: finalSelectedServers,
        factorPubs: factorPubs.map(f => pointToHex(f)),
        targetIndexes: tssIndexes,
        newLabel: label,
        sigs: authSignatures
      });
      const secondCommit = newTSSServerPub.toEllipticPoint(ec).add((0,rss_client_namespaceObject.ecPoint)(ec, tssPubKey).neg());
      const newTSSCommits = [common_types_namespaceObject.Point.fromJSON(tssPubKey), common_types_namespaceObject.Point.fromJSON({
        x: secondCommit.getX().toString(16, 64),
        y: secondCommit.getY().toString(16, 64)
      })];
      const factorEncs = {};
      for (let i = 0; i < refreshResponses.length; i++) {
        const refreshResponse = refreshResponses[i];
        factorEncs[refreshResponse.factorPub.x.padStart(64, "0")] = {
          type: "hierarchical",
          tssIndex: refreshResponse.targetIndex,
          userEnc: refreshResponse.userFactorEnc,
          serverEncs: refreshResponse.serverFactorEncs
        };
      }
      this.metadata.updateTSSData({
        tssKeyType: this._tssKeyType,
        tssTag: this.tssTag,
        tssNonce: newTssNonce,
        tssPolyCommits: newTSSCommits,
        factorPubs,
        factorEncs
      });
      if (!this._accountSalt) {
        const accountSalt = generateSalt(this._tssCurve);
        await this._setTKeyStoreItem(TSS_MODULE, {
          id: "accountSalt",
          value: accountSalt
        });
        this._accountSalt = accountSalt;
      }
      await this._syncShareMetadata();
    } catch (error) {
      this._tssTag = oldTag;
      throw error;
    }
  }

  /**
   * UNSAFE: USE WITH CAUTION
   *
   * Reconstructs and exports the TSS private key.
   */
  async _UNSAFE_exportTssKey(tssOptions) {
    if (!this.metadata) throw core_namespaceObject.CoreError.metadataUndefined("metadata is undefined");
    if (!this.secp256k1Key) throw new Error("Tkey is not reconstructed");
    if (!this.metadata.tssPolyCommits[this.tssTag]) throw new Error(`tss key has not been initialized for tssTag ${this.tssTag}`);
    const {
      factorKey,
      selectedServers,
      authSignatures,
      accountIndex
    } = tssOptions;
    const {
      tssIndex
    } = await this.getTSSShare(factorKey);
    // Assumption that there are only index 2 and 3 for tss shares
    // create complement index share
    const tempShareIndex = tssIndex === 2 ? 3 : 2;
    const tempFactorKey = factorKeyCurve.genKeyPair().getPrivate();
    const tempFactorPub = getPubKeyPoint(tempFactorKey, factorKeyCurve);
    await this.addFactorPub({
      existingFactorKey: factorKey,
      newFactorPub: tempFactorPub,
      newTSSIndex: tempShareIndex,
      authSignatures,
      selectedServers,
      refreshShares: true
    });
    const {
      tssShare: factorShare,
      tssIndex: factorIndex
    } = await this.getTSSShare(factorKey);
    const {
      tssShare: tempShare,
      tssIndex: tempIndex
    } = await this.getTSSShare(tempFactorKey);

    // reconstruct final key using sss
    const ec = this._tssCurve;
    const tssKey = lagrangeInterpolation(ec, [tempShare, factorShare], [new (external_bn_js_default())(tempIndex), new (external_bn_js_default())(factorIndex)]);

    // delete created tss share
    await this.deleteFactorPub({
      factorKey,
      deleteFactorPub: tempFactorPub,
      authSignatures,
      selectedServers
    });

    // Derive key for account index.
    const nonce = this.computeAccountNonce(accountIndex);
    const derivedKey = tssKey.add(nonce).umod(this._tssCurve.n);
    return derivedKey;
  }

  /**
   * UNSAFE: USE WITH CAUTION
   *
   * Reconstructs the TSS private key and exports the ed25519 private key seed.
   */
  async _UNSAFE_exportTssEd25519Seed(tssOptions) {
    const edScalar = await this._UNSAFE_exportTssKey(tssOptions);

    // Try to export ed25519 seed. This is only available if import key was being used.
    const domainKey = getEd25519SeedStoreDomainKey(this.tssTag || TSS_TAG_DEFAULT);
    const result = this.metadata.getGeneralStoreDomain(domainKey);
    const decKey = (0,torus_js_namespaceObject.getSecpKeyFromEd25519)(edScalar).scalar;
    const seed = await (0,common_types_namespaceObject.decrypt)(decKey.toArrayLike(Buffer, "be", 32), result.message);
    return seed;
  }

  /**
   * Runs the share refresh protocol for the TSS key shares.
   * @param inputShare - The current user secret share.
   * @param inputIndex - The user share index.
   * @param factorPubs - The target factor keys.
   * @param targetIndexes - The target indices to provide new shares for.
   */
  async _refreshTSSShares(updateMetadata, inputShare, inputIndex, factorPubs, targetIndexes, verifierNameVerifierId, serverOpts) {
    if (!this.metadata) throw core_namespaceObject.CoreError.metadataUndefined();
    if (!this.metadata.tssPolyCommits) throw core_namespaceObject.CoreError.default(`tss poly commits obj not found`);
    const tssCommits = this.metadata.tssPolyCommits[this.tssTag];
    if (!tssCommits) throw core_namespaceObject.CoreError.default(`tss commits not found for tssTag ${this.tssTag}`);
    if (tssCommits.length === 0) throw core_namespaceObject.CoreError.default(`tssCommits is empty`);
    const tssPubKeyPoint = tssCommits[0];
    const tssPubKey = pointToHex(tssPubKeyPoint);
    const {
      serverEndpoints,
      serverPubKeys,
      serverThreshold,
      selectedServers,
      authSignatures
    } = serverOpts;
    const rssClient = new rss_client_namespaceObject.RSSClient({
      serverEndpoints,
      serverPubKeys,
      serverThreshold,
      tssPubKey,
      keyType: this._tssKeyType
    });
    if (!this.metadata.factorPubs) throw core_namespaceObject.CoreError.default(`factorPubs obj not found`);
    if (!factorPubs) throw core_namespaceObject.CoreError.default(`factorPubs not found for tssTag ${this.tssTag}`);
    if (factorPubs.length === 0) throw core_namespaceObject.CoreError.default(`factorPubs is empty`);
    if (!this.metadata.tssNonces) throw core_namespaceObject.CoreError.default(`tssNonces obj not found`);
    const tssNonce = this.metadata.tssNonces[this.tssTag] || 0;
    const oldLabel = `${verifierNameVerifierId}\u0015${this.tssTag}\u0016${tssNonce}`;
    const newLabel = `${verifierNameVerifierId}\u0015${this.tssTag}\u0016${tssNonce + 1}`;
    const {
      pubKey: newTSSServerPub,
      nodeIndexes
    } = await this.serviceProvider.getTSSPubKey(this.tssTag, tssNonce + 1);
    let finalSelectedServers = selectedServers;
    if ((nodeIndexes === null || nodeIndexes === void 0 ? void 0 : nodeIndexes.length) > 0) {
      finalSelectedServers = nodeIndexes.slice(0, Math.min(selectedServers.length, nodeIndexes.length));
    }
    const refreshResponses = await rssClient.refresh({
      factorPubs: factorPubs.map(f => pointToHex(f)),
      targetIndexes,
      oldLabel,
      newLabel,
      sigs: authSignatures,
      dkgNewPub: pointToHex(newTSSServerPub),
      inputShare,
      inputIndex,
      selectedServers: finalSelectedServers
    });
    const secondCommit = newTSSServerPub.toEllipticPoint(this._tssCurve).add((0,rss_client_namespaceObject.ecPoint)(this._tssCurve, tssPubKey).neg());
    const newTSSCommits = [common_types_namespaceObject.Point.fromJSON(tssPubKey), common_types_namespaceObject.Point.fromJSON({
      x: secondCommit.getX().toString(16, 64),
      y: secondCommit.getY().toString(16, 64)
    })];
    const factorEncs = {};
    for (let i = 0; i < refreshResponses.length; i++) {
      const refreshResponse = refreshResponses[i];
      factorEncs[refreshResponse.factorPub.x.padStart(64, "0")] = {
        type: "hierarchical",
        tssIndex: refreshResponse.targetIndex,
        userEnc: refreshResponse.userFactorEnc,
        serverEncs: refreshResponse.serverFactorEncs
      };
    }
    this.metadata.updateTSSData({
      tssKeyType: this._tssKeyType,
      tssTag: this.tssTag,
      tssNonce: tssNonce + 1,
      tssPolyCommits: newTSSCommits,
      factorPubs,
      factorEncs
    });
    if (updateMetadata) await this._syncShareMetadata();
  }

  /**
   * Derives the account nonce for the specified account index.
   */
  computeAccountNonce(index) {
    if (!index || index === 0) {
      return new (external_bn_js_default())(0);
    }
    if (this._tssKeyType === common_types_namespaceObject.KeyType.ed25519) {
      throw new Error("account index not supported with ed25519");
    }

    // generation should occur during tkey.init, fails if accountSalt is absent
    if (!this._accountSalt) {
      throw Error("account salt undefined");
    }
    let accountHash = keccak256(Buffer.from(`${index}${this._accountSalt}`));
    if (accountHash.length === 66) accountHash = accountHash.slice(2);
    return new (external_bn_js_default())(accountHash, "hex").umod(this._tssCurve.n);
  }

  /**
   * Reconstructs the TKey and finalize intialization.
   */
  async reconstructKey(_reconstructKeyMiddleware) {
    const k = await super.reconstructKey(_reconstructKeyMiddleware);
    const accountSalt = await this.getTKeyStoreItem(TSS_MODULE, "accountSalt");
    if (accountSalt && accountSalt.value) {
      this._accountSalt = accountSalt.value;
    } else {
      const newSalt = generateSalt(this._tssCurve);
      await this._setTKeyStoreItem(TSS_MODULE, {
        id: "accountSalt",
        value: newSalt
      });
      this._accountSalt = newSalt;
      // this is very specific case where exisiting user do not have salt.
      // sync metadata to cloud to ensure salt is stored incase of manual sync mode
      // new user or importKey should not hit this cases
      // NOTE this is not mistake, we force sync for this case
      if (this.manualSync) await this.syncLocalMetadataTransitions();
    }
    return k;
  }

  /**
   * Adds a factor key to the set of authorized keys.
   *
   * `refreshShares` - If this is true, then refresh the shares. If this is
   * false, `newTSSIndex` must be the same as current factor key index.
   */
  async addFactorPub(args) {
    if (!this.metadata) throw core_namespaceObject.CoreError.metadataUndefined("metadata is undefined");
    if (!this.secp256k1Key) throw new Error("Tkey is not reconstructed");
    if (!this.metadata.tssPolyCommits[this.tssTag]) throw new Error(`tss key has not been initialized for tssTag ${this.tssTag}`);
    const {
      existingFactorKey,
      newFactorPub,
      newTSSIndex,
      selectedServers,
      authSignatures,
      refreshShares
    } = args;
    const {
      tssShare,
      tssIndex
    } = await this.getTSSShare(existingFactorKey);
    if (tssIndex !== newTSSIndex && !refreshShares) {
      throw core_namespaceObject.CoreError.default("newTSSIndex does not match existing tssIndex, set refreshShares to true to refresh shares");
    }
    if (!refreshShares) {
      // Just copy data stored under factor key.
      if (tssIndex !== newTSSIndex) {
        throw core_namespaceObject.CoreError.default("newTSSIndex does not match existing tssIndex, set refreshShares to true to refresh shares");
      }
      const updatedFactorPubs = this.metadata.factorPubs[this.tssTag].concat([newFactorPub]);
      const factorEncs = JSON.parse(JSON.stringify(this.metadata.factorEncs[this.tssTag]));
      const factorPubID = newFactorPub.x.toString(16, 64);
      factorEncs[factorPubID] = {
        tssIndex,
        type: "direct",
        userEnc: await (0,common_types_namespaceObject.encrypt)(newFactorPub.toSEC1(common_types_namespaceObject.secp256k1, false), tssShare.toArrayLike(Buffer, "be", 32)),
        serverEncs: []
      };
      this.metadata.updateTSSData({
        tssKeyType: this.tssKeyType,
        tssTag: this.tssTag,
        factorPubs: updatedFactorPubs,
        factorEncs
      });
    } else {
      // Use RSS to create new TSS share and store it under new factor key.
      const existingFactorPubs = this.metadata.factorPubs[this.tssTag];
      const updatedFactorPubs = existingFactorPubs.concat([newFactorPub]);
      const verifierId = this.serviceProvider.getVerifierNameVerifierId();
      const rssNodeDetails = await this._getRssNodeDetails();
      const randomSelectedServers = (0,rss_client_namespaceObject.randomSelection)(new Array(rssNodeDetails.serverEndpoints.length).fill(null).map((_, i) => i + 1), Math.ceil(rssNodeDetails.serverEndpoints.length / 2));
      const finalServer = selectedServers || randomSelectedServers;
      const existingTSSIndexes = existingFactorPubs.map(fb => this.getFactorEncs(fb).tssIndex);
      const updatedTSSIndexes = existingTSSIndexes.concat([newTSSIndex]);
      await this._refreshTSSShares(false, tssShare, tssIndex, updatedFactorPubs, updatedTSSIndexes, verifierId, objectSpread2_default()(objectSpread2_default()({}, rssNodeDetails), {}, {
        selectedServers: finalServer,
        authSignatures
      }));
    }
    await this._syncShareMetadata();
  }

  /**
   * Removes a factor key from the set of authorized keys and refreshes the TSS
   * key shares.
   */
  async deleteFactorPub(args) {
    if (!this.metadata) throw core_namespaceObject.CoreError.metadataUndefined("metadata is undefined");
    if (!this.secp256k1Key) throw new Error("Tkey is not reconstructed");
    if (!this.metadata.tssPolyCommits[this.tssTag]) throw new Error(`tss key has not been initialized for tssTag ${this.tssTag}`);
    const {
      factorKey,
      deleteFactorPub,
      selectedServers,
      authSignatures
    } = args;
    const existingFactorPubs = this.metadata.factorPubs[this.tssTag];
    const {
      tssShare,
      tssIndex
    } = await this.getTSSShare(factorKey);
    const found = existingFactorPubs.filter(f => f.x.eq(deleteFactorPub.x) && f.y.eq(deleteFactorPub.y));
    if (found.length === 0) throw core_namespaceObject.CoreError.default("could not find factorPub to delete");
    if (found.length > 1) throw core_namespaceObject.CoreError.default("found two or more factorPubs that match, error in metadata");
    const updatedFactorPubs = existingFactorPubs.filter(f => !f.x.eq(deleteFactorPub.x) || !f.y.eq(deleteFactorPub.y));
    this.metadata.updateTSSData({
      tssKeyType: this._tssKeyType,
      tssTag: this.tssTag,
      factorPubs: updatedFactorPubs
    });
    const rssNodeDetails = await this._getRssNodeDetails();
    const randomSelectedServers = (0,rss_client_namespaceObject.randomSelection)(new Array(rssNodeDetails.serverEndpoints.length).fill(null).map((_, i) => i + 1), Math.ceil(rssNodeDetails.serverEndpoints.length / 2));
    const finalServer = selectedServers || randomSelectedServers;
    const updatedTSSIndexes = updatedFactorPubs.map(fb => this.getFactorEncs(fb).tssIndex);
    await this._refreshTSSShares(false, tssShare, tssIndex, updatedFactorPubs, updatedTSSIndexes, this.serviceProvider.getVerifierNameVerifierId(), objectSpread2_default()(objectSpread2_default()({}, rssNodeDetails), {}, {
      selectedServers: finalServer,
      authSignatures
    }));
    await this._syncShareMetadata();
  }

  /**
   * Adjusts a TSS key share based on account index and share coefficient.
   */
  adjustTssShare(share, accountIndex, coefficient) {
    const nonce = this.computeAccountNonce(accountIndex);
    return share.mul(coefficient).add(nonce).umod(this._tssCurve.n);
  }

  /**
   * Initializes a new TSS key under the specified factor key and using the
   * provided user share.
   */
  async _initializeNewTSSKey(tssTag, deviceTSSShare, factorPub, deviceTSSIndex) {
    const ec = this._tssCurve;
    let tss2;
    const _tssIndex = deviceTSSIndex || 2; // TODO: fix
    if (deviceTSSShare) {
      tss2 = deviceTSSShare;
    } else {
      tss2 = this._tssCurve.genKeyPair().getPrivate();
    }
    const {
      pubKey: tss1Pub
    } = await this.serviceProvider.getTSSPubKey(tssTag, 0);
    const tss1PubKey = tss1Pub.toEllipticPoint(ec);
    const tss2PubKey = this._tssCurve.g.mul(tss2);
    const L1_0 = getLagrangeCoeffs(ec, [1, _tssIndex], 1, 0);
    const LIndex_0 = getLagrangeCoeffs(ec, [1, _tssIndex], _tssIndex, 0);
    const a0Pub = tss1PubKey.mul(L1_0).add(tss2PubKey.mul(LIndex_0));
    const a1Pub = tss1PubKey.add(a0Pub.neg());
    const tssPolyCommits = [common_types_namespaceObject.Point.fromElliptic(a0Pub), common_types_namespaceObject.Point.fromElliptic(a1Pub)];
    const factorPubs = [factorPub];
    const factorEncs = {};
    for (let i = 0; i < factorPubs.length; i++) {
      const f = factorPubs[i];
      const factorPubID = f.x.toString(16, 64);
      factorEncs[factorPubID] = {
        tssIndex: _tssIndex,
        type: "direct",
        userEnc: await (0,common_types_namespaceObject.encrypt)(f.toSEC1(factorKeyCurve, false), Buffer.from(tss2.toString(16, 64), "hex")),
        serverEncs: []
      };
    }
    return {
      tss2,
      factorEncs,
      factorPubs,
      tssPolyCommits
    };
  }
}
;// CONCATENATED MODULE: ./src/index.ts





module.exports = __webpack_exports__;
/******/ })()
;