import { EllipticCurve, KeyDetails, KeyType, Point, ReconstructedKeyResult, TKeyArgs, TKeyInitArgs } from "@tkey/common-types";
import { TKey } from "@tkey/core";
import { PointHex } from "@toruslabs/rss-client";
import BN from "bn.js";
import { ec as EC } from "elliptic";
import { TSSTorusServiceProvider } from ".";
import { FactorEnc, InitializeNewTSSKeyResult } from "./common";
export declare const TSS_MODULE = "tssModule";
export declare const TSS_TAG_DEFAULT = "default";
export declare const FACTOR_KEY_TYPE = "secp256k1";
export declare const factorKeyCurve: EC;
export declare const LEGACY_KEY_TYPE = "secp256k1";
export interface TSSTKeyArgs extends TKeyArgs {
    serviceProvider: TSSTorusServiceProvider;
    tssKeyType: KeyType;
    tssTag?: string;
}
export interface TKeyTSSInitArgs extends TKeyInitArgs {
    deviceTSSShare?: BN;
    deviceTSSIndex?: number;
    factorPub?: Point;
    skipTssInit?: boolean;
}
export declare class TKeyTSS extends TKey {
    serviceProvider: TSSTorusServiceProvider;
    private _tssKeyType;
    private _tssCurve;
    private _tssTag;
    private _accountSalt;
    /**
     * Constructs a new TKeyTSS instance using the given parameters.
     */
    constructor(args: TSSTKeyArgs);
    get tssTag(): string;
    get tssKeyType(): KeyType;
    get tssCurve(): EllipticCurve;
    set tssTag(tag: string);
    /**
     * Initializes this instance. If a TSS account does not exist, creates one
     * under the given factor key. `skipTssInit` skips TSS account creation and
     * can be used with `importTssKey` to just import an existing account instead.
     * @returns The key details of TKey core.
     */
    initialize(params?: TKeyTSSInitArgs): Promise<KeyDetails>;
    /**
     * Returns the encrypted data associated with the given factor public key.
     */
    getFactorEncs(factorPub: Point): FactorEnc;
    /**
     * Returns the TSS share associated with the given factor private key.
     */
    getTSSShare(factorKey: BN, opts?: {
        threshold?: number;
        accountIndex?: number;
        coefficient?: BN;
    }): Promise<{
        tssIndex: number;
        tssShare: BN;
    }>;
    /**
     * Returns the TSS public key and the curve points corresponding to secret key
     * shares, as stored in Metadata.
     */
    getTSSCommits(): Point[];
    /**
     * Returns the TSS public key.
     */
    getTSSPub(accountIndex?: number): Point;
    /**
     * Returns the node details for RSS.
     */
    _getRssNodeDetails(): Promise<{
        serverEndpoints: string[];
        serverPubKeys: PointHex[];
        serverThreshold: number;
    }>;
    /**
     * Imports an existing private key for threshold signing. A corresponding user
     * key share will be stored under the specified factor key.
     */
    importTssKey(params: {
        tag: string;
        importKey: Buffer;
        factorPub: Point;
        newTSSIndex: number;
    }, serverOpts: {
        selectedServers?: number[];
        authSignatures: string[];
    }): Promise<void>;
    /**
     * UNSAFE: USE WITH CAUTION
     *
     * Reconstructs and exports the TSS private key.
     */
    _UNSAFE_exportTssKey(tssOptions: {
        factorKey: BN;
        selectedServers?: number[];
        authSignatures: string[];
        accountIndex?: number;
    }): Promise<BN>;
    /**
     * UNSAFE: USE WITH CAUTION
     *
     * Reconstructs the TSS private key and exports the ed25519 private key seed.
     */
    _UNSAFE_exportTssEd25519Seed(tssOptions: {
        factorKey: BN;
        selectedServers?: number[];
        authSignatures: string[];
    }): Promise<Buffer>;
    /**
     * Runs the share refresh protocol for the TSS key shares.
     * @param inputShare - The current user secret share.
     * @param inputIndex - The user share index.
     * @param factorPubs - The target factor keys.
     * @param targetIndexes - The target indices to provide new shares for.
     */
    _refreshTSSShares(updateMetadata: boolean, inputShare: BN, inputIndex: number, factorPubs: Point[], targetIndexes: number[], verifierNameVerifierId: string, serverOpts: {
        serverEndpoints: string[];
        serverPubKeys: PointHex[];
        serverThreshold: number;
        selectedServers: number[];
        authSignatures: string[];
    }): Promise<void>;
    /**
     * Derives the account nonce for the specified account index.
     */
    computeAccountNonce(index?: number): BN;
    /**
     * Reconstructs the TKey and finalize intialization.
     */
    reconstructKey(_reconstructKeyMiddleware?: boolean): Promise<ReconstructedKeyResult>;
    /**
     * Adds a factor key to the set of authorized keys.
     *
     * `refreshShares` - If this is true, then refresh the shares. If this is
     * false, `newTSSIndex` must be the same as current factor key index.
     */
    addFactorPub(args: {
        existingFactorKey: BN;
        newFactorPub: Point;
        newTSSIndex: number;
        selectedServers?: number[];
        authSignatures: string[];
        refreshShares?: boolean;
    }): Promise<void>;
    /**
     * Removes a factor key from the set of authorized keys and refreshes the TSS
     * key shares.
     */
    deleteFactorPub(args: {
        factorKey: BN;
        deleteFactorPub: Point;
        selectedServers?: number[];
        authSignatures: string[];
    }): Promise<void>;
    /**
     * Adjusts a TSS key share based on account index and share coefficient.
     */
    protected adjustTssShare(share: BN, accountIndex: number, coefficient: BN): BN;
    /**
     * Initializes a new TSS key under the specified factor key and using the
     * provided user share.
     */
    protected _initializeNewTSSKey(tssTag: string, deviceTSSShare: BN, factorPub: Point, deviceTSSIndex?: number): Promise<InitializeNewTSSKeyResult>;
}
