import _objectSpread from '@babel/runtime/helpers/objectSpread2';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { publicToAddress, stripHexPrefix, intToBytes, isHexString, toBytes } from '@ethereumjs/util';
import { createScaffoldMiddleware, createAsyncMiddleware, rpcErrors, providerErrors, JRPCEngine, providerFromEngine } from '@web3auth/auth';
import { log, CHAIN_NAMESPACES, WalletInitializationError } from '@web3auth/base';
import { BaseProvider } from '@web3auth/base-provider';
import { validateTypedSignMessageDataV4, SignTypedDataVersion, TransactionFormatter, createEthMiddleware, createJsonRpcClient, createChainSwitchMiddleware } from '@web3auth/ethereum-provider';
import { concatSig } from '@toruslabs/base-controllers';
import { Signature, hashMessage } from 'ethers';
import { validateTypedData, hexToBytes, hashTypedData } from 'viem';

// #region account middlewares
function createAccountMiddleware({
  updatePrivatekey
}) {
  async function updateAccount(req, res) {
    var _req$params;
    const accountParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;
    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw rpcErrors.invalidParams("Missing privateKey");
    res.result = await updatePrivatekey(accountParams);
  }
  return createScaffoldMiddleware({
    wallet_updateAccount: createAsyncMiddleware(updateAccount)
  });
}

// #endregion account middlewares

async function signTx(txParams, sign, txFormatter) {
  const {
    Transaction
  } = await import('ethers');
  const finalTxParams = await txFormatter.formatTransaction(txParams);
  const ethTx = Transaction.from(_objectSpread(_objectSpread({}, finalTxParams), {}, {
    from: undefined // from is already calculated inside Transaction.from and is not allowed to be passed in
  }));
  const msgHash = stripHexPrefix(ethTx.unsignedHash);
  const vrs = await sign(Buffer.from(msgHash, "hex"));
  let {
    v
  } = vrs;
  const {
    r,
    s
  } = vrs;

  // mpc-core-kit workaround (revert back to 0/1)
  if (v > 1) {
    v = v - 27;
  }

  // addSignature will handle the v value
  const tx = ethTx;
  tx.signature = Signature.from({
    v,
    r: `0x${r.toString("hex")}`,
    s: `0x${s.toString("hex")}`
  });
  return tx.serialized;
}
async function signMessage(sign, data) {
  const message = stripHexPrefix(data);
  const msgSig = await sign(Buffer.from(message, "hex"));
  let modifiedV = msgSig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const rawMsgSig = concatSig(Buffer.from(intToBytes(modifiedV)), msgSig.r, msgSig.s);
  return rawMsgSig;
}
async function personalSign(sign, data) {
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  // we need to check if the data is hex or not
  // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
  // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
  const message = isHexString(data) ? Buffer.from(stripHexPrefix(data), "hex") : Buffer.from(data);
  const msgHash = hashMessage(message);
  const prefix = Buffer.from(`\u0019Ethereum Signed Message:\n${message.length}`, "utf-8");
  const sig = await sign(Buffer.from(msgHash.slice(2), "hex"), Buffer.concat([prefix, message]));
  let modifiedV = sig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const serialized = concatSig(Buffer.from(toBytes(modifiedV)), sig.r, sig.s);
  return serialized;
}
function validateVersion(version, allowedVersions) {
  if (!Object.keys(SignTypedDataVersion).includes(version)) {
    throw new Error(`Invalid version: '${version}'`);
  }
}
async function signTypedData(sign, data, version) {
  validateVersion(version); // Note: this is intentional;
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  const message = typeof data === "string" ? JSON.parse(data) : data;
  validateTypedData(message);
  const {
    v,
    r,
    s
  } = await sign(Buffer.from(hexToBytes(hashTypedData(message))));
  let modifiedV = v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  return concatSig(Buffer.from(toBytes(modifiedV)), r, s);
}
function getProviderHandlers({
  txFormatter,
  sign,
  getPublic,
  getProviderEngineProxy
}) {
  return {
    getAccounts: async _ => {
      const pubKey = await getPublic();
      return [`0x${Buffer.from(publicToAddress(pubKey)).toString("hex")}`];
    },
    getPrivateKey: async _ => {
      throw providerErrors.custom({
        message: "MPC Provider cannot return private key",
        code: 4902
      });
    },
    getPublicKey: async _ => {
      const pubKey = await getPublic();
      return `0x${pubKey.toString("hex")}`;
    },
    processTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      const txHash = await providerEngineProxy.request({
        method: "eth_sendRawTransaction",
        params: [serializedTxn]
      });
      return txHash;
    },
    processSignTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      return serializedTxn;
    },
    processEthSignMessage: async (msgParams, _) => {
      const rawMessageSig = signMessage(sign, msgParams.data);
      return rawMessageSig;
    },
    processPersonalMessage: async (msgParams, _) => {
      const sig = personalSign(sign, msgParams.data);
      return sig;
    },
    processTypedMessageV4: async (msgParams, _) => {
      log.debug("processTypedMessageV4", msgParams);
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const chainId = await providerEngineProxy.request({
        method: "eth_chainId"
      });
      await validateTypedSignMessageDataV4(msgParams, chainId);
      const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
      const sig = signTypedData(sign, data, SignTypedDataVersion.V4);
      return sig;
    }
  };
}

var _EthereumSigningProvider;
class EthereumSigningProvider extends BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config: {
        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {
          chainNamespace: CHAIN_NAMESPACES.EIP155
        })
      },
      state
    });
    _defineProperty(this, "PROVIDER_CHAIN_NAMESPACE", CHAIN_NAMESPACES.EIP155);
  }
  async enable() {
    if (!this.state.signMethods) throw providerErrors.custom({
      message: "signMethods are not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.signMethods);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  async setupProvider({
    sign,
    getPublic
  }) {
    const {
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const txFormatter = new TransactionFormatter({
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const providerHandlers = getProviderHandlers({
      txFormatter,
      sign,
      getPublic,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const ethMiddleware = createEthMiddleware(providerHandlers);
    const chainSwitchMiddleware = this.getChainSwitchMiddleware();
    const engine = new JRPCEngine();
    // Not a partial anymore because of checks in ctor
    const {
      networkMiddleware
    } = createJsonRpcClient(this.config.chainConfig);
    engine.push(ethMiddleware);
    engine.push(chainSwitchMiddleware);
    engine.push(this.getAccountMiddleware());
    engine.push(networkMiddleware);
    const provider = providerFromEngine(engine);
    this.updateProviderEngineProxy(provider);
    await txFormatter.init();
    await this.lookupNetwork();
    this.state.signMethods = {
      sign,
      getPublic
    };
  }
  async updateAccount(params) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const currentSignMethods = this.state.signMethods;
    if (!currentSignMethods) {
      throw providerErrors.custom({
        message: "signing methods are unavailable ",
        code: 4092
      });
    }
    const currentPubKey = (await currentSignMethods.getPublic()).toString("hex");
    const updatePubKey = (await params.signMethods.getPublic()).toString("hex");
    if (currentPubKey !== updatePubKey) {
      await this.setupProvider(params.signMethods);
      const accounts = await this._providerEngineProxy.request({
        method: "eth_accounts"
      });
      this.emit("accountsChanged", accounts);
    }
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    if (!this.state.signMethods) {
      throw providerErrors.custom({
        message: "sign methods are undefined",
        code: 4902
      });
    }
    await this.setupProvider(this.state.signMethods);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    if (!chainId) throw rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const network = await this._providerEngineProxy.request({
      method: "net_version",
      params: []
    });
    const finalNetwork = isHexString(network) ? parseInt(network, 16) : parseInt(network, 10);
    if (parseInt(chainId, 16) !== finalNetwork) throw providerErrors.chainDisconnected(`Invalid network, net_version is: ${network}`);
    if (this.state.chainId !== chainId) {
      this.emit("chainChanged", chainId);
      this.emit("connect", {
        chainId
      });
    }
    this.update({
      chainId
    });
    return network;
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addChain: async params => {
        const {
          chainId,
          chainName,
          rpcUrls,
          blockExplorerUrls,
          nativeCurrency,
          iconUrls
        } = params;
        this.addChain({
          chainNamespace: CHAIN_NAMESPACES.EIP155,
          chainId,
          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "ETH",
          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Ether",
          displayName: chainName,
          rpcTarget: rpcUrls[0],
          blockExplorerUrl: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || "",
          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 18,
          logo: (iconUrls === null || iconUrls === void 0 ? void 0 : iconUrls[0]) || "https://images.toruswallet.io/eth.svg"
        });
      },
      switchChain: async params => {
        const {
          chainId
        } = params;
        await this.switchChain({
          chainId
        });
      }
    };
    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
  getAccountMiddleware() {
    const accountHandlers = {
      updateSignMethods: async params => {
        await this.updateAccount(params);
      }
    };
    return createAccountMiddleware(accountHandlers);
  }
}
_EthereumSigningProvider = EthereumSigningProvider;
_defineProperty(EthereumSigningProvider, "getProviderInstance", async params => {
  const providerFactory = new _EthereumSigningProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.signMethods);
  return providerFactory;
});

export { EthereumSigningProvider };
