/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 999:
/***/ ((module) => {

module.exports = require("ethers");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  EthereumSigningProvider: () => (/* reexport */ EthereumSigningProvider)
});

;// external "@babel/runtime/helpers/objectSpread2"
const objectSpread2_namespaceObject = require("@babel/runtime/helpers/objectSpread2");
var objectSpread2_default = /*#__PURE__*/__webpack_require__.n(objectSpread2_namespaceObject);
;// external "@babel/runtime/helpers/defineProperty"
const defineProperty_namespaceObject = require("@babel/runtime/helpers/defineProperty");
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_namespaceObject);
;// external "@ethereumjs/util"
const util_namespaceObject = require("@ethereumjs/util");
;// external "@web3auth/auth"
const auth_namespaceObject = require("@web3auth/auth");
;// external "@web3auth/base"
const base_namespaceObject = require("@web3auth/base");
;// external "@web3auth/base-provider"
const base_provider_namespaceObject = require("@web3auth/base-provider");
;// external "@web3auth/ethereum-provider"
const ethereum_provider_namespaceObject = require("@web3auth/ethereum-provider");
;// ./src/rpc/ethRpcMiddlewares.ts

// #region account middlewares
function createAccountMiddleware({
  updatePrivatekey
}) {
  async function updateAccount(req, res) {
    var _req$params;
    const accountParams = (_req$params = req.params) !== null && _req$params !== void 0 && _req$params.length ? req.params[0] : undefined;
    if (!(accountParams !== null && accountParams !== void 0 && accountParams.privateKey)) throw auth_namespaceObject.rpcErrors.invalidParams("Missing privateKey");
    res.result = await updatePrivatekey(accountParams);
  }
  return (0,auth_namespaceObject.createScaffoldMiddleware)({
    wallet_updateAccount: (0,auth_namespaceObject.createAsyncMiddleware)(updateAccount)
  });
}

// #endregion account middlewares
;// external "@toruslabs/base-controllers"
const base_controllers_namespaceObject = require("@toruslabs/base-controllers");
// EXTERNAL MODULE: external "ethers"
var external_ethers_ = __webpack_require__(999);
;// external "viem"
const external_viem_namespaceObject = require("viem");
;// ./src/providers/signingProviders/signingUtils.ts








async function signTx(txParams, sign, txFormatter) {
  const {
    Transaction
  } = await Promise.resolve(/* import() */).then(__webpack_require__.t.bind(__webpack_require__, 999, 23));
  const finalTxParams = await txFormatter.formatTransaction(txParams);
  const ethTx = Transaction.from(objectSpread2_default()(objectSpread2_default()({}, finalTxParams), {}, {
    from: undefined // from is already calculated inside Transaction.from and is not allowed to be passed in
  }));
  const msgHash = (0,util_namespaceObject.stripHexPrefix)(ethTx.unsignedHash);
  const vrs = await sign(Buffer.from(msgHash, "hex"));
  let {
    v
  } = vrs;
  const {
    r,
    s
  } = vrs;

  // mpc-core-kit workaround (revert back to 0/1)
  if (v > 1) {
    v = v - 27;
  }

  // addSignature will handle the v value
  const tx = ethTx;
  tx.signature = external_ethers_.Signature.from({
    v,
    r: `0x${r.toString("hex")}`,
    s: `0x${s.toString("hex")}`
  });
  return tx.serialized;
}
async function signMessage(sign, data) {
  const message = (0,util_namespaceObject.stripHexPrefix)(data);
  const msgSig = await sign(Buffer.from(message, "hex"));
  let modifiedV = msgSig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const rawMsgSig = (0,base_controllers_namespaceObject.concatSig)(Buffer.from((0,util_namespaceObject.intToBytes)(modifiedV)), msgSig.r, msgSig.s);
  return rawMsgSig;
}
async function personalSign(sign, data) {
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  // we need to check if the data is hex or not
  // For historical reasons, you must submit the message to sign in hex-encoded UTF-8.
  // https://docs.metamask.io/wallet/how-to/sign-data/#use-personal_sign
  const message = (0,util_namespaceObject.isHexString)(data) ? Buffer.from((0,util_namespaceObject.stripHexPrefix)(data), "hex") : Buffer.from(data);
  const msgHash = (0,external_ethers_.hashMessage)(message);
  const prefix = Buffer.from(`\u0019Ethereum Signed Message:\n${message.length}`, "utf-8");
  const sig = await sign(Buffer.from(msgHash.slice(2), "hex"), Buffer.concat([prefix, message]));
  let modifiedV = sig.v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  const serialized = (0,base_controllers_namespaceObject.concatSig)(Buffer.from((0,util_namespaceObject.toBytes)(modifiedV)), sig.r, sig.s);
  return serialized;
}
function validateVersion(version, allowedVersions) {
  if (!Object.keys(ethereum_provider_namespaceObject.SignTypedDataVersion).includes(version)) {
    throw new Error(`Invalid version: '${version}'`);
  } else if (allowedVersions && !allowedVersions.includes(version)) {
    throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(", ")}`);
  }
}
async function signTypedData(sign, data, version) {
  validateVersion(version, undefined); // Note: this is intentional;
  if (data === null || data === undefined) {
    throw new Error("Missing data parameter");
  }
  const message = typeof data === "string" ? JSON.parse(data) : data;
  (0,external_viem_namespaceObject.validateTypedData)(message);
  const {
    v,
    r,
    s
  } = await sign(Buffer.from((0,external_viem_namespaceObject.hexToBytes)((0,external_viem_namespaceObject.hashTypedData)(message))));
  let modifiedV = v;
  if (modifiedV <= 1) {
    modifiedV = modifiedV + 27;
  }
  return (0,base_controllers_namespaceObject.concatSig)(Buffer.from((0,util_namespaceObject.toBytes)(modifiedV)), r, s);
}
function getProviderHandlers({
  txFormatter,
  sign,
  getPublic,
  getProviderEngineProxy
}) {
  return {
    getAccounts: async _ => {
      const pubKey = await getPublic();
      return [`0x${Buffer.from((0,util_namespaceObject.publicToAddress)(pubKey)).toString("hex")}`];
    },
    getPrivateKey: async _ => {
      throw auth_namespaceObject.providerErrors.custom({
        message: "MPC Provider cannot return private key",
        code: 4902
      });
    },
    getPublicKey: async _ => {
      const pubKey = await getPublic();
      return `0x${pubKey.toString("hex")}`;
    },
    processTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      const txHash = await providerEngineProxy.request({
        method: "eth_sendRawTransaction",
        params: [serializedTxn]
      });
      return txHash;
    },
    processSignTransaction: async (txParams, _) => {
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const serializedTxn = await signTx(txParams, sign, txFormatter);
      return serializedTxn;
    },
    processEthSignMessage: async (msgParams, _) => {
      const rawMessageSig = signMessage(sign, msgParams.data);
      return rawMessageSig;
    },
    processPersonalMessage: async (msgParams, _) => {
      const sig = personalSign(sign, msgParams.data);
      return sig;
    },
    processTypedMessageV4: async (msgParams, _) => {
      base_namespaceObject.log.debug("processTypedMessageV4", msgParams);
      const providerEngineProxy = getProviderEngineProxy();
      if (!providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
        message: "Provider is not initialized",
        code: 4902
      });
      const chainId = await providerEngineProxy.request({
        method: "eth_chainId"
      });
      await (0,ethereum_provider_namespaceObject.validateTypedSignMessageDataV4)(msgParams, chainId);
      const data = typeof msgParams.data === "string" ? JSON.parse(msgParams.data) : msgParams.data;
      const sig = signTypedData(sign, data, ethereum_provider_namespaceObject.SignTypedDataVersion.V4);
      return sig;
    }
  };
}
;// ./src/providers/signingProviders/EthereumSigningProvider.ts


var _EthereumSigningProvider;







class EthereumSigningProvider extends base_provider_namespaceObject.BaseProvider {
  constructor({
    config,
    state
  }) {
    super({
      config: {
        chainConfig: objectSpread2_default()(objectSpread2_default()({}, config.chainConfig), {}, {
          chainNamespace: base_namespaceObject.CHAIN_NAMESPACES.EIP155
        })
      },
      state
    });
    defineProperty_default()(this, "PROVIDER_CHAIN_NAMESPACE", base_namespaceObject.CHAIN_NAMESPACES.EIP155);
  }
  async enable() {
    if (!this.state.signMethods) throw auth_namespaceObject.providerErrors.custom({
      message: "signMethods are not found in state, plz pass it in constructor state param",
      code: 4902
    });
    await this.setupProvider(this.state.signMethods);
    return this._providerEngineProxy.request({
      method: "eth_accounts"
    });
  }
  async setupProvider({
    sign,
    getPublic
  }) {
    const {
      chainNamespace
    } = this.config.chainConfig;
    if (chainNamespace !== this.PROVIDER_CHAIN_NAMESPACE) throw base_namespaceObject.WalletInitializationError.incompatibleChainNameSpace("Invalid chain namespace");
    const txFormatter = new ethereum_provider_namespaceObject.TransactionFormatter({
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const providerHandlers = getProviderHandlers({
      txFormatter,
      sign,
      getPublic,
      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)
    });
    const ethMiddleware = (0,ethereum_provider_namespaceObject.createEthMiddleware)(providerHandlers);
    const chainSwitchMiddleware = this.getChainSwitchMiddleware();
    const engine = new auth_namespaceObject.JRPCEngine();
    // Not a partial anymore because of checks in ctor
    const {
      networkMiddleware
    } = (0,ethereum_provider_namespaceObject.createJsonRpcClient)(this.config.chainConfig);
    engine.push(ethMiddleware);
    engine.push(chainSwitchMiddleware);
    engine.push(this.getAccountMiddleware());
    engine.push(networkMiddleware);
    const provider = (0,auth_namespaceObject.providerFromEngine)(engine);
    this.updateProviderEngineProxy(provider);
    await txFormatter.init();
    await this.lookupNetwork();
    this.state.signMethods = {
      sign,
      getPublic
    };
  }
  async updateAccount(params) {
    if (!this._providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const currentSignMethods = this.state.signMethods;
    if (!currentSignMethods) {
      throw auth_namespaceObject.providerErrors.custom({
        message: "signing methods are unavailable ",
        code: 4092
      });
    }
    const currentPubKey = (await currentSignMethods.getPublic()).toString("hex");
    const updatePubKey = (await params.signMethods.getPublic()).toString("hex");
    if (currentPubKey !== updatePubKey) {
      await this.setupProvider(params.signMethods);
      const accounts = await this._providerEngineProxy.request({
        method: "eth_accounts"
      });
      this.emit("accountsChanged", accounts);
    }
  }
  async switchChain(params) {
    if (!this._providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const chainConfig = this.getChainConfig(params.chainId);
    this.update({
      chainId: "loading"
    });
    this.configure({
      chainConfig
    });
    if (!this.state.signMethods) {
      throw auth_namespaceObject.providerErrors.custom({
        message: "sign methods are undefined",
        code: 4902
      });
    }
    await this.setupProvider(this.state.signMethods);
  }
  async lookupNetwork() {
    if (!this._providerEngineProxy) throw auth_namespaceObject.providerErrors.custom({
      message: "Provider is not initialized",
      code: 4902
    });
    const {
      chainId
    } = this.config.chainConfig;
    if (!chainId) throw auth_namespaceObject.rpcErrors.invalidParams("chainId is required while lookupNetwork");
    const network = await this._providerEngineProxy.request({
      method: "net_version",
      params: []
    });
    const finalNetwork = (0,util_namespaceObject.isHexString)(network) ? parseInt(network, 16) : parseInt(network, 10);
    if (parseInt(chainId, 16) !== finalNetwork) throw auth_namespaceObject.providerErrors.chainDisconnected(`Invalid network, net_version is: ${network}`);
    if (this.state.chainId !== chainId) {
      this.emit("chainChanged", chainId);
      this.emit("connect", {
        chainId
      });
    }
    this.update({
      chainId
    });
    return network;
  }
  getChainSwitchMiddleware() {
    const chainSwitchHandlers = {
      addChain: async params => {
        const {
          chainId,
          chainName,
          rpcUrls,
          blockExplorerUrls,
          nativeCurrency,
          iconUrls
        } = params;
        this.addChain({
          chainNamespace: base_namespaceObject.CHAIN_NAMESPACES.EIP155,
          chainId,
          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || "ETH",
          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || "Ether",
          displayName: chainName,
          rpcTarget: rpcUrls[0],
          blockExplorerUrl: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || "",
          decimals: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.decimals) || 18,
          logo: (iconUrls === null || iconUrls === void 0 ? void 0 : iconUrls[0]) || "https://images.toruswallet.io/eth.svg"
        });
      },
      switchChain: async params => {
        const {
          chainId
        } = params;
        await this.switchChain({
          chainId
        });
      }
    };
    const chainSwitchMiddleware = (0,ethereum_provider_namespaceObject.createChainSwitchMiddleware)(chainSwitchHandlers);
    return chainSwitchMiddleware;
  }
  getAccountMiddleware() {
    const accountHandlers = {
      updateSignMethods: async params => {
        await this.updateAccount(params);
      }
    };
    return createAccountMiddleware(accountHandlers);
  }
}
_EthereumSigningProvider = EthereumSigningProvider;
defineProperty_default()(EthereumSigningProvider, "getProviderInstance", async params => {
  const providerFactory = new _EthereumSigningProvider({
    config: {
      chainConfig: params.chainConfig
    }
  });
  await providerFactory.setupProvider(params.signMethods);
  return providerFactory;
});
;// ./src/providers/signingProviders/index.ts

;// ./src/providers/index.ts

;// ./src/index.ts

module.exports = __webpack_exports__;
/******/ })()
;