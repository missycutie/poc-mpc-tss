import {
  secp256k1
} from "./chunk-NQ6JAIIU.js";
import {
  __export
} from "./chunk-OL46QLBJ.js";

// node_modules/@ethereumjs/rlp/dist/esm/index.js
function encode(input) {
  if (Array.isArray(input)) {
    const output = [];
    let outputLength = 0;
    for (let i = 0; i < input.length; i++) {
      const encoded = encode(input[i]);
      output.push(encoded);
      outputLength += encoded.length;
    }
    return concatBytes(encodeLength(outputLength, 192), ...output);
  }
  const inputBuf = toBytes(input);
  if (inputBuf.length === 1 && inputBuf[0] < 128) {
    return inputBuf;
  }
  return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
function safeSlice(input, start, end) {
  if (end > input.length) {
    throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
  }
  return input.slice(start, end);
}
function decodeLength(v) {
  if (v[0] === 0) {
    throw new Error("invalid RLP: extra zeros");
  }
  return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
  if (len < 56) {
    return Uint8Array.from([len + offset]);
  }
  const hexLength = numberToHex(len);
  const lLength = hexLength.length / 2;
  const firstByte = numberToHex(offset + 55 + lLength);
  return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
  if (typeof input === "undefined" || input === null || input.length === 0) {
    return Uint8Array.from([]);
  }
  const inputBytes = toBytes(input);
  const decoded = _decode(inputBytes);
  if (stream) {
    return {
      data: decoded.data,
      remainder: decoded.remainder.slice()
    };
  }
  if (decoded.remainder.length !== 0) {
    throw new Error("invalid RLP: remainder must be zero");
  }
  return decoded.data;
}
function _decode(input) {
  let length, llength, data, innerRemainder, d;
  const decoded = [];
  const firstByte = input[0];
  if (firstByte <= 127) {
    return {
      data: input.slice(0, 1),
      remainder: input.subarray(1)
    };
  } else if (firstByte <= 183) {
    length = firstByte - 127;
    if (firstByte === 128) {
      data = Uint8Array.from([]);
    } else {
      data = safeSlice(input, 1, length);
    }
    if (length === 2 && data[0] < 128) {
      throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
    }
    return {
      data,
      remainder: input.subarray(length)
    };
  } else if (firstByte <= 191) {
    llength = firstByte - 182;
    if (input.length - 1 < llength) {
      throw new Error("invalid RLP: not enough bytes for string length");
    }
    length = decodeLength(safeSlice(input, 1, llength));
    if (length <= 55) {
      throw new Error("invalid RLP: expected string length to be greater than 55");
    }
    data = safeSlice(input, llength, length + llength);
    return {
      data,
      remainder: input.subarray(length + llength)
    };
  } else if (firstByte <= 247) {
    length = firstByte - 191;
    innerRemainder = safeSlice(input, 1, length);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(length)
    };
  } else {
    llength = firstByte - 246;
    length = decodeLength(safeSlice(input, 1, llength));
    if (length < 56) {
      throw new Error("invalid RLP: encoded list too short");
    }
    const totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error("invalid RLP: total length is larger than the data");
    }
    innerRemainder = safeSlice(input, llength, totalLength);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.subarray(totalLength)
    };
  }
}
var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += cachedHexes[uint8a[i]];
  }
  return hex;
}
function parseHexByte(hexByte) {
  const byte = Number.parseInt(hexByte, 16);
  if (Number.isNaN(byte))
    throw new Error("Invalid byte sequence");
  return byte;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array.length; i++) {
    const j = i * 2;
    array[i] = parseHexByte(hex.slice(j, j + 2));
  }
  return array;
}
function concatBytes(...arrays) {
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
function utf8ToBytes(utf) {
  return new TextEncoder().encode(utf);
}
function numberToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }
  const hex = integer.toString(16);
  return hex.length % 2 ? `0${hex}` : hex;
}
function padToEven(a) {
  return a.length % 2 ? `0${a}` : a;
}
function isHexPrefixed(str) {
  return str.length >= 2 && str[0] === "0" && str[1] === "x";
}
function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }
  return isHexPrefixed(str) ? str.slice(2) : str;
}
function toBytes(v) {
  if (v instanceof Uint8Array) {
    return v;
  }
  if (typeof v === "string") {
    if (isHexPrefixed(v)) {
      return hexToBytes(padToEven(stripHexPrefix(v)));
    }
    return utf8ToBytes(v);
  }
  if (typeof v === "number" || typeof v === "bigint") {
    if (!v) {
      return Uint8Array.from([]);
    }
    return hexToBytes(numberToHex(v));
  }
  if (v === null || v === void 0) {
    return Uint8Array.from([]);
  }
  throw new Error("toBytes: received unsupported type " + typeof v);
}
var RLP = { encode, decode };

// node_modules/ethereum-cryptography/esm/secp256k1.js
var secp256k1_exports = {};
__export(secp256k1_exports, {
  secp256k1: () => secp256k1
});

export {
  secp256k1_exports,
  RLP
};
//# sourceMappingURL=chunk-2KFWL72M.js.map
