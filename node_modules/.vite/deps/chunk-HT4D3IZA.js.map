{
  "version": 3,
  "sources": ["../../@toruslabs/broadcast-channel/dist/lib.esm/methods/native.js", "../../@toruslabs/broadcast-channel/dist/lib.esm/util.js", "../../@toruslabs/broadcast-channel/dist/lib.esm/methods/indexed-db.js", "../../oblivious-set/src/index.ts", "../../@toruslabs/broadcast-channel/dist/lib.esm/options.js", "../../@toruslabs/broadcast-channel/dist/lib.esm/methods/localstorage.js", "../../@toruslabs/broadcast-channel/dist/lib.esm/methods/server.js", "../../@toruslabs/broadcast-channel/node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js", "../../@toruslabs/broadcast-channel/dist/lib.esm/methods/simulate.js", "../../@toruslabs/broadcast-channel/dist/lib.esm/method-chooser.js", "../../@toruslabs/broadcast-channel/dist/lib.esm/broadcast-channel.js"],
  "sourcesContent": ["import { microSeconds as microSeconds$1, PROMISE_RESOLVED_VOID } from '../util.js';\n\nconst microSeconds = microSeconds$1;\nconst type = 'native';\nfunction create(channelName) {\n  const state = {\n    time: microSeconds$1(),\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName),\n    subFns: [] // subscriberFunctions\n  };\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data);\n    }\n  };\n  return state;\n}\nfunction close(channelState) {\n  channelState.bc.close();\n  channelState.subFns = [];\n}\nfunction postMessage(channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false);\n    return PROMISE_RESOLVED_VOID;\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  /**\n   * in the electron-renderer, isNode will be true even if we are in browser-context\n   * so we also check if window is undefined\n   */\n  if (typeof window === 'undefined') return false;\n  if (typeof BroadcastChannel === 'function') {\n    if (BroadcastChannel._pubkey) {\n      throw new Error('BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill');\n    }\n    return true;\n  } else return false;\n}\nfunction averageResponseTime() {\n  return 150;\n}\n\nexport { averageResponseTime, canBeUsed, close, create, microSeconds, onMessage, postMessage, type };\n", "import loglevel from 'loglevel';\n\n// import Bowser from 'bowser';\n\n/**\n * returns true if the given object is a promise\n */\nfunction isPromise(obj) {\n  if (obj && typeof obj.then === 'function') {\n    return true;\n  } else {\n    return false;\n  }\n}\nPromise.resolve(false);\nPromise.resolve(true);\nconst PROMISE_RESOLVED_VOID = Promise.resolve();\nfunction sleep(time, resolveWith) {\n  if (!time) time = 0;\n  return new Promise(res => setTimeout(() => res(resolveWith), time));\n}\nfunction randomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * https://stackoverflow.com/a/8084248\n */\nfunction randomToken() {\n  return Math.random().toString(36).substring(2);\n}\nlet lastMs = 0;\n\n/**\n * returns the current time in micro-seconds,\n * WARNING: This is a pseudo-function\n * Performance.now is not reliable in webworkers, so we just make sure to never return the same time.\n * This is enough in browsers, and this function will not be used in nodejs.\n * The main reason for this hack is to ensure that BroadcastChannel behaves equal to production when it is used in fast-running unit tests.\n */\nfunction microSeconds() {\n  let ret = Date.now() * 1000; // milliseconds to microseconds\n  if (ret <= lastMs) {\n    ret = lastMs + 1;\n  }\n  lastMs = ret;\n  return ret;\n}\n\n// the problem is only in iframes. we should default to server in case of iframes.\n// storage scoping is present in all browsers now\n// Safari and other browsers support native Broadcast channel now. It's in LS.\n// test here: https://pubkey.github.io/broadcast-channel/e2e.html?methodType=native\n// https://caniuse.com/broadcastchannel\n// export function are3PCSupported() {\n//     if (typeof navigator === 'undefined') return false;\n//     const browserInfo = Bowser.parse(navigator.userAgent);\n//     log.info(JSON.stringify(browserInfo), 'current browser info');\n\n//     let thirdPartyCookieSupport = true;\n//     // brave\n//     if (navigator.brave) {\n//         thirdPartyCookieSupport = false;\n//     }\n//     // All webkit & gecko engine instances use itp (intelligent tracking prevention -\n//     // https://webkit.org/tracking-prevention/#intelligent-tracking-prevention-itp)\n//     if (browserInfo.engine.name === Bowser.ENGINE_MAP.WebKit || browserInfo.engine.name === Bowser.ENGINE_MAP.Gecko) {\n//         thirdPartyCookieSupport = false;\n//     }\n\n//     return thirdPartyCookieSupport;\n// }\n\nconst log = loglevel.getLogger('broadcast-channel');\nlog.setLevel('error');\n\nexport { PROMISE_RESOLVED_VOID, isPromise, log, microSeconds, randomInt, randomToken, sleep };\n", "import { microSeconds as microSeconds$1, randomToken, PROMISE_RESOLVED_VOID, sleep, randomInt } from '../util.js';\nimport { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\n\n/**\n * this method uses indexeddb to store the messages\n * There is currently no observerAPI for idb\n * @link https://github.com/w3c/IndexedDB/issues/51\n *\n * When working on this, ensure to use these performance optimizations:\n * @link https://rxdb.info/slow-indexeddb.html\n */\n\nconst microSeconds = microSeconds$1;\nconst DB_PREFIX = 'pubkey.broadcast-channel-0-';\nconst OBJECT_STORE_ID = 'messages';\n\n/**\n * Use relaxed durability for faster performance on all transactions.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nconst TRANSACTION_SETTINGS = {\n  durability: 'relaxed'\n};\nconst type = 'idb';\nfunction getIdb() {\n  if (typeof indexedDB !== 'undefined') return indexedDB;\n  if (typeof window !== 'undefined') {\n    if (typeof window.mozIndexedDB !== 'undefined') return window.mozIndexedDB;\n    if (typeof window.webkitIndexedDB !== 'undefined') return window.webkitIndexedDB;\n    if (typeof window.msIndexedDB !== 'undefined') return window.msIndexedDB;\n  }\n  return false;\n}\n\n/**\n * If possible, we should explicitly commit IndexedDB transactions\n * for better performance.\n * @link https://nolanlawson.com/2021/08/22/speeding-up-indexeddb-reads-and-writes/\n */\nfunction commitIndexedDBTransaction(tx) {\n  if (tx.commit) {\n    tx.commit();\n  }\n}\nfunction createDatabase(channelName) {\n  const IndexedDB = getIdb();\n\n  // create table\n  const dbName = DB_PREFIX + channelName;\n\n  /**\n   * All IndexedDB databases are opened without version\n   * because it is a bit faster, especially on firefox\n   * @link http://nparashuram.com/IndexedDB/perf/#Open%20Database%20with%20version\n   */\n  const openRequest = IndexedDB.open(dbName);\n  openRequest.onupgradeneeded = ev => {\n    const db = ev.target.result;\n    db.createObjectStore(OBJECT_STORE_ID, {\n      keyPath: 'id',\n      autoIncrement: true\n    });\n  };\n  const dbPromise = new Promise((res, rej) => {\n    openRequest.onerror = ev => rej(ev);\n    openRequest.onsuccess = () => {\n      res(openRequest.result);\n    };\n  });\n  return dbPromise;\n}\n\n/**\n * writes the new message to the database\n * so other readers can find it\n */\nfunction writeMessage(db, readerUuid, messageJson) {\n  const time = Date.now();\n  const writeObject = {\n    uuid: readerUuid,\n    time,\n    data: messageJson\n  };\n  const tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  return new Promise((res, rej) => {\n    tx.oncomplete = () => res();\n    tx.onerror = ev => rej(ev);\n    const objectStore = tx.objectStore(OBJECT_STORE_ID);\n    objectStore.add(writeObject);\n    commitIndexedDBTransaction(tx);\n  });\n}\nfunction getAllMessages(db) {\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  return new Promise(res => {\n    objectStore.openCursor().onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        ret.push(cursor.value);\n        //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n        cursor.continue();\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction getMessagesHigherThan(db, lastCursorId) {\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n\n  /**\n   * Optimization shortcut,\n   * if getAll() can be used, do not use a cursor.\n   * @link https://rxdb.info/slow-indexeddb.html\n   */\n  if (objectStore.getAll) {\n    const getAllRequest = objectStore.getAll(keyRangeValue);\n    return new Promise((res, rej) => {\n      getAllRequest.onerror = err => rej(err);\n      getAllRequest.onsuccess = function (e) {\n        res(e.target.result);\n      };\n    });\n  }\n  function openCursor() {\n    // Occasionally Safari will fail on IDBKeyRange.bound, this\n    // catches that error, having it open the cursor to the first\n    // item. When it gets data it will advance to the desired key.\n    try {\n      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);\n      return objectStore.openCursor(keyRangeValue);\n    } catch (e) {\n      return objectStore.openCursor();\n    }\n  }\n  return new Promise((res, rej) => {\n    const openCursorRequest = openCursor();\n    openCursorRequest.onerror = err => rej(err);\n    openCursorRequest.onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        if (cursor.value.id < lastCursorId + 1) {\n          cursor.continue(lastCursorId + 1);\n        } else {\n          ret.push(cursor.value);\n          cursor.continue();\n        }\n      } else {\n        commitIndexedDBTransaction(tx);\n        res(ret);\n      }\n    };\n  });\n}\nfunction removeMessagesById(db, ids) {\n  const tx = db.transaction([OBJECT_STORE_ID], 'readwrite', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  return Promise.all(ids.map(id => {\n    const deleteRequest = objectStore.delete(id);\n    return new Promise(res => {\n      deleteRequest.onsuccess = () => res();\n    });\n  }));\n}\nfunction getOldMessages(db, ttl) {\n  const olderThen = Date.now() - ttl;\n  const tx = db.transaction(OBJECT_STORE_ID, 'readonly', TRANSACTION_SETTINGS);\n  const objectStore = tx.objectStore(OBJECT_STORE_ID);\n  const ret = [];\n  return new Promise(res => {\n    objectStore.openCursor().onsuccess = ev => {\n      const cursor = ev.target.result;\n      if (cursor) {\n        const msgObk = cursor.value;\n        if (msgObk.time < olderThen) {\n          ret.push(msgObk);\n          //alert(\"Name for SSN \" + cursor.key + \" is \" + cursor.value.name);\n          cursor.continue();\n        } else {\n          // no more old messages,\n          commitIndexedDBTransaction(tx);\n          res(ret);\n          return;\n        }\n      } else {\n        res(ret);\n      }\n    };\n  });\n}\nfunction cleanOldMessages(db, ttl) {\n  return getOldMessages(db, ttl).then(tooOld => {\n    return removeMessagesById(db, tooOld.map(msg => msg.id));\n  });\n}\nfunction create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  return createDatabase(channelName).then(db => {\n    const state = {\n      closed: false,\n      lastCursorId: 0,\n      channelName,\n      options,\n      uuid: randomToken(),\n      /**\n       * emittedMessagesIds\n       * contains all messages that have been emitted before\n       * @type {ObliviousSet}\n       */\n      eMIs: new ObliviousSet(options.idb.ttl * 2),\n      // ensures we do not read messages in parrallel\n      writeBlockPromise: PROMISE_RESOLVED_VOID,\n      messagesCallback: null,\n      readQueuePromises: [],\n      db,\n      time: microSeconds$1()\n    };\n\n    /**\n     * Handle abrupt closes that do not originate from db.close().\n     * This could happen, for example, if the underlying storage is\n     * removed or if the user clears the database in the browser's\n     * history preferences.\n     */\n    db.onclose = function () {\n      state.closed = true;\n      if (options.idb.onclose) options.idb.onclose();\n    };\n\n    /**\n     * if service-workers are used,\n     * we have no 'storage'-event if they post a message,\n     * therefore we also have to set an interval\n     */\n    _readLoop(state);\n    return state;\n  });\n}\nfunction _readLoop(state) {\n  if (state.closed) return;\n  readNewMessages(state).then(() => sleep(state.options.idb.fallbackInterval)).then(() => _readLoop(state));\n}\nfunction _filterMessage(msgObj, state) {\n  if (msgObj.uuid === state.uuid) return false; // send by own\n  if (state.eMIs.has(msgObj.id)) return false; // already emitted\n  if (msgObj.data.time < state.messagesCallbackTime) return false; // older then onMessageCallback\n  return true;\n}\n\n/**\n * reads all new messages from the database and emits them\n */\nfunction readNewMessages(state) {\n  // channel already closed\n  if (state.closed) return PROMISE_RESOLVED_VOID;\n\n  // if no one is listening, we do not need to scan for new messages\n  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;\n  return getMessagesHigherThan(state.db, state.lastCursorId).then(newerMessages => {\n    const useMessages = newerMessages\n    /**\n     * there is a bug in iOS where the msgObj can be undefined some times\n     * so we filter them out\n     * @link https://github.com/pubkey/broadcast-channel/issues/19\n     */.filter(msgObj => !!msgObj).map(msgObj => {\n      if (msgObj.id > state.lastCursorId) {\n        state.lastCursorId = msgObj.id;\n      }\n      return msgObj;\n    }).filter(msgObj => _filterMessage(msgObj, state)).sort((msgObjA, msgObjB) => msgObjA.time - msgObjB.time); // sort by time\n    useMessages.forEach(msgObj => {\n      if (state.messagesCallback) {\n        state.eMIs.add(msgObj.id);\n        state.messagesCallback(msgObj.data);\n      }\n    });\n    return PROMISE_RESOLVED_VOID;\n  });\n}\nfunction close(channelState) {\n  channelState.closed = true;\n  channelState.db.close();\n}\nfunction postMessage(channelState, messageJson) {\n  channelState.writeBlockPromise = channelState.writeBlockPromise.then(() => writeMessage(channelState.db, channelState.uuid, messageJson)).then(() => {\n    if (randomInt(0, 10) === 0) {\n      /* await (do not await) */\n      cleanOldMessages(channelState.db, channelState.options.idb.ttl);\n    }\n  });\n  return channelState.writeBlockPromise;\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n  readNewMessages(channelState);\n}\nfunction canBeUsed() {\n  const idb = getIdb();\n  if (!idb) return false;\n  return true;\n}\nfunction averageResponseTime(options) {\n  return options.idb.fallbackInterval * 2;\n}\n\nexport { TRANSACTION_SETTINGS, averageResponseTime, canBeUsed, cleanOldMessages, close, commitIndexedDBTransaction, create, createDatabase, getAllMessages, getIdb, getMessagesHigherThan, getOldMessages, microSeconds, onMessage, postMessage, removeMessagesById, type, writeMessage };\n", "\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet<T = any> {\n    public readonly map = new Map();\n\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n    public _to: boolean = false;\n    constructor(\n        public readonly ttl: number\n    ) { }\n\n    has(value: T): boolean {\n        return this.map.has(value);\n    }\n\n    add(value: T): void {\n        this.map.set(value, now());\n\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(() => {\n                this._to = false;\n                removeTooOldValues(this);\n            }, 0);\n        }\n    }\n\n    clear() {\n        this.map.clear();\n    }\n}\n\n\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(\n    obliviousSet: ObliviousSet\n) {\n    const olderThen = now() - obliviousSet.ttl;\n    const iterator = obliviousSet.map[Symbol.iterator]();\n\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n\n        const next = iterator.next().value;\n\n        if (!next) {\n            return; // no more elements\n        }\n        const value = next[0];\n        const time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        } else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\n\nexport function now(): number {\n    return Date.now();\n}\n\n\n", "function fillOptionsWithDefaults(originalOptions = {}) {\n  const options = JSON.parse(JSON.stringify(originalOptions));\n\n  // main\n  if (typeof options.webWorkerSupport === 'undefined') options.webWorkerSupport = true;\n\n  // indexed-db\n  if (!options.idb) options.idb = {};\n  //  after this time the messages get deleted\n  if (!options.idb.ttl) options.idb.ttl = 1000 * 45;\n  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;\n  //  handles abrupt db onclose events.\n  if (originalOptions.idb && typeof originalOptions.idb.onclose === 'function') options.idb.onclose = originalOptions.idb.onclose;\n\n  // localstorage\n  if (!options.localstorage) options.localstorage = {};\n  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1000 * 60;\n\n  // server\n  if (!options.server) options.server = {};\n  if (!options.server.url) options.server.url = 'https://session.web3auth.io';\n  if (!options.server.removeTimeout) options.server.removeTimeout = 1000 * 60 * 5; // 5 minutes\n\n  // custom methods\n  if (originalOptions.methods) options.methods = originalOptions.methods;\n  return options;\n}\n\nexport { fillOptionsWithDefaults };\n", "import { ObliviousSet } from 'oblivious-set';\nimport { fillOptionsWithDefaults } from '../options.js';\nimport { microSeconds as microSeconds$1, sleep, randomToken } from '../util.js';\n\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nconst microSeconds = microSeconds$1;\nconst KEY_PREFIX = 'pubkey.broadcastChannel-';\nconst type = 'localstorage';\n\n/**\n * copied from crosstab\n * @link https://github.com/tejacques/crosstab/blob/master/src/crosstab.js#L32\n */\nfunction getLocalStorage() {\n  let localStorage;\n  if (typeof window === 'undefined') return null;\n  try {\n    localStorage = window.localStorage;\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage;\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage;\n}\nfunction storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nfunction postMessage(channelState, messageJson) {\n  return new Promise(res => {\n    sleep().then(() => {\n      const key = storageKey(channelState.channelName);\n      const writeObj = {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      };\n      const value = JSON.stringify(writeObj);\n      getLocalStorage().setItem(key, value);\n\n      /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n      const ev = document.createEvent('Event');\n      ev.initEvent('storage', true, true);\n      ev.key = key;\n      ev.newValue = value;\n      window.dispatchEvent(ev);\n      res();\n    });\n  });\n}\nfunction addStorageEventListener(channelName, fn) {\n  const key = storageKey(channelName);\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue));\n    }\n  };\n  window.addEventListener('storage', listener);\n  return listener;\n}\nfunction removeStorageEventListener(listener) {\n  window.removeEventListener('storage', listener);\n}\nfunction create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  if (!canBeUsed()) {\n    throw new Error('BroadcastChannel: localstorage cannot be used');\n  }\n  const uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  const eMIs = new ObliviousSet(options.localstorage.removeTimeout);\n  const state = {\n    channelName,\n    uuid,\n    time: microSeconds$1(),\n    eMIs // emittedMessagesIds\n  };\n  state.listener = addStorageEventListener(channelName, msgObj => {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === uuid) return; // own message\n    if (!msgObj.token || eMIs.has(msgObj.token)) return; // already emitted\n    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  return state;\n}\nfunction close(channelState) {\n  removeStorageEventListener(channelState.listener);\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  const ls = getLocalStorage();\n  if (!ls) return false;\n  try {\n    const key = '__broadcastchannel_check';\n    ls.setItem(key, 'works');\n    ls.removeItem(key);\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n    return false;\n  }\n  return true;\n}\nfunction averageResponseTime() {\n  const defaultTime = 120;\n  const userAgent = navigator.userAgent.toLowerCase();\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2;\n  }\n  return defaultTime;\n}\n\nexport { addStorageEventListener, averageResponseTime, canBeUsed, close, create, getLocalStorage, microSeconds, onMessage, postMessage, removeStorageEventListener, storageKey, type };\n", "import { ObliviousSet } from 'oblivious-set';\nimport { io } from 'socket.io-client';\nimport { getPublic, sign } from '@toruslabs/eccrypto';\nimport { keccak256, encryptData, decryptData } from '@toruslabs/metadata-helpers';\nimport { microSeconds as microSeconds$1, sleep, randomToken, log } from '../util.js';\nimport { fillOptionsWithDefaults } from '../options.js';\n\n/**\n * A localStorage-only method which uses localstorage and its 'storage'-event\n * This does not work inside of webworkers because they have no access to locastorage\n * This is basically implemented to support IE9 or your grandmothers toaster.\n * @link https://caniuse.com/#feat=namevalue-storage\n * @link https://caniuse.com/#feat=indexeddb\n */\n\nconst microSeconds = microSeconds$1;\nconst KEY_PREFIX = 'pubkey.broadcastChannel-';\nconst type = 'server';\nlet SOCKET_CONN_INSTANCE = null;\n// used to decide to reconnect socket e.g. when socket connection is disconnected unexpectedly\nconst runningChannels = new Set();\nfunction storageKey(channelName) {\n  return KEY_PREFIX + channelName;\n}\n\n/**\n * writes the new message to the storage\n * and fires the storage-event so other readers can find it\n */\nfunction postMessage(channelState, messageJson) {\n  return new Promise((res, rej) => {\n    sleep().then(async () => {\n      const key = storageKey(channelState.channelName);\n      const channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n      const encData = await encryptData(channelEncPrivKey.toString('hex'), {\n        token: randomToken(),\n        time: Date.now(),\n        data: messageJson,\n        uuid: channelState.uuid\n      });\n      const body = {\n        sameOriginCheck: true,\n        sameIpCheck: true,\n        key: getPublic(channelEncPrivKey).toString('hex'),\n        data: encData,\n        signature: (await sign(channelEncPrivKey, keccak256(Buffer.from(encData, 'utf8')))).toString('hex')\n      };\n      if (channelState.timeout) body.timeout = channelState.timeout;\n      return fetch(channelState.serverUrl + '/channel/set', {\n        method: 'POST',\n        body: JSON.stringify(body),\n        headers: {\n          'Content-Type': 'application/json; charset=utf-8'\n        }\n      }).then(res).catch(rej);\n    });\n  });\n}\nfunction getSocketInstance(serverUrl) {\n  if (SOCKET_CONN_INSTANCE) {\n    return SOCKET_CONN_INSTANCE;\n  }\n  const SOCKET_CONN = io(serverUrl, {\n    transports: ['websocket', 'polling'],\n    // use WebSocket first, if available\n    withCredentials: true,\n    reconnectionDelayMax: 10000,\n    reconnectionAttempts: 10\n  });\n  SOCKET_CONN.on('connect_error', err => {\n    // revert to classic upgrade\n    SOCKET_CONN.io.opts.transports = ['polling', 'websocket'];\n    log.error('connect error', err);\n  });\n  SOCKET_CONN.on('connect', async () => {\n    const {\n      engine\n    } = SOCKET_CONN.io;\n    log.debug('initially connected to', engine.transport.name); // in most cases, prints \"polling\"\n    engine.once('upgrade', () => {\n      // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)\n      log.debug('upgraded', engine.transport.name); // in most cases, prints \"websocket\"\n    });\n    engine.once('close', reason => {\n      // called when the underlying connection is closed\n      log.debug('connection closed', reason);\n    });\n  });\n  SOCKET_CONN.on('error', err => {\n    log.error('socket errored', err);\n    SOCKET_CONN.disconnect();\n  });\n  SOCKET_CONN_INSTANCE = SOCKET_CONN;\n  return SOCKET_CONN;\n}\nfunction setupSocketConnection(serverUrl, channelState, fn) {\n  const socketConn = getSocketInstance(serverUrl);\n  const key = storageKey(channelState.channelName);\n  const channelEncPrivKey = keccak256(Buffer.from(key, 'utf8'));\n  const channelPubKey = getPublic(channelEncPrivKey).toString('hex');\n  if (socketConn.connected) {\n    socketConn.emit('check_auth_status', channelPubKey, {\n      sameOriginCheck: true,\n      sameIpCheck: true\n    });\n  } else {\n    socketConn.once('connect', () => {\n      log.debug('connected with socket');\n      socketConn.emit('check_auth_status', channelPubKey, {\n        sameOriginCheck: true,\n        sameIpCheck: true\n      });\n    });\n  }\n  const reconnect = () => {\n    socketConn.once('connect', async () => {\n      if (runningChannels.has(channelState.channelName)) {\n        socketConn.emit('check_auth_status', channelPubKey, {\n          sameOriginCheck: true,\n          sameIpCheck: true\n        });\n      }\n    });\n  };\n  const visibilityListener = () => {\n    // if channel is closed, then remove the listener.\n    if (!socketConn || !runningChannels.has(channelState.channelName)) {\n      document.removeEventListener('visibilitychange', visibilityListener);\n      return;\n    }\n    // if not connected, then wait for connection and ping server for latest msg.\n    if (!socketConn.connected && document.visibilityState === 'visible') {\n      reconnect();\n    }\n  };\n  const listener = async ev => {\n    try {\n      const decData = await decryptData(channelEncPrivKey.toString('hex'), ev);\n      log.info(decData);\n      fn(decData);\n    } catch (error) {\n      log.error(error);\n    }\n  };\n  socketConn.on('disconnect', () => {\n    log.debug('socket disconnected');\n    if (runningChannels.has(channelState.channelName)) {\n      log.error('socket disconnected unexpectedly, reconnecting socket');\n      reconnect();\n    }\n  });\n  socketConn.on(`${channelPubKey}_success`, listener);\n  if (typeof document !== 'undefined') document.addEventListener('visibilitychange', visibilityListener);\n  return socketConn;\n}\nfunction removeStorageEventListener() {\n  if (SOCKET_CONN_INSTANCE) {\n    SOCKET_CONN_INSTANCE.disconnect();\n  }\n}\nfunction create(channelName, options) {\n  options = fillOptionsWithDefaults(options);\n  const uuid = randomToken();\n\n  /**\n   * eMIs\n   * contains all messages that have been emitted before\n   * @type {ObliviousSet}\n   */\n  const eMIs = new ObliviousSet(options.server.removeTimeout);\n  const state = {\n    channelName,\n    uuid,\n    eMIs,\n    // emittedMessagesIds\n    serverUrl: options.server.url,\n    time: microSeconds$1()\n  };\n  if (options.server.timeout) state.timeout = options.server.timeout;\n  setupSocketConnection(options.server.url, state, msgObj => {\n    if (!state.messagesCallback) return; // no listener\n    if (msgObj.uuid === state.uuid) return; // own message\n    if (!msgObj.token || state.eMIs.has(msgObj.token)) return; // already emitted\n    // if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return; // too old\n\n    state.eMIs.add(msgObj.token);\n    state.messagesCallback(msgObj.data);\n  });\n  runningChannels.add(channelName);\n  return state;\n}\nfunction close(channelState) {\n  runningChannels.delete(channelState.channelName);\n  // give 2 sec for all msgs which are in transit to be consumed\n  // by receiver.\n  // window.setTimeout(() => {\n  //     removeStorageEventListener(channelState);\n  //     SOCKET_CONN_INSTANCE = null;\n  // }, 1000);\n}\nfunction onMessage(channelState, fn, time) {\n  channelState.messagesCallbackTime = time;\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  return true;\n}\nfunction averageResponseTime() {\n  const defaultTime = 500;\n  // TODO: Maybe increase it based on operation\n  return defaultTime;\n}\n\nexport { averageResponseTime, canBeUsed, close, create, getSocketInstance, microSeconds, onMessage, postMessage, removeStorageEventListener, setupSocketConnection, storageKey, type };\n", "import { ec as ec$1 } from 'elliptic';\n\nconst ec = new ec$1(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, n/no-unsupported-features/node-builtins\nconst browserCrypto = globalThis.crypto || globalThis.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(browserCrypto.randomBytes(size));\n  }\n  const arr = new Uint8Array(size);\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (!browserCrypto.createHash) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = browserCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle && subtle[op] && subtle.importKey) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      // encrypt and decrypt ops are not implemented in react-native-quick-crypto yet.\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\" && browserCrypto.createCipheriv) {\n      // This is available if crypto is polyfilled in react native environment\n      const cipher = browserCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\" && browserCrypto.createDecipheriv) {\n      const decipher = browserCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (!browserCrypto.createHmac) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = browserCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n\nexport { decrypt, derive, derivePadded, deriveUnpadded, encrypt, generatePrivate, getPublic, getPublicCompressed, sign, verify };\n", "import { microSeconds as microSeconds$1 } from '../util.js';\n\nconst microSeconds = microSeconds$1;\nconst type = 'simulate';\nconst SIMULATE_CHANNELS = new Set();\nconst SIMULATE_DELAY_TIME = 5;\nfunction create(channelName) {\n  const state = {\n    time: microSeconds$1(),\n    name: channelName,\n    messagesCallback: null\n  };\n  SIMULATE_CHANNELS.add(state);\n  return state;\n}\nfunction close(channelState) {\n  SIMULATE_CHANNELS.delete(channelState);\n}\nfunction postMessage(channelState, messageJson) {\n  return new Promise(res => setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS);\n    channelArray.forEach(channel => {\n      if (channel.name === channelState.name &&\n      // has same name\n      channel !== channelState &&\n      // not own channel\n      !!channel.messagesCallback &&\n      // has subscribers\n      channel.time < messageJson.time // channel not created after postMessage() call\n      ) {\n        channel.messagesCallback(messageJson);\n      }\n    });\n    res();\n  }, SIMULATE_DELAY_TIME));\n}\nfunction onMessage(channelState, fn) {\n  channelState.messagesCallback = fn;\n}\nfunction canBeUsed() {\n  return true;\n}\nfunction averageResponseTime() {\n  return SIMULATE_DELAY_TIME;\n}\n\nexport { SIMULATE_DELAY_TIME, averageResponseTime, canBeUsed, close, create, microSeconds, onMessage, postMessage, type };\n", "import * as native from './methods/native.js';\nimport * as indexedDb from './methods/indexed-db.js';\nimport * as localstorage from './methods/localstorage.js';\nimport * as server from './methods/server.js';\nimport * as simulate from './methods/simulate.js';\n\n// order is important\nconst METHODS = [native,\n// fastest\nindexedDb, localstorage, server];\nfunction chooseMethod(options) {\n  let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);\n\n  // directly chosen\n  if (options.type) {\n    if (options.type === 'simulate') {\n      // only use simulate-method if directly chosen\n      return simulate;\n    }\n    const ret = chooseMethods.find(m => m.type === options.type);\n    if (!ret) throw new Error('method-type ' + options.type + ' not found');else return ret;\n  }\n\n  /**\n   * if no webworker support is needed,\n   * remove idb from the list so that localstorage is been chosen\n   */\n  if (!options.webWorkerSupport) {\n    chooseMethods = chooseMethods.filter(m => m.type !== 'idb');\n  }\n  const useMethod = chooseMethods.find(method => method.canBeUsed(options));\n  if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map(m => m.type))}`);else return useMethod;\n}\n\nexport { chooseMethod };\n", "import { PROMISE_RESOLVED_VOID, isPromise } from './util.js';\nimport { chooseMethod } from './method-chooser.js';\nimport { fillOptionsWithDefaults } from './options.js';\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nconst OPEN_BROADCAST_CHANNELS = new Set();\nlet lastId = 0;\nconst BroadcastChannel = function (name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n  this.options = fillOptionsWithDefaults(options);\n  this.method = chooseMethod(this.options);\n\n  // isListening\n  this._iL = false;\n\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n  this._onML = null;\n\n  /**\n   * _addEventListeners\n   */\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n  this._uMP = new Set();\n\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n  this._befC = [];\n\n  /**\n   * _preparePromise\n   */\n  this._prepP = null;\n  _prepareChannel(this);\n};\n\n// STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\nBroadcastChannel._pubkey = true;\n\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\nlet ENFORCED_OPTIONS;\nfunction enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n}\n\n// PROTOTYPE\nBroadcastChannel.prototype = {\n  postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n    return _post(this, 'message', msg);\n  },\n  postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n  set onmessage(fn) {\n    const time = this.method.microSeconds();\n    const listenObj = {\n      time,\n      fn\n    };\n    _removeListenerObject(this, 'message', this._onML);\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n  addEventListener(type, fn) {\n    const time = this.method.microSeconds();\n    const listenObj = {\n      time,\n      fn\n    };\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener(type, fn) {\n    const obj = this._addEL[type].find(obj => obj.fn === fn);\n    _removeListenerObject(this, type, obj);\n  },\n  close() {\n    if (this.closed) {\n      return;\n    }\n    OPEN_BROADCAST_CHANNELS.delete(this);\n    this.closed = true;\n    const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare\n    // wait until all current sending are processed\n    .then(() => Promise.all(Array.from(this._uMP)))\n    // run before-close hooks\n    .then(() => Promise.all(this._befC.map(fn => fn())))\n    // close the channel\n    .then(() => this.method.close(this._state));\n  },\n  get type() {\n    return this.method.type;\n  },\n  get isClosed() {\n    return this.closed;\n  }\n};\n\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\nfunction _post(broadcastChannel, type, msg) {\n  const time = broadcastChannel.method.microSeconds();\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  };\n  const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(() => {\n    const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);\n\n    // add/remove to unsend messages list\n    broadcastChannel._uMP.add(sendPromise);\n    sendPromise.catch().then(() => broadcastChannel._uMP.delete(sendPromise));\n    return sendPromise;\n  });\n}\nfunction _prepareChannel(channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options);\n  if (isPromise(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(s => {\n      // used in tests to simulate slow runtime\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n  _startListening(channel);\n}\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(o => o !== obj);\n  _stopListening(channel);\n}\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEL[msgObj.type].forEach(listenerObject => {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        // const hundredMsInMicro = 100 * 1000;\n        // const minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= listenerObject.time) {\n          listenerObject.fn(msgObj.data);\n        } else if (channel.method.type === 'server') {\n          // server msg might lag based on connection.\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n    const time = channel.method.microSeconds();\n    if (channel._prepP) {\n      channel._prepP.then(() => {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    const time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}\n\nexport { BroadcastChannel, OPEN_BROADCAST_CHANNELS, enforceOptions };\n"],
  "mappings": "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",
  "names": ["microSeconds", "loglevel", "microSeconds", "averageResponseTime", "canBeUsed", "close", "create", "microSeconds", "onMessage", "postMessage", "type", "microSeconds", "type", "create", "close", "postMessage", "onMessage", "canBeUsed", "averageResponseTime", "averageResponseTime", "canBeUsed", "close", "create", "microSeconds", "onMessage", "postMessage", "type", "microSeconds", "type", "postMessage", "create", "canBeUsed", "close", "onMessage", "averageResponseTime", "averageResponseTime", "canBeUsed", "close", "create", "microSeconds", "onMessage", "postMessage", "removeStorageEventListener", "storageKey", "type", "ec$1", "microSeconds", "KEY_PREFIX", "type", "storageKey", "postMessage", "removeStorageEventListener", "create", "close", "onMessage", "canBeUsed", "averageResponseTime", "averageResponseTime", "canBeUsed", "close", "create", "microSeconds", "onMessage", "postMessage", "type", "microSeconds", "type", "create", "close", "postMessage", "onMessage", "canBeUsed", "averageResponseTime", "BroadcastChannel", "type", "obj"]
}
