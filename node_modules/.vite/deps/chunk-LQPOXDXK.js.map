{
  "version": 3,
  "sources": ["../../@toruslabs/torus.js/dist/lib.esm/constants.js", "../../@toruslabs/torus.js/dist/lib.esm/Point.js", "../../@toruslabs/torus.js/dist/lib.esm/Polynomial.js", "../../@toruslabs/torus.js/dist/lib.esm/Share.js", "../../@toruslabs/torus.js/node_modules/@toruslabs/constants/dist/lib.esm/constants.js", "../../@toruslabs/torus.js/dist/lib.esm/torus.js", "../../@toruslabs/torus.js/dist/lib.esm/config.js", "../../@toruslabs/torus.js/dist/lib.esm/loglevel.js", "../../@toruslabs/torus.js/dist/lib.esm/helpers/errorUtils.js", "../../@toruslabs/torus.js/node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js", "../../@toruslabs/torus.js/dist/lib.esm/helpers/nodeUtils.js", "../../@toruslabs/torus.js/dist/lib.esm/some.js", "../../@toruslabs/torus.js/dist/lib.esm/helpers/common.js", "../../@toruslabs/bs58/dist/lib.esm/bs58.js", "../../@toruslabs/torus.js/dist/lib.esm/helpers/keyUtils.js", "../../ethereum-cryptography/esm/sha512.js", "../../@toruslabs/torus.js/dist/lib.esm/helpers/langrangeInterpolatePoly.js", "../../@toruslabs/torus.js/dist/lib.esm/helpers/metadataUtils.js", "../../@toruslabs/torus.js/dist/lib.esm/helpers/tssPubKeyUtils.js"],
  "sourcesContent": ["const JRPC_METHODS = {\n  GET_OR_SET_KEY: \"GetPubKeyOrKeyAssign\",\n  VERIFIER_LOOKUP: \"VerifierLookupRequest\",\n  COMMITMENT_REQUEST: \"CommitmentRequest\",\n  IMPORT_SHARES: \"ImportShares\",\n  GET_SHARE_OR_KEY_ASSIGN: \"GetShareOrKeyAssign\"\n};\nconst SAPPHIRE_METADATA_URL = \"https://node-1.node.web3auth.io/metadata\";\nconst SAPPHIRE_DEVNET_METADATA_URL = \"https://node-1.dev-node.web3auth.io/metadata\";\n\nexport { JRPC_METHODS, SAPPHIRE_DEVNET_METADATA_URL, SAPPHIRE_METADATA_URL };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport BN from 'bn.js';\n\nclass Point {\n  constructor(x, y, ecCurve) {\n    _defineProperty(this, \"x\", void 0);\n    _defineProperty(this, \"y\", void 0);\n    _defineProperty(this, \"ecCurve\", void 0);\n    this.x = new BN(x, \"hex\");\n    this.y = new BN(y, \"hex\");\n    this.ecCurve = ecCurve;\n  }\n  encode(enc) {\n    switch (enc) {\n      case \"arr\":\n        return Buffer.concat([Buffer.from(\"04\", \"hex\"), Buffer.from(this.x.toString(\"hex\", 64), \"hex\"), Buffer.from(this.y.toString(\"hex\", 64), \"hex\")]);\n      case \"elliptic-compressed\":\n        {\n          const key = this.ecCurve.keyFromPublic({\n            x: this.x.toString(\"hex\", 64),\n            y: this.y.toString(\"hex\", 64)\n          }, \"hex\");\n          return Buffer.from(key.getPublic(true, \"hex\"));\n        }\n      default:\n        throw new Error(\"encoding doesn't exist in Point\");\n    }\n  }\n}\n\nexport { Point as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport BN from 'bn.js';\nimport Share from './Share.js';\n\nclass Polynomial {\n  constructor(polynomial, ecCurve) {\n    _defineProperty(this, \"polynomial\", void 0);\n    _defineProperty(this, \"ecCurve\", void 0);\n    this.polynomial = polynomial;\n    this.ecCurve = ecCurve;\n  }\n  getThreshold() {\n    return this.polynomial.length;\n  }\n  polyEval(x) {\n    const tmpX = new BN(x, \"hex\");\n    let xi = new BN(tmpX);\n    let sum = new BN(0);\n    sum = sum.add(this.polynomial[0]);\n    for (let i = 1; i < this.polynomial.length; i += 1) {\n      const tmp = xi.mul(this.polynomial[i]);\n      sum = sum.add(tmp);\n      sum = sum.umod(this.ecCurve.n);\n      xi = xi.mul(new BN(tmpX));\n      xi = xi.umod(this.ecCurve.n);\n    }\n    return sum;\n  }\n  generateShares(shareIndexes) {\n    const newShareIndexes = shareIndexes.map(index => {\n      if (typeof index === \"number\") {\n        return new BN(index);\n      }\n      if (index instanceof BN) {\n        return index;\n      }\n      if (typeof index === \"string\") {\n        return new BN(index, \"hex\");\n      }\n      return index;\n    });\n    const shares = {};\n    for (let x = 0; x < newShareIndexes.length; x += 1) {\n      shares[newShareIndexes[x].toString(\"hex\", 64)] = new Share(newShareIndexes[x], this.polyEval(newShareIndexes[x]));\n    }\n    return shares;\n  }\n}\n\nexport { Polynomial as default };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport BN from 'bn.js';\n\nclass Share {\n  constructor(shareIndex, share) {\n    _defineProperty(this, \"share\", void 0);\n    _defineProperty(this, \"shareIndex\", void 0);\n    this.share = new BN(share, \"hex\");\n    this.shareIndex = new BN(shareIndex, \"hex\");\n  }\n  static fromJSON(value) {\n    const {\n      share,\n      shareIndex\n    } = value;\n    return new Share(shareIndex, share);\n  }\n  toJSON() {\n    return {\n      share: this.share.toString(\"hex\", 64),\n      shareIndex: this.shareIndex.toString(\"hex\", 64)\n    };\n  }\n}\n\nexport { Share as default };\n", "const TORUS_LEGACY_NETWORK = {\n  MAINNET: \"mainnet\",\n  TESTNET: \"testnet\",\n  CYAN: \"cyan\",\n  AQUA: \"aqua\",\n  CELESTE: \"celeste\"\n};\nconst TORUS_SAPPHIRE_NETWORK = {\n  SAPPHIRE_DEVNET: \"sapphire_devnet\",\n  SAPPHIRE_MAINNET: \"sapphire_mainnet\"\n};\nconst PROXY_CONTRACT_ADDRESS = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"0xf20336e16B5182637f09821c27BDe29b0AFcfe80\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"0x9f072ba19b3370e512aa1b4bfcdaf97283168005\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"0x29Dea82a0509153b91040ee13cDBba0f03efb625\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c\"\n};\nconst MULTI_CLUSTER_NETWORKS = [\n  // TORUS_LEGACY_NETWORK.AQUA,\n  // TORUS_LEGACY_NETWORK.CELESTE,\n  // TORUS_LEGACY_NETWORK.CYAN,\n];\nconst LEGACY_NETWORKS_ROUTE_MAP = {\n  [TORUS_LEGACY_NETWORK.AQUA]: {\n    migrationCompleted: true,\n    networkIdentifier: \"aqua\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CELESTE]: {\n    migrationCompleted: true,\n    networkIdentifier: \"celeste\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.CYAN]: {\n    migrationCompleted: true,\n    networkIdentifier: \"cyan\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.MAINNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"mainnet\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET\n  },\n  [TORUS_LEGACY_NETWORK.TESTNET]: {\n    migrationCompleted: true,\n    networkIdentifier: \"teal\",\n    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET\n  }\n};\nconst NETWORK_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"mainnet\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"goerli\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"polygon-mainnet\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"polygon-mainnet\"\n};\nconst SIGNER_MAP = {\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: \"https://signer.web3auth.io\",\n  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://signer.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://signer-polygon.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://signer-polygon.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://signer-polygon.web3auth.io\"\n};\nconst METADATA_MAP = {\n  [TORUS_LEGACY_NETWORK.MAINNET]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.TESTNET]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CYAN]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.AQUA]: \"https://metadata.web3auth.io\",\n  [TORUS_LEGACY_NETWORK.CELESTE]: \"https://metadata.web3auth.io\"\n};\nconst FND_SERVER = \"https://fnd.web3auth.io\";\nconst SESSION_SERVER = \"https://session.web3auth.io\";\nconst KEY_TYPE = {\n  SECP256K1: \"secp256k1\",\n  ED25519: \"ed25519\"\n};\n\nexport { FND_SERVER, KEY_TYPE, LEGACY_NETWORKS_ROUTE_MAP, METADATA_MAP, MULTI_CLUSTER_NETWORKS, NETWORK_MAP, PROXY_CONTRACT_ADDRESS, SESSION_SERVER, SIGNER_MAP, TORUS_LEGACY_NETWORK, TORUS_SAPPHIRE_NETWORK };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { KEY_TYPE, LEGACY_NETWORKS_ROUTE_MAP, SIGNER_MAP, METADATA_MAP } from '@toruslabs/constants';\nimport { setAPIKey, setEmbedHost } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport { config } from './config.js';\nimport log from './loglevel.js';\nimport { GetOrSetNonceError } from './helpers/errorUtils.js';\nimport { retrieveOrImportShare, GetPubKeyOrKeyAssign } from './helpers/nodeUtils.js';\nimport { generateShares, getEd25519ExtendedPublicKey, encodeEd25519Point, generateAddressFromPubKey } from './helpers/keyUtils.js';\nimport { getOrSetNonce, getMetadata } from './helpers/metadataUtils.js';\n\n// Implement threshold logic wrappers around public APIs\n// of Torus nodes to handle malicious node responses\nclass Torus {\n  constructor({\n    enableOneKey = false,\n    clientId,\n    network,\n    serverTimeOffset = 0,\n    allowHost,\n    legacyMetadataHost,\n    keyType = KEY_TYPE.SECP256K1\n  }) {\n    // 86400 = 24 hour\n    _defineProperty(this, \"allowHost\", void 0);\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n    _defineProperty(this, \"network\", void 0);\n    _defineProperty(this, \"clientId\", void 0);\n    _defineProperty(this, \"ec\", void 0);\n    _defineProperty(this, \"enableOneKey\", void 0);\n    _defineProperty(this, \"legacyMetadataHost\", void 0);\n    _defineProperty(this, \"keyType\", KEY_TYPE.SECP256K1);\n    if (!clientId) throw new Error(\"Please provide a valid clientId in constructor\");\n    if (!network) throw new Error(\"Please provide a valid network in constructor\");\n    if (keyType === KEY_TYPE.ED25519 && LEGACY_NETWORKS_ROUTE_MAP[network]) {\n      throw new Error(`keyType: ${keyType} is not supported by ${network} network`);\n    }\n    this.keyType = keyType;\n    this.ec = new ec(this.keyType);\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n    this.network = network;\n    this.clientId = clientId;\n    this.allowHost = allowHost || `${SIGNER_MAP[network]}/api/allow`;\n    this.enableOneKey = enableOneKey;\n    this.legacyMetadataHost = legacyMetadataHost || METADATA_MAP[network];\n  }\n  static enableLogging(v = true) {\n    if (v) {\n      log.enableAll();\n      config.logRequestTracing = true;\n    } else log.disableAll();\n  }\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n  static setSessionTime(sessionTime) {\n    Torus.sessionTime = sessionTime;\n  }\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError;\n  }\n  static getPostboxKey(torusKey) {\n    if (torusKey.metadata.typeOfUser === \"v1\") {\n      return torusKey.finalKeyData.privKey || torusKey.postboxKeyData.privKey;\n    }\n    return torusKey.postboxKeyData.privKey;\n  }\n  async retrieveShares(params) {\n    const {\n      verifier,\n      verifierParams,\n      idToken,\n      nodePubkeys,\n      indexes,\n      endpoints,\n      useDkg,\n      extraParams = {},\n      checkCommitment = true\n    } = params;\n    if (nodePubkeys.length === 0) {\n      throw new Error(\"nodePubkeys param is required\");\n    }\n    if (nodePubkeys.length !== indexes.length) {\n      throw new Error(\"nodePubkeys length must be same as indexes length\");\n    }\n    if (nodePubkeys.length !== endpoints.length) {\n      throw new Error(\"nodePubkeys length must be same as endpoints length\");\n    }\n    // dkg is used by default only for secp256k1 keys,\n    // for ed25519 keys import keys flows is the default\n    let shouldUseDkg;\n    if (typeof useDkg === \"boolean\") {\n      if (useDkg === false && LEGACY_NETWORKS_ROUTE_MAP[this.network]) {\n        throw new Error(`useDkg cannot be false for legacy network; ${this.network}`);\n      }\n      shouldUseDkg = this.keyType === KEY_TYPE.ED25519 ? false : useDkg;\n    } else if (this.keyType === KEY_TYPE.ED25519) {\n      shouldUseDkg = false;\n    } else {\n      shouldUseDkg = true;\n    }\n    if (!shouldUseDkg && nodePubkeys.length === 0) {\n      throw new Error(\"nodePubkeys param is required\");\n    }\n    if (!extraParams.session_token_exp_second) {\n      extraParams.session_token_exp_second = Torus.sessionTime;\n    }\n    return retrieveOrImportShare({\n      legacyMetadataHost: this.legacyMetadataHost,\n      serverTimeOffset: this.serverTimeOffset,\n      enableOneKey: this.enableOneKey,\n      ecCurve: this.ec,\n      keyType: this.keyType,\n      allowHost: this.allowHost,\n      network: this.network,\n      clientId: this.clientId,\n      endpoints,\n      indexes,\n      verifier,\n      verifierParams,\n      idToken,\n      useDkg: shouldUseDkg,\n      newImportedShares: [],\n      overrideExistingKey: false,\n      nodePubkeys,\n      extraParams,\n      checkCommitment\n    });\n  }\n  async getPublicAddress(endpoints, torusNodePubs, {\n    verifier,\n    verifierId,\n    extendedVerifierId\n  }) {\n    log.info(torusNodePubs, {\n      verifier,\n      verifierId,\n      extendedVerifierId\n    });\n    return this.getNewPublicAddress(endpoints, {\n      verifier,\n      verifierId,\n      extendedVerifierId\n    }, this.enableOneKey);\n  }\n  async importPrivateKey(params) {\n    const {\n      nodeIndexes,\n      newPrivateKey,\n      verifier,\n      verifierParams,\n      idToken,\n      nodePubkeys,\n      endpoints,\n      extraParams = {},\n      checkCommitment = true\n    } = params;\n    if (LEGACY_NETWORKS_ROUTE_MAP[this.network]) {\n      throw new Error(`importPrivateKey is not supported by legacy network; ${this.network}`);\n    }\n    if (endpoints.length !== nodeIndexes.length) {\n      throw new Error(`length of endpoints array must be same as length of nodeIndexes array`);\n    }\n    if (!extraParams.session_token_exp_second) {\n      extraParams.session_token_exp_second = Torus.sessionTime;\n    }\n    let privKeyBuffer;\n    if (this.keyType === KEY_TYPE.SECP256K1) {\n      privKeyBuffer = Buffer.from(newPrivateKey.padStart(64, \"0\"), \"hex\");\n      if (privKeyBuffer.length !== 32) {\n        throw new Error(\"Invalid private key length for given secp256k1 key\");\n      }\n    }\n    if (this.keyType === KEY_TYPE.ED25519) {\n      privKeyBuffer = Buffer.from(newPrivateKey.padStart(64, \"0\"), \"hex\");\n      if (privKeyBuffer.length !== 32) {\n        throw new Error(\"Invalid private key length for given ed25519 key\");\n      }\n    }\n    const sharesData = await generateShares(this.ec, this.keyType, this.serverTimeOffset, nodeIndexes, nodePubkeys, privKeyBuffer);\n    if (this.keyType === KEY_TYPE.ED25519) {\n      const ed25519Key = getEd25519ExtendedPublicKey(privKeyBuffer);\n      const ed25519PubKey = encodeEd25519Point(ed25519Key.point);\n      const encodedPubKey = encodeEd25519Point(sharesData[0].final_user_point);\n      const importedPubKey = Buffer.from(ed25519PubKey).toString(\"hex\");\n      const derivedPubKey = encodedPubKey.toString(\"hex\");\n      if (importedPubKey !== derivedPubKey) {\n        throw new Error(\"invalid shares data for ed25519 key, public key is not matching after generating shares\");\n      }\n    }\n    return retrieveOrImportShare({\n      legacyMetadataHost: this.legacyMetadataHost,\n      serverTimeOffset: this.serverTimeOffset,\n      enableOneKey: this.enableOneKey,\n      ecCurve: this.ec,\n      keyType: this.keyType,\n      allowHost: this.allowHost,\n      network: this.network,\n      clientId: this.clientId,\n      endpoints,\n      indexes: nodeIndexes,\n      verifier,\n      verifierParams,\n      idToken,\n      useDkg: false,\n      overrideExistingKey: true,\n      newImportedShares: sharesData,\n      nodePubkeys,\n      extraParams,\n      checkCommitment\n    });\n  }\n\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   * this is a legacy function, use getPublicAddress instead for new networks\n   */\n  async getUserTypeAndAddress(endpoints, {\n    verifier,\n    verifierId,\n    extendedVerifierId\n  }) {\n    return this.getNewPublicAddress(endpoints, {\n      verifier,\n      verifierId,\n      extendedVerifierId\n    }, true);\n  }\n  async getNewPublicAddress(endpoints, {\n    verifier,\n    verifierId,\n    extendedVerifierId\n  }, enableOneKey) {\n    const keyAssignResult = await GetPubKeyOrKeyAssign({\n      endpoints,\n      network: this.network,\n      verifier,\n      verifierId,\n      keyType: this.keyType,\n      extendedVerifierId\n    });\n    const {\n      errorResult,\n      keyResult,\n      nodeIndexes = [],\n      serverTimeOffset\n    } = keyAssignResult;\n    const finalServerTimeOffset = this.serverTimeOffset || serverTimeOffset;\n    const {\n      nonceResult\n    } = keyAssignResult;\n    if (errorResult && JSON.stringify(errorResult).toLowerCase().includes(\"verifier not supported\")) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`);\n    }\n    if (errorResult) {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n    if (!(keyResult !== null && keyResult !== void 0 && keyResult.keys)) {\n      throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`);\n    }\n\n    // no need of nonce for extendedVerifierId (tss verifier id)\n    if (!nonceResult && !extendedVerifierId && !LEGACY_NETWORKS_ROUTE_MAP[this.network]) {\n      throw new GetOrSetNonceError(\"metadata nonce is missing in share response\");\n    }\n    const {\n      pub_key_X: X,\n      pub_key_Y: Y\n    } = keyResult.keys[0];\n    let pubNonce;\n    const nonce = new BN((nonceResult === null || nonceResult === void 0 ? void 0 : nonceResult.nonce) || \"0\", 16);\n    let oAuthPubKey;\n    let finalPubKey;\n    if (extendedVerifierId) {\n      // for tss key no need to add pub nonce\n      finalPubKey = this.ec.keyFromPublic({\n        x: X,\n        y: Y\n      }).getPublic();\n      oAuthPubKey = finalPubKey;\n    } else if (LEGACY_NETWORKS_ROUTE_MAP[this.network]) {\n      return this.formatLegacyPublicKeyData({\n        isNewKey: keyResult.is_new_key,\n        enableOneKey,\n        finalKeyResult: {\n          keys: keyResult.keys\n        },\n        serverTimeOffset: finalServerTimeOffset\n      });\n    } else {\n      const v2NonceResult = nonceResult;\n      oAuthPubKey = this.ec.keyFromPublic({\n        x: X,\n        y: Y\n      }).getPublic();\n      finalPubKey = this.ec.keyFromPublic({\n        x: X,\n        y: Y\n      }).getPublic().add(this.ec.keyFromPublic({\n        x: v2NonceResult.pubNonce.x,\n        y: v2NonceResult.pubNonce.y\n      }).getPublic());\n      pubNonce = {\n        X: v2NonceResult.pubNonce.x,\n        Y: v2NonceResult.pubNonce.y\n      };\n    }\n    if (!oAuthPubKey) {\n      throw new Error(\"Unable to derive oAuthPubKey\");\n    }\n    const oAuthX = oAuthPubKey.getX().toString(16, 64);\n    const oAuthY = oAuthPubKey.getY().toString(16, 64);\n    const oAuthAddress = generateAddressFromPubKey(this.keyType, oAuthPubKey.getX(), oAuthPubKey.getY());\n    if (!finalPubKey) {\n      throw new Error(\"Unable to derive finalPubKey\");\n    }\n    const finalX = finalPubKey ? finalPubKey.getX().toString(16, 64) : \"\";\n    const finalY = finalPubKey ? finalPubKey.getY().toString(16, 64) : \"\";\n    const finalAddress = finalPubKey ? generateAddressFromPubKey(this.keyType, finalPubKey.getX(), finalPubKey.getY()) : \"\";\n    return {\n      oAuthKeyData: {\n        walletAddress: oAuthAddress,\n        X: oAuthX,\n        Y: oAuthY\n      },\n      finalKeyData: {\n        walletAddress: finalAddress,\n        X: finalX,\n        Y: finalY\n      },\n      metadata: {\n        pubNonce,\n        nonce,\n        upgraded: (nonceResult === null || nonceResult === void 0 ? void 0 : nonceResult.upgraded) || false,\n        typeOfUser: \"v2\",\n        serverTimeOffset: finalServerTimeOffset\n      },\n      nodesData: {\n        nodeIndexes\n      }\n    };\n  }\n  async formatLegacyPublicKeyData(params) {\n    var _nonceResult;\n    const {\n      finalKeyResult,\n      enableOneKey,\n      isNewKey,\n      serverTimeOffset\n    } = params;\n    const {\n      pub_key_X: X,\n      pub_key_Y: Y\n    } = finalKeyResult.keys[0];\n    let nonceResult;\n    let nonce;\n    let finalPubKey;\n    let typeOfUser;\n    let pubNonce;\n    const oAuthPubKey = this.ec.keyFromPublic({\n      x: X,\n      y: Y\n    }).getPublic();\n    const finalServerTimeOffset = this.serverTimeOffset || serverTimeOffset;\n    if (enableOneKey) {\n      try {\n        nonceResult = await getOrSetNonce(this.legacyMetadataHost, this.ec, finalServerTimeOffset, X, Y, undefined, !isNewKey);\n        nonce = new BN(nonceResult.nonce || \"0\", 16);\n        typeOfUser = nonceResult.typeOfUser;\n      } catch {\n        throw new GetOrSetNonceError();\n      }\n      if (nonceResult.typeOfUser === \"v1\") {\n        nonce = await getMetadata(this.legacyMetadataHost, {\n          pub_key_X: X,\n          pub_key_Y: Y\n        });\n        finalPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16, 64), \"hex\").getPublic());\n      } else if (nonceResult.typeOfUser === \"v2\") {\n        finalPubKey = this.ec.keyFromPublic({\n          x: X,\n          y: Y\n        }).getPublic().add(this.ec.keyFromPublic({\n          x: nonceResult.pubNonce.x,\n          y: nonceResult.pubNonce.y\n        }).getPublic());\n        pubNonce = {\n          X: nonceResult.pubNonce.x,\n          Y: nonceResult.pubNonce.y\n        };\n      } else {\n        throw new Error(\"getOrSetNonce should always return typeOfUser.\");\n      }\n    } else {\n      typeOfUser = \"v1\";\n      nonce = await getMetadata(this.legacyMetadataHost, {\n        pub_key_X: X,\n        pub_key_Y: Y\n      });\n      finalPubKey = this.ec.keyFromPublic({\n        x: X,\n        y: Y\n      }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16, 64), \"hex\").getPublic());\n    }\n    if (!oAuthPubKey) {\n      throw new Error(\"Unable to derive oAuthPubKey\");\n    }\n    const oAuthX = oAuthPubKey.getX().toString(16, 64);\n    const oAuthY = oAuthPubKey.getY().toString(16, 64);\n    const oAuthAddress = generateAddressFromPubKey(this.keyType, oAuthPubKey.getX(), oAuthPubKey.getY());\n    if (typeOfUser === \"v2\" && !finalPubKey) {\n      throw new Error(\"Unable to derive finalPubKey\");\n    }\n    const finalX = finalPubKey ? finalPubKey.getX().toString(16, 64) : \"\";\n    const finalY = finalPubKey ? finalPubKey.getY().toString(16, 64) : \"\";\n    const finalAddress = finalPubKey ? generateAddressFromPubKey(this.keyType, finalPubKey.getX(), finalPubKey.getY()) : \"\";\n    return {\n      oAuthKeyData: {\n        walletAddress: oAuthAddress,\n        X: oAuthX,\n        Y: oAuthY\n      },\n      finalKeyData: {\n        walletAddress: finalAddress,\n        X: finalX,\n        Y: finalY\n      },\n      metadata: {\n        pubNonce,\n        nonce,\n        upgraded: ((_nonceResult = nonceResult) === null || _nonceResult === void 0 ? void 0 : _nonceResult.upgraded) || false,\n        typeOfUser,\n        serverTimeOffset: finalServerTimeOffset\n      },\n      nodesData: {\n        nodeIndexes: []\n      }\n    };\n  }\n}\n_defineProperty(Torus, \"sessionTime\", 86400);\n\nexport { Torus as default };\n", "const config = {\n  logRequestTracing: false\n};\n\nexport { config };\n", "import log$1 from 'loglevel';\n\nconst log = log$1.getLogger(\"torus.js\");\nlog.disableAll();\n\nexport { log as default };\n", "class GetOrSetNonceError extends Error {}\n\nexport { GetOrSetNonceError };\n", "import { ec as ec$1 } from 'elliptic';\n\nconst ec = new ec$1(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, n/no-unsupported-features/node-builtins\nconst browserCrypto = globalThis.crypto || globalThis.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(browserCrypto.randomBytes(size));\n  }\n  const arr = new Uint8Array(size);\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (!browserCrypto.createHash) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = browserCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle && subtle[op] && subtle.importKey) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      // encrypt and decrypt ops are not implemented in react-native-quick-crypto yet.\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\" && browserCrypto.createCipheriv) {\n      // This is available if crypto is polyfilled in react native environment\n      const cipher = browserCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\" && browserCrypto.createDecipheriv) {\n      const decipher = browserCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (!browserCrypto.createHmac) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = browserCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n\nexport { decrypt, derive, derivePadded, deriveUnpadded, encrypt, generatePrivate, getPublic, getPublicCompressed, sign, verify };\n", "import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport { KEY_TYPE, LEGACY_NETWORKS_ROUTE_MAP } from '@toruslabs/constants';\nimport { generatePrivate, getPublic } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, get } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { getRandomBytes } from 'ethereum-cryptography/random';\nimport { config } from '../config.js';\nimport { JRPC_METHODS } from '../constants.js';\nimport log from '../loglevel.js';\nimport { Some } from '../some.js';\nimport { generatePrivateKey, thresholdSame, getProxyCoordinatorEndpointIndex, normalizeKeysResult, calculateMedian, normalizeLookUpResult, keccak256, retryCommitment, kCombinations } from './common.js';\nimport { generateShares, derivePubKey, generateAddressFromPrivKey, generateAddressFromPubKey } from './keyUtils.js';\nimport { lagrangeInterpolation } from './langrangeInterpolatePoly.js';\nimport { getOrSetSapphireMetadataNonce, getOrSetNonce, getMetadata, decryptSeedData, getSecpKeyFromEd25519, decryptNodeData, decryptNodeDataWithPadding } from './metadataUtils.js';\n\nconst GetPubKeyOrKeyAssign = async params => {\n  const {\n    endpoints,\n    network,\n    verifier,\n    verifierId,\n    extendedVerifierId,\n    keyType\n  } = params;\n  const minThreshold = ~~(endpoints.length / 2) + 1;\n  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(JRPC_METHODS.GET_OR_SET_KEY, {\n    distributed_metadata: true,\n    verifier,\n    verifier_id: verifierId.toString(),\n    extended_verifier_id: extendedVerifierId,\n    one_key_flow: true,\n    key_type: keyType,\n    fetch_node_index: true,\n    client_time: Math.floor(Date.now() / 1000).toString()\n  }), {}, {\n    logTracingHeader: config.logRequestTracing\n  }).catch(err => log.error(`${JRPC_METHODS.GET_OR_SET_KEY} request failed`, err)));\n  let nonceResult;\n  const nodeIndexes = [];\n  const result = await Some(lookupPromises, async lookupResults => {\n    const lookupPubKeys = lookupResults.filter(x1 => {\n      if (x1 && !x1.error) {\n        return x1;\n      }\n      return false;\n    });\n    const errorResult = thresholdSame(lookupResults.map(x2 => x2 && x2.error), minThreshold);\n    const keyResult = thresholdSame(lookupPubKeys.map(x3 => x3 && normalizeKeysResult(x3.result)), minThreshold);\n\n    // check for nonce result in response if not a extendedVerifierId and not a legacy network\n    if (keyResult && !nonceResult && !extendedVerifierId && !LEGACY_NETWORKS_ROUTE_MAP[network]) {\n      for (let i = 0; i < lookupResults.length; i++) {\n        const x1 = lookupResults[i];\n        if (x1 && !x1.error) {\n          var _x1$result;\n          const currentNodePubKey = x1.result.keys[0].pub_key_X.toLowerCase();\n          const thresholdPubKey = keyResult.keys[0].pub_key_X.toLowerCase();\n          const pubNonceX = (_x1$result = x1.result) === null || _x1$result === void 0 || (_x1$result = _x1$result.keys[0].nonce_data) === null || _x1$result === void 0 || (_x1$result = _x1$result.pubNonce) === null || _x1$result === void 0 ? void 0 : _x1$result.x;\n          if (pubNonceX && currentNodePubKey === thresholdPubKey) {\n            nonceResult = x1.result.keys[0].nonce_data;\n            break;\n          }\n        }\n      }\n\n      // if nonce result is not returned by nodes, fetch directly from metadata\n      if (!nonceResult) {\n        const metadataNonceResult = await getOrSetSapphireMetadataNonce(network, keyResult.keys[0].pub_key_X, keyResult.keys[0].pub_key_Y);\n        // rechecking nonceResult to avoid promise race condition.\n        if (!nonceResult && metadataNonceResult) {\n          nonceResult = metadataNonceResult;\n          if (nonceResult.nonce) {\n            delete nonceResult.nonce;\n          }\n        }\n      }\n    }\n    const serverTimeOffsets = [];\n    // nonceResult must exist except for extendedVerifierId and legacy networks along with keyResult\n    if (keyResult && (nonceResult || extendedVerifierId || LEGACY_NETWORKS_ROUTE_MAP[network]) || errorResult) {\n      if (keyResult) {\n        lookupResults.forEach(x1 => {\n          if (x1 && x1.result) {\n            const currentNodePubKey = x1.result.keys[0].pub_key_X.toLowerCase();\n            const thresholdPubKey = keyResult.keys[0].pub_key_X.toLowerCase();\n            // push only those indexes for nodes who are returning pub key matching with threshold pub key.\n            // this check is important when different nodes have different keys assigned to a user.\n            if (currentNodePubKey === thresholdPubKey) {\n              const nodeIndex = Number.parseInt(x1.result.node_index);\n              if (nodeIndex) nodeIndexes.push(nodeIndex);\n            }\n            const serverTimeOffset = x1.result.server_time_offset ? Number.parseInt(x1.result.server_time_offset, 10) : 0;\n            serverTimeOffsets.push(serverTimeOffset);\n          }\n        });\n      }\n      const serverTimeOffset = keyResult ? calculateMedian(serverTimeOffsets) : 0;\n      return Promise.resolve({\n        keyResult,\n        serverTimeOffset,\n        nodeIndexes,\n        errorResult,\n        nonceResult\n      });\n    }\n    return Promise.reject(new Error(`invalid public key result: ${JSON.stringify(lookupResults)} and nonce result:${JSON.stringify(nonceResult || {})} for verifier: ${verifier}, verifierId: ${verifierId} and extendedVerifierId: ${extendedVerifierId} `));\n  });\n  return result;\n};\nconst VerifierLookupRequest = async params => {\n  const {\n    endpoints,\n    verifier,\n    verifierId,\n    keyType\n  } = params;\n  const minThreshold = ~~(endpoints.length / 2) + 1;\n  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(JRPC_METHODS.VERIFIER_LOOKUP, {\n    verifier,\n    verifier_id: verifierId.toString(),\n    key_type: keyType,\n    client_time: Math.floor(Date.now() / 1000).toString()\n  }), {}, {\n    logTracingHeader: config.logRequestTracing\n  }).catch(err => log.error(`${JRPC_METHODS.GET_OR_SET_KEY} request failed`, err)));\n  const result = await Some(lookupPromises, async lookupResults => {\n    const lookupPubKeys = lookupResults.filter(x1 => {\n      if (x1 && !x1.error) {\n        return x1;\n      }\n      return false;\n    });\n    const errorResult = thresholdSame(lookupResults.map(x2 => x2 && x2.error), minThreshold);\n    const keyResult = thresholdSame(lookupPubKeys.map(x3 => x3 && normalizeLookUpResult(x3.result)), minThreshold);\n    const serverTimeOffsets = [];\n    if (keyResult || errorResult) {\n      const serverTimeOffset = keyResult ? calculateMedian(serverTimeOffsets) : 0;\n      return Promise.resolve({\n        keyResult,\n        serverTimeOffset,\n        errorResult\n      });\n    }\n    return Promise.reject(new Error(`invalid lookup result: ${JSON.stringify(lookupResults)}\n        )} for verifier: ${verifier}, verifierId: ${verifierId}`));\n  });\n  return result;\n};\nconst commitmentRequest = async params => {\n  const {\n    idToken,\n    endpoints,\n    indexes,\n    keyType,\n    verifier,\n    verifierParams,\n    pubKeyX,\n    pubKeyY,\n    finalImportedShares,\n    overrideExistingKey\n  } = params;\n  const tokenCommitment = keccak256(Buffer.from(idToken, \"utf8\"));\n  const threeFourthsThreshold = ~~(endpoints.length * 3 / 4) + 1;\n  const halfThreshold = ~~(endpoints.length / 2) + 1;\n  const promiseArr = [];\n  // make commitment requests to endpoints\n  for (let i = 0; i < endpoints.length; i += 1) {\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      } \n      */\n    const p = () => post(endpoints[i], generateJsonRPCObject(JRPC_METHODS.COMMITMENT_REQUEST, {\n      messageprefix: \"mug00\",\n      keytype: keyType,\n      tokencommitment: tokenCommitment.slice(2),\n      temppubx: pubKeyX,\n      temppuby: pubKeyY,\n      verifieridentifier: verifier,\n      verifier_id: verifierParams.verifier_id,\n      extended_verifier_id: verifierParams.extended_verifier_id,\n      is_import_key_flow: true\n    }), {}, {\n      logTracingHeader: config.logRequestTracing\n    });\n    const r = retryCommitment(p, 4);\n    promiseArr.push(r);\n  }\n  return new Promise((resolve, reject) => {\n    // send share request once k + t number of commitment requests have completed\n    Some(promiseArr, resultArr => {\n      const completedRequests = resultArr.filter(x => {\n        if (!x || typeof x !== \"object\") {\n          return false;\n        }\n        if (x.error) {\n          return false;\n        }\n        return true;\n      });\n      if (finalImportedShares.length > 0) {\n        // this is a optimization is for imported keys\n        // for new imported keys registration we need to wait for all nodes to agree on commitment\n        // for fetching existing imported keys we can rely on threshold nodes commitment\n        if (overrideExistingKey && completedRequests.length === endpoints.length) {\n          const requiredNodeResult = completedRequests.find(resp => {\n            if (resp) {\n              return true;\n            }\n            return false;\n          });\n          if (requiredNodeResult) {\n            return Promise.resolve(resultArr);\n          }\n        } else if (!overrideExistingKey && completedRequests.length >= threeFourthsThreshold) {\n          const nodeSigs = [];\n          for (let i = 0; i < completedRequests.length; i += 1) {\n            const x = completedRequests[i];\n            if (!x || typeof x !== \"object\" || x.error) {\n              continue;\n            }\n            if (x) nodeSigs.push(x.result);\n          }\n          const existingPubKey = thresholdSame(nodeSigs.map(x => x && x.pub_key_x), halfThreshold);\n          const proxyEndpointNum = getProxyCoordinatorEndpointIndex(endpoints, verifier, verifierParams.verifier_id);\n          // for import shares, proxy node response is required.\n          // proxy node returns metadata.\n          // if user's account already\n          const requiredNodeIndex = indexes[proxyEndpointNum].toString(10);\n\n          // if not a existing key we need to wait for nodes to agree on commitment\n          if (existingPubKey || !existingPubKey && completedRequests.length === endpoints.length) {\n            const requiredNodeResult = completedRequests.find(resp => {\n              var _resp$result;\n              if (resp && ((_resp$result = resp.result) === null || _resp$result === void 0 ? void 0 : _resp$result.nodeindex) === requiredNodeIndex) {\n                return true;\n              }\n              return false;\n            });\n            if (requiredNodeResult) {\n              return Promise.resolve(resultArr);\n            }\n          }\n        }\n      } else if (completedRequests.length >= threeFourthsThreshold) {\n        // this case is for dkg keys\n        const requiredNodeResult = completedRequests.find(resp => {\n          if (resp) {\n            return true;\n          }\n          return false;\n        });\n        if (requiredNodeResult) {\n          return Promise.resolve(resultArr);\n        }\n      }\n      return Promise.reject(new Error(`invalid commitment results ${JSON.stringify(resultArr)}`));\n    }).then(resultArr => {\n      return resolve(resultArr);\n    }).catch(reject);\n  });\n};\nasync function retrieveOrImportShare(params) {\n  const {\n    legacyMetadataHost,\n    enableOneKey,\n    ecCurve,\n    keyType,\n    allowHost,\n    network,\n    clientId,\n    endpoints,\n    nodePubkeys,\n    indexes,\n    verifier,\n    verifierParams,\n    idToken,\n    overrideExistingKey,\n    newImportedShares,\n    extraParams,\n    useDkg = true,\n    serverTimeOffset,\n    checkCommitment = true\n  } = params;\n  await get(allowHost, {\n    headers: {\n      verifier,\n      verifierid: verifierParams.verifier_id,\n      network,\n      clientid: clientId,\n      enablegating: \"true\"\n    }\n  }, {\n    useAPIKey: true\n  });\n\n  // generate temporary private and public key that is used to secure receive shares\n  const sessionAuthKey = generatePrivate();\n  const pubKey = getPublic(sessionAuthKey).toString(\"hex\");\n  const sessionPubX = pubKey.slice(2, 66);\n  const sessionPubY = pubKey.slice(66);\n  let finalImportedShares = [];\n  const halfThreshold = ~~(endpoints.length / 2) + 1;\n  if ((newImportedShares === null || newImportedShares === void 0 ? void 0 : newImportedShares.length) > 0) {\n    if (newImportedShares.length !== endpoints.length) {\n      throw new Error(\"Invalid imported shares length\");\n    }\n    finalImportedShares = newImportedShares;\n  } else if (!useDkg) {\n    const bufferKey = keyType === KEY_TYPE.SECP256K1 ? generatePrivateKey(ecCurve, Buffer) : await getRandomBytes(32);\n    const generatedShares = await generateShares(ecCurve, keyType, serverTimeOffset, indexes, nodePubkeys, Buffer.from(bufferKey));\n    finalImportedShares = [...finalImportedShares, ...generatedShares];\n  }\n  let commitmentRequestResult = [];\n  let isExistingKey;\n  const nodeSigs = [];\n  if (checkCommitment) {\n    commitmentRequestResult = await commitmentRequest({\n      idToken,\n      endpoints,\n      indexes,\n      keyType,\n      verifier,\n      verifierParams,\n      pubKeyX: sessionPubX,\n      pubKeyY: sessionPubY,\n      finalImportedShares,\n      overrideExistingKey\n    });\n    for (let i = 0; i < commitmentRequestResult.length; i += 1) {\n      const x = commitmentRequestResult[i];\n      if (!x || typeof x !== \"object\" || x.error) {\n        continue;\n      }\n      if (x) nodeSigs.push(x.result);\n    }\n    // if user's account already\n    isExistingKey = !!thresholdSame(nodeSigs.map(x => x && x.pub_key_x), halfThreshold);\n  } else if (!checkCommitment && finalImportedShares.length > 0) {\n    // in case not allowed to override existing key for import request\n    // check if key exists\n    if (!overrideExistingKey) {\n      var _keyLookupResult$erro, _keyLookupResult$keyR;\n      const keyLookupResult = await VerifierLookupRequest({\n        endpoints,\n        verifier,\n        verifierId: verifierParams.verifier_id,\n        keyType\n      });\n      if (keyLookupResult.errorResult && !((_keyLookupResult$erro = keyLookupResult.errorResult) !== null && _keyLookupResult$erro !== void 0 && (_keyLookupResult$erro = _keyLookupResult$erro.data) !== null && _keyLookupResult$erro !== void 0 && _keyLookupResult$erro.includes(\"Verifier + VerifierID has not yet been assigned\"))) {\n        throw new Error(`node results do not match at first lookup ${JSON.stringify(keyLookupResult.keyResult || {})}, ${JSON.stringify(keyLookupResult.errorResult || {})}`);\n      }\n      if (((_keyLookupResult$keyR = keyLookupResult.keyResult) === null || _keyLookupResult$keyR === void 0 || (_keyLookupResult$keyR = _keyLookupResult$keyR.keys) === null || _keyLookupResult$keyR === void 0 ? void 0 : _keyLookupResult$keyR.length) > 0) {\n        isExistingKey = !!keyLookupResult.keyResult.keys[0];\n      }\n    }\n  }\n  const promiseArrRequest = [];\n  const canImportedShares = overrideExistingKey || !useDkg && !isExistingKey;\n  if (canImportedShares) {\n    const proxyEndpointNum = getProxyCoordinatorEndpointIndex(endpoints, verifier, verifierParams.verifier_id);\n    const items = [];\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const importedShare = finalImportedShares[i];\n      if (!importedShare) {\n        throw new Error(`invalid imported share at index ${i}`);\n      }\n      items.push(_objectSpread(_objectSpread({}, verifierParams), {}, {\n        idtoken: idToken,\n        nodesignatures: nodeSigs,\n        verifieridentifier: verifier,\n        pub_key_x: importedShare.oauth_pub_key_x,\n        pub_key_y: importedShare.oauth_pub_key_y,\n        signing_pub_key_x: importedShare.signing_pub_key_x,\n        signing_pub_key_y: importedShare.signing_pub_key_y,\n        encrypted_share: importedShare.encrypted_share,\n        encrypted_share_metadata: importedShare.encrypted_share_metadata,\n        node_index: importedShare.node_index,\n        key_type: importedShare.key_type,\n        nonce_data: importedShare.nonce_data,\n        nonce_signature: importedShare.nonce_signature,\n        sss_endpoint: endpoints[i]\n      }, extraParams));\n    }\n    const p = post(endpoints[proxyEndpointNum], generateJsonRPCObject(JRPC_METHODS.IMPORT_SHARES, {\n      encrypted: \"yes\",\n      use_temp: true,\n      verifieridentifier: verifier,\n      temppubx: nodeSigs.length === 0 && !checkCommitment ? sessionPubX : \"\",\n      // send session pub key x only if node signatures are not available (Ie. in non commitment flow)\n      temppuby: nodeSigs.length === 0 && !checkCommitment ? sessionPubY : \"\",\n      // send session pub key y only if node signatures are not available (Ie. in non commitment flow)\n      item: items,\n      key_type: keyType,\n      one_key_flow: true\n    }), {}, {\n      logTracingHeader: config.logRequestTracing\n    }).catch(err => log.error(\"share req\", err));\n    promiseArrRequest.push(p);\n  } else {\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(endpoints[i], generateJsonRPCObject(JRPC_METHODS.GET_SHARE_OR_KEY_ASSIGN, {\n        encrypted: \"yes\",\n        use_temp: true,\n        key_type: keyType,\n        distributed_metadata: true,\n        verifieridentifier: verifier,\n        temppubx: nodeSigs.length === 0 && !checkCommitment ? sessionPubX : \"\",\n        // send session pub key x only if node signatures are not available (Ie. in non commitment flow)\n        temppuby: nodeSigs.length === 0 && !checkCommitment ? sessionPubY : \"\",\n        // send session pub key y only if node signatures are not available (Ie. in non commitment flow)\n        item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n          idtoken: idToken,\n          key_type: keyType,\n          nodesignatures: nodeSigs,\n          verifieridentifier: verifier\n        }, extraParams)],\n        client_time: Math.floor(Date.now() / 1000).toString(),\n        one_key_flow: true\n      }), {}, {\n        logTracingHeader: config.logRequestTracing\n      });\n      promiseArrRequest.push(p);\n    }\n  }\n  return Some(promiseArrRequest, async (shareResponseResult, sharedState) => {\n    let thresholdNonceData;\n    let shareResponses = [];\n    // for import shares case, where result is an array\n    if (shareResponseResult.length === 1 && shareResponseResult[0] && Array.isArray(shareResponseResult[0].result)) {\n      // this is for import shares\n      const importedSharesResult = shareResponseResult[0];\n      shareResponseResult[0].result.forEach(res => {\n        shareResponses.push({\n          id: importedSharesResult.id,\n          jsonrpc: \"2.0\",\n          result: res,\n          error: importedSharesResult.error\n        });\n      });\n    } else {\n      shareResponses = shareResponseResult;\n    }\n    // check if threshold number of nodes have returned the same user public key\n    const completedRequests = shareResponses.filter(x => {\n      if (!x || typeof x !== \"object\") {\n        return false;\n      }\n      if (x.error) {\n        return false;\n      }\n      return true;\n    });\n    const pubkeys = shareResponses.map(x => {\n      if (x && x.result && x.result.keys[0].public_key) {\n        return x.result.keys[0].public_key;\n      }\n      return undefined;\n    });\n    const thresholdPublicKey = thresholdSame(pubkeys, halfThreshold);\n    if (!thresholdPublicKey) {\n      throw new Error(\"invalid result from nodes, threshold number of public key results are not matching\");\n    }\n    shareResponses.forEach(x => {\n      const requiredShareResponse = x && x.result && x.result.keys[0].public_key && x.result.keys[0];\n      if (requiredShareResponse && !thresholdNonceData && !verifierParams.extended_verifier_id) {\n        var _requiredShareRespons;\n        const currentPubKey = requiredShareResponse.public_key;\n        const pubNonce = (_requiredShareRespons = requiredShareResponse.nonce_data) === null || _requiredShareRespons === void 0 || (_requiredShareRespons = _requiredShareRespons.pubNonce) === null || _requiredShareRespons === void 0 ? void 0 : _requiredShareRespons.x;\n        if (pubNonce && currentPubKey.X === thresholdPublicKey.X) {\n          thresholdNonceData = requiredShareResponse.nonce_data;\n        }\n      }\n    });\n    const thresholdReqCount = canImportedShares ? endpoints.length : halfThreshold;\n    // optimistically run lagrange interpolation once threshold number of shares have been received\n    // this is matched against the user public key to ensure that shares are consistent\n    // Note: no need of thresholdMetadataNonce for extended_verifier_id key\n    if (completedRequests.length >= thresholdReqCount && thresholdPublicKey) {\n      const sharePromises = [];\n      const sessionTokenSigPromises = [];\n      const sessionTokenPromises = [];\n      const nodeIndexes = [];\n      const sessionTokenData = [];\n      const isNewKeyResponses = [];\n      const serverTimeOffsetResponses = [];\n      for (let i = 0; i < completedRequests.length; i += 1) {\n        var _currentShareResponse;\n        const currentShareResponse = completedRequests[i];\n        const {\n          session_tokens: sessionTokens,\n          session_token_metadata: sessionTokenMetadata,\n          session_token_sigs: sessionTokenSigs,\n          session_token_sig_metadata: sessionTokenSigMetadata,\n          keys,\n          is_new_key: isNewKey,\n          server_time_offset: serverTimeOffsetResponse\n        } = currentShareResponse.result;\n        isNewKeyResponses.push({\n          isNewKey,\n          publicKey: ((_currentShareResponse = currentShareResponse.result) === null || _currentShareResponse === void 0 || (_currentShareResponse = _currentShareResponse.keys[0]) === null || _currentShareResponse === void 0 || (_currentShareResponse = _currentShareResponse.public_key) === null || _currentShareResponse === void 0 ? void 0 : _currentShareResponse.X) || \"\"\n        });\n        serverTimeOffsetResponses.push(serverTimeOffsetResponse || \"0\");\n        if ((sessionTokenSigs === null || sessionTokenSigs === void 0 ? void 0 : sessionTokenSigs.length) > 0) {\n          var _sessionTokenSigMetad;\n          // decrypt sessionSig if enc metadata is sent\n          if (sessionTokenSigMetadata && (_sessionTokenSigMetad = sessionTokenSigMetadata[0]) !== null && _sessionTokenSigMetad !== void 0 && _sessionTokenSigMetad.ephemPublicKey) {\n            sessionTokenSigPromises.push(decryptNodeData(sessionTokenSigMetadata[0], sessionTokenSigs[0], sessionAuthKey).catch(err => log.error(\"session sig decryption\", err)));\n          } else {\n            sessionTokenSigPromises.push(Promise.resolve(Buffer.from(sessionTokenSigs[0], \"hex\")));\n          }\n        } else {\n          sessionTokenSigPromises.push(Promise.resolve(undefined));\n        }\n        if ((sessionTokens === null || sessionTokens === void 0 ? void 0 : sessionTokens.length) > 0) {\n          var _sessionTokenMetadata;\n          // decrypt session token if enc metadata is sent\n          if (sessionTokenMetadata && (_sessionTokenMetadata = sessionTokenMetadata[0]) !== null && _sessionTokenMetadata !== void 0 && _sessionTokenMetadata.ephemPublicKey) {\n            sessionTokenPromises.push(decryptNodeData(sessionTokenMetadata[0], sessionTokens[0], sessionAuthKey).catch(err => log.error(\"session token sig decryption\", err)));\n          } else {\n            sessionTokenPromises.push(Promise.resolve(Buffer.from(sessionTokens[0], \"base64\")));\n          }\n        } else {\n          sessionTokenPromises.push(Promise.resolve(undefined));\n        }\n        if ((keys === null || keys === void 0 ? void 0 : keys.length) > 0) {\n          const latestKey = currentShareResponse.result.keys[0];\n          nodeIndexes.push(new BN(latestKey.node_index));\n          if (latestKey.share_metadata) {\n            sharePromises.push(decryptNodeDataWithPadding(latestKey.share_metadata, Buffer.from(latestKey.share, \"base64\").toString(\"binary\"), sessionAuthKey).catch(err => log.error(\"share decryption\", err)));\n          }\n        } else {\n          nodeIndexes.push(undefined);\n          sharePromises.push(Promise.resolve(undefined));\n        }\n      }\n      const allPromises = await Promise.all(sharePromises.concat(sessionTokenSigPromises).concat(sessionTokenPromises));\n      const sharesResolved = allPromises.slice(0, sharePromises.length);\n      const sessionSigsResolved = allPromises.slice(sharePromises.length, sharePromises.length + sessionTokenSigPromises.length);\n      const sessionTokensResolved = allPromises.slice(sharePromises.length + sessionTokenSigPromises.length, allPromises.length);\n      const validSigs = sessionSigsResolved.filter(sig => {\n        if (sig) {\n          return true;\n        }\n        return false;\n      });\n      if (!verifierParams.extended_verifier_id && validSigs.length < halfThreshold) {\n        throw new Error(`Insufficient number of signatures from nodes, required: ${halfThreshold}, found: ${validSigs.length}`);\n      }\n      const validTokens = sessionTokensResolved.filter(token => {\n        if (token) {\n          return true;\n        }\n        return false;\n      });\n      if (!verifierParams.extended_verifier_id && validTokens.length < halfThreshold) {\n        throw new Error(`Insufficient number of session tokens from nodes, required: ${halfThreshold}, found: ${validTokens.length}`);\n      }\n      sessionTokensResolved.forEach((x, index) => {\n        if (!x || !sessionSigsResolved[index]) sessionTokenData.push(undefined);else sessionTokenData.push({\n          token: x.toString(\"base64\"),\n          signature: sessionSigsResolved[index].toString(\"hex\"),\n          node_pubx: completedRequests[index].result.node_pubx,\n          node_puby: completedRequests[index].result.node_puby\n        });\n      });\n      if (sharedState.resolved) return undefined;\n      const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n        if (curr) {\n          acc.push({\n            index: nodeIndexes[index],\n            value: new BN(curr)\n          });\n        }\n        return acc;\n      }, []);\n      // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n      const allCombis = kCombinations(decryptedShares.length, halfThreshold);\n      let privateKey = null;\n      for (let j = 0; j < allCombis.length; j += 1) {\n        const currentCombi = allCombis[j];\n        const currentCombiShares = decryptedShares.filter((_, index) => currentCombi.includes(index));\n        const shares = currentCombiShares.map(x => x.value);\n        const indices = currentCombiShares.map(x => x.index);\n        const derivedPrivateKey = lagrangeInterpolation(ecCurve, shares, indices);\n        if (!derivedPrivateKey) continue;\n        const decryptedPubKey = derivePubKey(ecCurve, derivedPrivateKey);\n        const decryptedPubKeyX = decryptedPubKey.getX();\n        const decryptedPubKeyY = decryptedPubKey.getY();\n        if (decryptedPubKeyX.cmp(new BN(thresholdPublicKey.X, 16)) === 0 && decryptedPubKeyY.cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n          privateKey = derivedPrivateKey;\n          break;\n        }\n      }\n      if (privateKey === undefined || privateKey === null) {\n        throw new Error(\"could not derive private key\");\n      }\n      let isNewKey = false;\n      isNewKeyResponses.forEach(x => {\n        if (x.isNewKey === \"true\" && x.publicKey.toLowerCase() === thresholdPublicKey.X.toLowerCase()) {\n          isNewKey = true;\n        }\n      });\n\n      // Convert each string timestamp to a number\n      const serverOffsetTimes = serverTimeOffsetResponses.map(timestamp => Number.parseInt(timestamp, 10));\n      return {\n        privateKey,\n        sessionTokenData,\n        thresholdNonceData,\n        nodeIndexes,\n        thresholdPubKey: thresholdPublicKey,\n        isNewKey,\n        serverTimeOffsetResponse: serverTimeOffset || calculateMedian(serverOffsetTimes)\n      };\n    }\n    if (completedRequests.length < thresholdReqCount) {\n      throw new Error(`Waiting for results from more nodes, pending: ${thresholdReqCount - completedRequests.length}`);\n    }\n    throw new Error(`Invalid results, threshold pub key: ${thresholdPublicKey}, nonce data found: ${!!thresholdNonceData}, extended verifierId: ${verifierParams.extended_verifier_id}`);\n  }).then(async res => {\n    var _nonceResult;\n    const {\n      privateKey,\n      thresholdPubKey,\n      sessionTokenData,\n      nodeIndexes,\n      thresholdNonceData,\n      isNewKey,\n      serverTimeOffsetResponse\n    } = res;\n    let nonceResult = thresholdNonceData;\n    if (!privateKey) throw new Error(\"Invalid private key returned\");\n    const oAuthKey = privateKey;\n    const oAuthPubKey = derivePubKey(ecCurve, oAuthKey);\n    const oAuthPubkeyX = oAuthPubKey.getX().toString(\"hex\", 64);\n    const oAuthPubkeyY = oAuthPubKey.getY().toString(\"hex\", 64);\n\n    // if both thresholdNonceData and extended_verifier_id are not available\n    // then we need to throw other wise address would be incorrect.\n    if (!nonceResult && !verifierParams.extended_verifier_id && !LEGACY_NETWORKS_ROUTE_MAP[network]) {\n      // NOTE: dont use padded pub key anywhere in metadata apis, send pub keys as is received from nodes.\n      const metadataNonceResult = await getOrSetSapphireMetadataNonce(network, thresholdPubKey.X, thresholdPubKey.Y, serverTimeOffset, oAuthKey);\n      // rechecking nonceResult to avoid promise race condition.\n      if (metadataNonceResult && !thresholdNonceData) {\n        nonceResult = metadataNonceResult;\n      } else {\n        throw new Error(`invalid metadata result from nodes, nonce metadata is empty for verifier: ${verifier} and verifierId: ${verifierParams.verifier_id}`);\n      }\n    }\n    let metadataNonce = new BN((_nonceResult = nonceResult) !== null && _nonceResult !== void 0 && _nonceResult.nonce ? nonceResult.nonce.padStart(64, \"0\") : \"0\", \"hex\");\n    let finalPubKey;\n    let pubNonce;\n    let typeOfUser = \"v1\";\n    // extended_verifier_id is only exception for torus-test-health verifier\n    // otherwise extended verifier id should not even return shares.\n    if (verifierParams.extended_verifier_id) {\n      typeOfUser = \"v2\";\n      // for tss key no need to add pub nonce\n      finalPubKey = ecCurve.keyFromPublic({\n        x: oAuthPubkeyX,\n        y: oAuthPubkeyY\n      }).getPublic();\n    } else if (LEGACY_NETWORKS_ROUTE_MAP[network]) {\n      if (enableOneKey) {\n        nonceResult = await getOrSetNonce(legacyMetadataHost, ecCurve, serverTimeOffsetResponse, oAuthPubkeyX, oAuthPubkeyY, oAuthKey, !isNewKey);\n        metadataNonce = new BN(nonceResult.nonce || \"0\", 16);\n        typeOfUser = nonceResult.typeOfUser;\n        if (typeOfUser === \"v2\") {\n          pubNonce = {\n            X: nonceResult.pubNonce.x,\n            Y: nonceResult.pubNonce.y\n          };\n          finalPubKey = ecCurve.keyFromPublic({\n            x: oAuthPubkeyX,\n            y: oAuthPubkeyY\n          }).getPublic().add(ecCurve.keyFromPublic({\n            x: nonceResult.pubNonce.x,\n            y: nonceResult.pubNonce.y\n          }).getPublic());\n        } else {\n          typeOfUser = \"v1\";\n          // for imported keys in legacy networks\n          metadataNonce = await getMetadata(legacyMetadataHost, {\n            pub_key_X: oAuthPubkeyX,\n            pub_key_Y: oAuthPubkeyY\n          });\n          const privateKeyWithNonce = oAuthKey.add(metadataNonce).umod(ecCurve.n);\n          finalPubKey = ecCurve.keyFromPrivate(privateKeyWithNonce.toString(16, 64), \"hex\").getPublic();\n        }\n      } else {\n        typeOfUser = \"v1\";\n        // for imported keys in legacy networks\n        metadataNonce = await getMetadata(legacyMetadataHost, {\n          pub_key_X: oAuthPubkeyX,\n          pub_key_Y: oAuthPubkeyY\n        });\n        const privateKeyWithNonce = oAuthKey.add(metadataNonce).umod(ecCurve.n);\n        finalPubKey = ecCurve.keyFromPrivate(privateKeyWithNonce.toString(16, 64), \"hex\").getPublic();\n      }\n    } else {\n      typeOfUser = \"v2\";\n      finalPubKey = ecCurve.keyFromPublic({\n        x: oAuthPubkeyX,\n        y: oAuthPubkeyY\n      }).getPublic().add(ecCurve.keyFromPublic({\n        x: nonceResult.pubNonce.x,\n        y: nonceResult.pubNonce.y\n      }).getPublic());\n      pubNonce = {\n        X: nonceResult.pubNonce.x,\n        Y: nonceResult.pubNonce.y\n      };\n    }\n    if (!finalPubKey) {\n      throw new Error(\"Invalid public key, this might be a bug, please report this to web3auth team\");\n    }\n    let finalPrivKey = \"\"; // it is empty for v2 user upgraded to 2/n\n    let isUpgraded = false;\n    const oAuthKeyAddress = generateAddressFromPrivKey(keyType, oAuthKey);\n    // deriving address from pub key coz pubkey is always available\n    // but finalPrivKey won't be available for  v2 user upgraded to 2/n\n    const finalWalletAddress = generateAddressFromPubKey(keyType, finalPubKey.getX(), finalPubKey.getY());\n    let keyWithNonce = \"\";\n    if (typeOfUser === \"v1\") {\n      isUpgraded = null;\n    } else if (typeOfUser === \"v2\") {\n      isUpgraded = metadataNonce.eq(new BN(\"0\"));\n    }\n    if (typeOfUser === \"v1\" || typeOfUser === \"v2\" && metadataNonce.gt(new BN(0))) {\n      const privateKeyWithNonce = oAuthKey.add(metadataNonce).umod(ecCurve.n);\n      keyWithNonce = privateKeyWithNonce.toString(\"hex\", 64);\n    }\n    if (keyType === KEY_TYPE.SECP256K1) {\n      finalPrivKey = keyWithNonce;\n    } else if (keyType === KEY_TYPE.ED25519) {\n      if (keyWithNonce && !nonceResult.seed) {\n        throw new Error(\"Invalid data, seed data is missing for ed25519 key, Please report this bug\");\n      } else if (keyWithNonce && nonceResult.seed) {\n        // console.log(\"nonceResult.seed\", nonceResult.seed, keyWithNonce);\n        const decryptedSeed = await decryptSeedData(nonceResult.seed, new BN(keyWithNonce, \"hex\"));\n        finalPrivKey = decryptedSeed.toString(\"hex\");\n      }\n    } else {\n      throw new Error(`Invalid keyType: ${keyType}`);\n    }\n    let postboxKey = oAuthKey;\n    let postboxPubX = oAuthPubkeyX;\n    let postboxPubY = oAuthPubkeyY;\n    if (keyType === KEY_TYPE.ED25519) {\n      const {\n        scalar,\n        point\n      } = getSecpKeyFromEd25519(privateKey);\n      postboxKey = scalar;\n      postboxPubX = point.getX().toString(16, 64);\n      postboxPubY = point.getY().toString(16, 64);\n      if (thresholdPubKey.SignerX.padStart(64, \"0\") !== postboxPubX || thresholdPubKey.SignerY.padStart(64, \"0\") !== postboxPubY) {\n        throw new Error(\"Invalid postbox key\");\n      }\n    }\n    // return reconstructed private key and ethereum address\n    return {\n      finalKeyData: {\n        walletAddress: finalWalletAddress,\n        X: finalPubKey.getX().toString(16, 64),\n        // this is final pub x user before and after updating to 2/n\n        Y: finalPubKey.getY().toString(16, 64),\n        // this is final pub y user before and after updating to 2/n\n        privKey: finalPrivKey\n      },\n      oAuthKeyData: {\n        walletAddress: oAuthKeyAddress,\n        X: oAuthPubkeyX,\n        Y: oAuthPubkeyY,\n        privKey: oAuthKey.toString(\"hex\", 64)\n      },\n      postboxKeyData: {\n        privKey: postboxKey.toString(\"hex\", 64),\n        X: postboxPubX,\n        Y: postboxPubY\n      },\n      sessionData: {\n        sessionTokenData,\n        sessionAuthKey: sessionAuthKey.toString(\"hex\").padStart(64, \"0\")\n      },\n      metadata: {\n        pubNonce,\n        nonce: metadataNonce,\n        typeOfUser,\n        upgraded: isUpgraded,\n        serverTimeOffset: serverTimeOffsetResponse\n      },\n      nodesData: {\n        nodeIndexes: nodeIndexes.map(x => x.toNumber())\n      }\n    };\n  });\n}\n\nexport { GetPubKeyOrKeyAssign, VerifierLookupRequest, retrieveOrImportShare };\n", "import _defineProperty from '@babel/runtime/helpers/defineProperty';\n\n/* eslint-disable promise/catch-or-return */\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nclass SomeError extends Error {\n  constructor({\n    errors,\n    responses,\n    predicate\n  }) {\n    // its fine to log responses in errors logs for better debugging,\n    // as data is always encrypted with temp key\n    // temp key should not be logged anywhere\n    const message = `Unable to resolve enough promises. \n      errors: ${errors.map(x => (x === null || x === void 0 ? void 0 : x.message) || x).join(\", \")}, \n      predicate error: ${predicate},\n      ${responses.length} responses,\n      responses: ${JSON.stringify(responses)}`;\n    super(message);\n    _defineProperty(this, \"errors\", void 0);\n    _defineProperty(this, \"responses\", void 0);\n    _defineProperty(this, \"predicate\", void 0);\n    this.errors = errors;\n    this.responses = responses;\n    this.predicate = predicate;\n  }\n  get message() {\n    return `${super.message}. errors: ${this.errors.map(x => (x === null || x === void 0 ? void 0 : x.message) || x).join(\", \")} and ${this.responses.length} responses: ${JSON.stringify(this.responses)},\n      predicate error: ${this.predicate}`;\n  }\n  toString() {\n    return this.message;\n  }\n}\nconst Some = (promises, predicate) => new Promise((resolve, reject) => {\n  let finishedCount = 0;\n  const sharedState = {\n    resolved: false\n  };\n  const errorArr = new Array(promises.length).fill(undefined);\n  const resultArr = new Array(promises.length).fill(undefined);\n  let predicateError;\n  promises.forEach((x, index) => {\n    x.then(resp => {\n      resultArr[index] = resp;\n      return undefined;\n    }).catch(error => {\n      errorArr[index] = error;\n    })\n    // eslint-disable-next-line promise/no-return-in-finally\n    .finally(() => {\n      if (sharedState.resolved) return;\n      return predicate(resultArr.slice(0), sharedState).then(data => {\n        sharedState.resolved = true;\n        resolve(data);\n        return undefined;\n      }).catch(error => {\n        // log only the last predicate error\n        predicateError = error;\n      }).finally(() => {\n        finishedCount += 1;\n        if (finishedCount === promises.length) {\n          const errors = Object.values(resultArr.reduce((acc, z) => {\n            if (z) {\n              var _error$data;\n              const {\n                id,\n                error\n              } = z;\n              if ((error === null || error === void 0 || (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith(\"Error occurred while verifying params\")) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n            }\n            return acc;\n          }, {}));\n          if (errors.length > 0) {\n            // Format-able errors\n            const msg = errors.length > 1 ? `\\n${errors.map(it => ` ${it}`).join(\"\\n\")}` : errors[0];\n            reject(new Error(msg));\n          } else {\n            var _predicateError;\n            reject(new SomeError({\n              errors: errorArr,\n              responses: resultArr,\n              predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n            }));\n          }\n        }\n      });\n    });\n  });\n});\n\nexport { Some, SomeError };\n", "import { KEY_TYPE } from '@toruslabs/constants';\nimport { BN } from 'bn.js';\nimport { ec } from 'elliptic';\nimport { keccak256 as keccak256$1 } from 'ethereum-cryptography/keccak';\nimport stringify from 'json-stable-stringify';\n\nfunction keccak256(a) {\n  const hash = Buffer.from(keccak256$1(a)).toString(\"hex\");\n  return `0x${hash}`;\n}\nconst generatePrivateKey = (ecCurve, buf) => {\n  return ecCurve.genKeyPair().getPrivate().toArrayLike(buf);\n};\nconst getKeyCurve = keyType => {\n  if (keyType === KEY_TYPE.ED25519) {\n    return new ec(KEY_TYPE.ED25519);\n  } else if (keyType === KEY_TYPE.SECP256K1) {\n    return new ec(KEY_TYPE.SECP256K1);\n  }\n  throw new Error(`Invalid keyType: ${keyType}`);\n};\n// this function normalizes the result from nodes before passing the result to threshold check function\n// For ex: some fields returns by nodes might be different from each other\n// like created_at field might vary and nonce_data might not be returned by all nodes because\n// of the metadata implementation in sapphire.\nconst normalizeKeysResult = result => {\n  const finalResult = {\n    keys: [],\n    is_new_key: result.is_new_key\n  };\n  if (result && result.keys && result.keys.length > 0) {\n    const finalKey = result.keys[0];\n    finalResult.keys = [{\n      pub_key_X: finalKey.pub_key_X,\n      pub_key_Y: finalKey.pub_key_Y,\n      address: finalKey.address\n    }];\n  }\n  return finalResult;\n};\nconst normalizeLookUpResult = result => {\n  const finalResult = {\n    keys: []\n  };\n  if (result && result.keys && result.keys.length > 0) {\n    const finalKey = result.keys[0];\n    finalResult.keys = [{\n      pub_key_X: finalKey.pub_key_X,\n      pub_key_Y: finalKey.pub_key_Y,\n      address: finalKey.address\n    }];\n  }\n  return finalResult;\n};\nconst kCombinations = (s, k) => {\n  let set = s;\n  if (typeof set === \"number\") {\n    set = Array.from({\n      length: set\n    }, (_, i) => i);\n  }\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n  if (k === set.length) {\n    return [set];\n  }\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], []);\n  }\n  const combs = [];\n  let tailCombs = [];\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]]);\n    }\n  }\n  return combs;\n};\nconst thresholdSame = (arr, t) => {\n  const hashMap = {};\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = stringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n  return undefined;\n};\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\"),\n    mode: \"AES256\"\n  };\n}\nfunction encParamsHexToBuf(eciesData) {\n  return {\n    ephemPublicKey: Buffer.from(eciesData.ephemPublicKey, \"hex\"),\n    iv: Buffer.from(eciesData.iv, \"hex\"),\n    mac: Buffer.from(eciesData.mac, \"hex\")\n  };\n}\nfunction getProxyCoordinatorEndpointIndex(endpoints, verifier, verifierId) {\n  const verifierIdStr = `${verifier}${verifierId}`;\n  const hashedVerifierId = keccak256(Buffer.from(verifierIdStr, \"utf8\")).slice(2);\n  const proxyEndpointNum = new BN(hashedVerifierId, \"hex\").mod(new BN(endpoints.length)).toNumber();\n  return proxyEndpointNum;\n}\nfunction calculateMedian(arr) {\n  const arrSize = arr.length;\n  if (arrSize === 0) return 0;\n  const sortedArr = arr.sort(function (a, b) {\n    return a - b;\n  });\n\n  // odd length\n  if (arrSize % 2 !== 0) {\n    return sortedArr[Math.floor(arrSize / 2)];\n  }\n\n  // return average of two mid values in case of even arrSize\n  const mid1 = sortedArr[arrSize / 2 - 1];\n  const mid2 = sortedArr[arrSize / 2];\n  return (mid1 + mid2) / 2;\n}\nfunction waitFor(milliseconds) {\n  return new Promise((resolve, reject) => {\n    // hack to bypass eslint warning.\n    if (milliseconds > 0) {\n      setTimeout(resolve, milliseconds);\n    } else {\n      reject(new Error(\"value of milliseconds must be greater than 0\"));\n    }\n  });\n}\nfunction retryCommitment(executionPromise, maxRetries) {\n  // Notice that we declare an inner function here\n  // so we can encapsulate the retries and don't expose\n  // it to the caller. This is also a recursive function\n  async function retryWithBackoff(retries) {\n    try {\n      // we don't wait on the first attempt\n      if (retries > 0) {\n        // on every retry, we exponentially increase the time to wait.\n        // Here is how it looks for a `maxRetries` = 4\n        // (2 ** 1) * 100 = 200 ms\n        // (2 ** 2) * 100 = 400 ms\n        // (2 ** 3) * 100 = 800 ms\n        const timeToWait = 2 ** retries * 100;\n        await waitFor(timeToWait);\n      }\n      const a = await executionPromise();\n      return a;\n    } catch (e) {\n      const errorMsg = e.message;\n      const acceptedErrorMsgs = [\n      // Slow node\n      \"Timed out\", \"Failed to fetch\", \"fetch failed\", \"Load failed\", \"cancelled\", \"NetworkError when attempting to fetch resource.\",\n      // Happens when the node is not reachable (dns issue etc)\n      \"TypeError: Failed to fetch\",\n      // All except iOS and Firefox\n      \"TypeError: cancelled\",\n      // iOS\n      \"TypeError: NetworkError when attempting to fetch resource.\" // Firefox\n      ];\n      if (retries < maxRetries && (acceptedErrorMsgs.includes(errorMsg) || errorMsg && errorMsg.includes(\"reason: getaddrinfo EAI_AGAIN\"))) {\n        // only retry if we didn't reach the limit\n        // otherwise, let the caller handle the error\n        return retryWithBackoff(retries + 1);\n      }\n      throw e;\n    }\n  }\n  return retryWithBackoff(0);\n}\n\nexport { calculateMedian, encParamsBufToHex, encParamsHexToBuf, generatePrivateKey, getKeyCurve, getProxyCoordinatorEndpointIndex, kCombinations, keccak256, normalizeKeysResult, normalizeLookUpResult, retryCommitment, thresholdSame, waitFor };\n", "const base = ALPHABET => {\n  if (ALPHABET.length >= 255) {\n    throw new TypeError(\"Alphabet too long\");\n  }\n  const BASE_MAP = new Uint8Array(256);\n  for (let j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (let i = 0; i < ALPHABET.length; i++) {\n    const x = ALPHABET.charAt(i);\n    const xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) {\n      throw new TypeError(`${x} is ambiguous`);\n    }\n    BASE_MAP[xc] = i;\n  }\n  const BASE = ALPHABET.length;\n  const LEADER = ALPHABET.charAt(0);\n  const FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  const iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  function encode(source) {\n    // eslint-disable-next-line no-empty\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) {\n      throw new TypeError(\"Expected Uint8Array\");\n    }\n    if (source.length === 0) {\n      return \"\";\n    }\n    // Skip & count leading zeroes.\n    let zeroes = 0;\n    let length = 0;\n    let pbegin = 0;\n    const pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n    // Allocate enough space in big-endian base58 representation.\n    const size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n    const b58 = new Uint8Array(size);\n    // Process the bytes.\n    while (pbegin !== pend) {\n      let carry = source[pbegin];\n      // Apply \"b58 = b58 * 256 + ch\".\n      let i = 0;\n      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {\n        carry += 256 * b58[it1] >>> 0;\n        b58[it1] = carry % BASE >>> 0;\n        carry = carry / BASE >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error(\"Non-zero carry\");\n      }\n      length = i;\n      pbegin++;\n    }\n    // Skip leading zeroes in base58 result.\n    let it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n    // Translate the result into a string.\n    let str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) {\n      str += ALPHABET.charAt(b58[it2]);\n    }\n    return str;\n  }\n  function decodeUnsafe(source) {\n    if (typeof source !== \"string\") {\n      throw new TypeError(\"Expected String\");\n    }\n    if (source.length === 0) {\n      return new Uint8Array();\n    }\n    let psz = 0;\n    // Skip and count leading '1's.\n    let zeroes = 0;\n    let length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n    // Allocate enough space in big-endian base256 representation.\n    const size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.\n    const b256 = new Uint8Array(size);\n    // Process the characters.\n    while (source[psz]) {\n      // Decode character\n      let carry = BASE_MAP[source.charCodeAt(psz)];\n      // Invalid character\n      if (carry === 255) {\n        return;\n      }\n      let i = 0;\n      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {\n        carry += BASE * b256[it3] >>> 0;\n        b256[it3] = carry % 256 >>> 0;\n        carry = carry / 256 >>> 0;\n      }\n      if (carry !== 0) {\n        throw new Error(\"Non-zero carry\");\n      }\n      length = i;\n      psz++;\n    }\n    // Skip leading zeroes in b256.\n    let it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    const vch = new Uint8Array(zeroes + (size - it4));\n    let j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch;\n  }\n  function decode(s) {\n    const buffer = decodeUnsafe(s);\n    if (buffer) {\n      return buffer;\n    }\n    throw new Error(`Non-base${BASE} character`);\n  }\n  return {\n    encode,\n    decodeUnsafe,\n    decode\n  };\n};\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nconst bs58 = base(ALPHABET);\n\nexport { bs58 };\n", "import { bs58 } from '@toruslabs/bs58';\nimport { KEY_TYPE } from '@toruslabs/constants';\nimport { encrypt } from '@toruslabs/eccrypto';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport { keccak256 } from 'ethereum-cryptography/keccak';\nimport { sha512 } from 'ethereum-cryptography/sha512';\nimport stringify from 'json-stable-stringify';\nimport log from 'loglevel';\nimport { getKeyCurve, encParamsBufToHex, generatePrivateKey, keccak256 as keccak256$1 } from './common.js';\nimport { generateRandomPolynomial } from './langrangeInterpolatePoly.js';\nimport { getSecpKeyFromEd25519, generateNonceMetadataParams } from './metadataUtils.js';\n\nfunction stripHexPrefix(str) {\n  return str.startsWith(\"0x\") ? str.slice(2) : str;\n}\nfunction toChecksumAddress(hexAddress) {\n  const address = stripHexPrefix(hexAddress).toLowerCase();\n  const buf = Buffer.from(address, \"utf8\");\n  const hash = Buffer.from(keccak256(buf)).toString(\"hex\");\n  let ret = \"0x\";\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n  return ret;\n}\nfunction adjustScalarBytes(bytes) {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n/** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\nfunction getEd25519ExtendedPublicKey(keyBuffer) {\n  const ed25519Curve = getKeyCurve(KEY_TYPE.ED25519);\n  const len = 32;\n  const G = ed25519Curve.g;\n  const N = ed25519Curve.n;\n  if (keyBuffer.length !== 32) {\n    log.error(\"Invalid seed for ed25519 key derivation\", keyBuffer.length);\n    throw new Error(\"Invalid seed for ed25519 key derivation\");\n  }\n  // Hash private key with curve's hash function to produce uniformingly random input\n  // Check byte lengths: ensure(64, h(ensure(32, key)))\n  const hashed = sha512(keyBuffer);\n  if (hashed.length !== 64) {\n    throw new Error(\"Invalid hash length for ed25519 seed\");\n  }\n  const head = new BN(adjustScalarBytes(Buffer.from(hashed.slice(0, len))), \"le\");\n  const scalar = new BN(head.umod(N), \"le\"); // The actual private scalar\n  const point = G.mul(scalar); // Point on Edwards curve aka public key\n  return {\n    scalar,\n    point\n  };\n}\nfunction encodeEd25519Point(point) {\n  const ed25519Curve = getKeyCurve(KEY_TYPE.ED25519);\n  const encodingLength = Math.ceil(ed25519Curve.n.bitLength() / 8);\n  const enc = point.getY().toArrayLike(Buffer, \"le\", encodingLength);\n  enc[encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;\n  return enc;\n}\nconst generateEd25519KeyData = async ed25519Seed => {\n  const ed25519Curve = getKeyCurve(KEY_TYPE.ED25519);\n  const finalEd25519Key = getEd25519ExtendedPublicKey(ed25519Seed);\n  const encryptionKey = getSecpKeyFromEd25519(finalEd25519Key.scalar);\n  const encryptedSeed = await encrypt(Buffer.from(encryptionKey.point.encodeCompressed(\"hex\"), \"hex\"), ed25519Seed);\n  const encData = {\n    enc_text: encryptedSeed.ciphertext.toString(\"hex\"),\n    metadata: encParamsBufToHex(encryptedSeed),\n    public_key: encodeEd25519Point(finalEd25519Key.point).toString(\"hex\")\n  };\n  const encDataBase64 = Buffer.from(JSON.stringify(encData), \"utf-8\").toString(\"base64\");\n  const metadataPrivNonce = ed25519Curve.genKeyPair().getPrivate();\n  const oauthKey = finalEd25519Key.scalar.sub(metadataPrivNonce).umod(ed25519Curve.n);\n  const oauthKeyPair = ed25519Curve.keyFromPrivate(oauthKey.toArrayLike(Buffer));\n  const metadataSigningKey = getSecpKeyFromEd25519(oauthKeyPair.getPrivate());\n  return {\n    oAuthKeyScalar: oauthKeyPair.getPrivate(),\n    oAuthPubX: oauthKeyPair.getPublic().getX(),\n    oAuthPubY: oauthKeyPair.getPublic().getY(),\n    SigningPubX: metadataSigningKey.point.getX(),\n    SigningPubY: metadataSigningKey.point.getY(),\n    metadataNonce: metadataPrivNonce,\n    metadataSigningKey: metadataSigningKey.scalar,\n    encryptedSeed: encDataBase64,\n    finalUserPubKeyPoint: finalEd25519Key.point\n  };\n};\nconst generateSecp256k1KeyData = async scalarBuffer => {\n  const secp256k1Curve = getKeyCurve(KEY_TYPE.SECP256K1);\n  const scalar = new BN(scalarBuffer);\n  const randomNonce = new BN(generatePrivateKey(secp256k1Curve, Buffer));\n  const oAuthKey = scalar.sub(randomNonce).umod(secp256k1Curve.n);\n  const oAuthKeyPair = secp256k1Curve.keyFromPrivate(oAuthKey.toArrayLike(Buffer));\n  const oAuthPubKey = oAuthKeyPair.getPublic();\n  const finalUserKeyPair = secp256k1Curve.keyFromPrivate(scalar.toString(\"hex\", 64), \"hex\");\n  return {\n    oAuthKeyScalar: oAuthKeyPair.getPrivate(),\n    oAuthPubX: oAuthPubKey.getX(),\n    oAuthPubY: oAuthPubKey.getY(),\n    SigningPubX: oAuthPubKey.getX(),\n    SigningPubY: oAuthPubKey.getY(),\n    metadataNonce: randomNonce,\n    encryptedSeed: \"\",\n    metadataSigningKey: oAuthKeyPair.getPrivate(),\n    finalUserPubKeyPoint: finalUserKeyPair.getPublic()\n  };\n};\nfunction generateAddressFromEcKey(keyType, key) {\n  if (keyType === KEY_TYPE.SECP256K1) {\n    const publicKey = key.getPublic().encode(\"hex\", false).slice(2);\n    const evmAddressLower = `0x${keccak256$1(Buffer.from(publicKey, \"hex\")).slice(64 - 38)}`;\n    return toChecksumAddress(evmAddressLower);\n  } else if (keyType === KEY_TYPE.ED25519) {\n    const publicKey = encodeEd25519Point(key.getPublic());\n    const address = bs58.encode(publicKey);\n    return address;\n  }\n  throw new Error(`Invalid keyType: ${keyType}`);\n}\nfunction generateAddressFromPrivKey(keyType, privateKey) {\n  const ecCurve = getKeyCurve(keyType);\n  const key = ecCurve.keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n  return generateAddressFromEcKey(keyType, key);\n}\nfunction generateAddressFromPubKey(keyType, publicKeyX, publicKeyY) {\n  const ecCurve = getKeyCurve(keyType);\n  const key = ecCurve.keyFromPublic({\n    x: publicKeyX.toString(\"hex\", 64),\n    y: publicKeyY.toString(\"hex\", 64)\n  });\n  return generateAddressFromEcKey(keyType, key);\n}\nfunction getPostboxKeyFrom1OutOf1(ecCurve, privKey, nonce) {\n  const privKeyBN = new BN(privKey, 16);\n  const nonceBN = new BN(nonce, 16);\n  return privKeyBN.sub(nonceBN).umod(ecCurve.n).toString(\"hex\");\n}\nfunction derivePubKey(ecCurve, sk) {\n  const skHex = sk.toString(16, 64);\n  return ecCurve.keyFromPrivate(skHex, \"hex\").getPublic();\n}\nconst getEncryptionEC = () => {\n  return new ec(\"secp256k1\");\n};\nconst generateShares = async (ecCurve, keyType, serverTimeOffset, nodeIndexes, nodePubkeys, privKey) => {\n  const keyData = keyType === KEY_TYPE.ED25519 ? await generateEd25519KeyData(privKey) : await generateSecp256k1KeyData(privKey);\n  const {\n    metadataNonce,\n    oAuthKeyScalar: oAuthKey,\n    encryptedSeed,\n    metadataSigningKey\n  } = keyData;\n  const threshold = ~~(nodePubkeys.length / 2) + 1;\n  const degree = threshold - 1;\n  const nodeIndexesBn = [];\n  for (const nodeIndex of nodeIndexes) {\n    nodeIndexesBn.push(new BN(nodeIndex));\n  }\n  const oAuthPubKey = ecCurve.keyFromPrivate(oAuthKey.toString(\"hex\", 64), \"hex\").getPublic();\n  const poly = generateRandomPolynomial(ecCurve, degree, oAuthKey);\n  const shares = poly.generateShares(nodeIndexesBn);\n  const nonceParams = generateNonceMetadataParams(serverTimeOffset, \"getOrSetNonce\", metadataSigningKey, keyType, metadataNonce, encryptedSeed);\n  const nonceData = Buffer.from(stringify(nonceParams.set_data), \"utf8\").toString(\"base64\");\n  const sharesData = [];\n  const encPromises = [];\n  for (let i = 0; i < nodeIndexesBn.length; i++) {\n    const shareJson = shares[nodeIndexesBn[i].toString(\"hex\", 64)].toJSON();\n    if (!nodePubkeys[i]) {\n      throw new Error(`Missing node pub key for node index: ${nodeIndexesBn[i].toString(\"hex\", 64)}`);\n    }\n    const nodePubKey = getEncryptionEC().keyFromPublic({\n      x: nodePubkeys[i].X,\n      y: nodePubkeys[i].Y\n    });\n    encPromises.push(encrypt(Buffer.from(nodePubKey.getPublic().encodeCompressed(\"hex\"), \"hex\"), Buffer.from(shareJson.share.padStart(64, \"0\"), \"hex\")));\n  }\n  const encShares = await Promise.all(encPromises);\n  for (let i = 0; i < nodeIndexesBn.length; i += 1) {\n    const shareJson = shares[nodeIndexesBn[i].toString(\"hex\", 64)].toJSON();\n    const encParams = encShares[i];\n    const encParamsMetadata = encParamsBufToHex(encParams);\n    const shareData = {\n      encrypted_seed: keyData.encryptedSeed,\n      final_user_point: keyData.finalUserPubKeyPoint,\n      oauth_pub_key_x: oAuthPubKey.getX().toString(\"hex\"),\n      oauth_pub_key_y: oAuthPubKey.getY().toString(\"hex\"),\n      signing_pub_key_x: keyData.SigningPubX.toString(\"hex\"),\n      signing_pub_key_y: keyData.SigningPubY.toString(\"hex\"),\n      encrypted_share: encParamsMetadata.ciphertext,\n      encrypted_share_metadata: encParamsMetadata,\n      node_index: Number.parseInt(shareJson.shareIndex, 16),\n      key_type: keyType,\n      nonce_data: nonceData,\n      nonce_signature: nonceParams.signature\n    };\n    sharesData.push(shareData);\n  }\n  return sharesData;\n};\n\nexport { derivePubKey, encodeEd25519Point, generateAddressFromPrivKey, generateAddressFromPubKey, generateEd25519KeyData, generateSecp256k1KeyData, generateShares, getEd25519ExtendedPublicKey, getEncryptionEC, getPostboxKeyFrom1OutOf1, stripHexPrefix, toChecksumAddress };\n", "import { sha512 as _sha512 } from \"@noble/hashes/sha512\";\nimport { wrapHash } from \"./utils.js\";\nexport const sha512 = wrapHash(_sha512);\n", "import BN from 'bn.js';\nimport Point from '../Point.js';\nimport Polynomial from '../Polynomial.js';\nimport { generatePrivateKey } from './common.js';\n\nfunction generatePrivateExcludingIndexes(shareIndexes, ecCurve) {\n  const key = new BN(generatePrivateKey(ecCurve, Buffer));\n  if (shareIndexes.find(el => el.eq(key))) {\n    return generatePrivateExcludingIndexes(shareIndexes, ecCurve);\n  }\n  return key;\n}\nconst generateEmptyBNArray = length => Array.from({\n  length\n}, () => new BN(0));\nconst denominator = (ecCurve, i, innerPoints) => {\n  let result = new BN(1);\n  const xi = innerPoints[i].x;\n  for (let j = innerPoints.length - 1; j >= 0; j -= 1) {\n    if (i !== j) {\n      let tmp = new BN(xi);\n      tmp = tmp.sub(innerPoints[j].x);\n      tmp = tmp.umod(ecCurve.n);\n      result = result.mul(tmp);\n      result = result.umod(ecCurve.n);\n    }\n  }\n  return result;\n};\nconst interpolationPoly = (ecCurve, i, innerPoints) => {\n  let coefficients = generateEmptyBNArray(innerPoints.length);\n  const d = denominator(ecCurve, i, innerPoints);\n  if (d.cmp(new BN(0)) === 0) {\n    throw new Error(\"Denominator for interpolationPoly is 0\");\n  }\n  coefficients[0] = d.invm(ecCurve.n);\n  for (let k = 0; k < innerPoints.length; k += 1) {\n    const newCoefficients = generateEmptyBNArray(innerPoints.length);\n    if (k !== i) {\n      let j;\n      if (k < i) {\n        j = k + 1;\n      } else {\n        j = k;\n      }\n      j -= 1;\n      for (; j >= 0; j -= 1) {\n        newCoefficients[j + 1] = newCoefficients[j + 1].add(coefficients[j]).umod(ecCurve.n);\n        let tmp = new BN(innerPoints[k].x);\n        tmp = tmp.mul(coefficients[j]).umod(ecCurve.n);\n        newCoefficients[j] = newCoefficients[j].sub(tmp).umod(ecCurve.n);\n      }\n      coefficients = newCoefficients;\n    }\n  }\n  return coefficients;\n};\nconst pointSort = innerPoints => {\n  const pointArrClone = [...innerPoints];\n  pointArrClone.sort((a, b) => a.x.cmp(b.x));\n  return pointArrClone;\n};\nconst lagrange = (ecCurve, unsortedPoints) => {\n  const sortedPoints = pointSort(unsortedPoints);\n  const polynomial = generateEmptyBNArray(sortedPoints.length);\n  for (let i = 0; i < sortedPoints.length; i += 1) {\n    const coefficients = interpolationPoly(ecCurve, i, sortedPoints);\n    for (let k = 0; k < sortedPoints.length; k += 1) {\n      let tmp = new BN(sortedPoints[i].y);\n      tmp = tmp.mul(coefficients[k]);\n      polynomial[k] = polynomial[k].add(tmp).umod(ecCurve.n);\n    }\n  }\n  return new Polynomial(polynomial, ecCurve);\n};\nfunction lagrangeInterpolatePolynomial(ecCurve, points) {\n  return lagrange(ecCurve, points);\n}\nfunction lagrangeInterpolation(ecCurve, shares, nodeIndex) {\n  if (shares.length !== nodeIndex.length) {\n    throw new Error(\"shares not equal to nodeIndex length in lagrangeInterpolation\");\n  }\n  let secret = new BN(0);\n  for (let i = 0; i < shares.length; i += 1) {\n    let upper = new BN(1);\n    let lower = new BN(1);\n    for (let j = 0; j < shares.length; j += 1) {\n      if (i !== j) {\n        upper = upper.mul(nodeIndex[j].neg());\n        upper = upper.umod(ecCurve.n);\n        let temp = nodeIndex[i].sub(nodeIndex[j]);\n        temp = temp.umod(ecCurve.n);\n        lower = lower.mul(temp).umod(ecCurve.n);\n      }\n    }\n    let delta = upper.mul(lower.invm(ecCurve.n)).umod(ecCurve.n);\n    delta = delta.mul(shares[i]).umod(ecCurve.n);\n    secret = secret.add(delta);\n  }\n  return secret.umod(ecCurve.n);\n}\n\n// generateRandomPolynomial - determinisiticShares are assumed random\nfunction generateRandomPolynomial(ecCurve, degree, secret, deterministicShares) {\n  let actualS = secret;\n  if (!secret) {\n    actualS = generatePrivateExcludingIndexes([new BN(0)], ecCurve);\n  }\n  if (!deterministicShares) {\n    const poly = [actualS];\n    for (let i = 0; i < degree; i += 1) {\n      const share = generatePrivateExcludingIndexes(poly, ecCurve);\n      poly.push(share);\n    }\n    return new Polynomial(poly, ecCurve);\n  }\n  if (!Array.isArray(deterministicShares)) {\n    throw new Error(\"deterministic shares in generateRandomPolynomial should be an array\");\n  }\n  if (deterministicShares.length > degree) {\n    throw new Error(\"deterministicShares in generateRandomPolynomial should be less or equal than degree to ensure an element of randomness\");\n  }\n  const points = {};\n  deterministicShares.forEach(share => {\n    points[share.shareIndex.toString(\"hex\", 64)] = new Point(share.shareIndex, share.share, ecCurve);\n  });\n  for (let i = 0; i < degree - deterministicShares.length; i += 1) {\n    let shareIndex = generatePrivateExcludingIndexes([new BN(0)], ecCurve);\n    while (points[shareIndex.toString(\"hex\", 64)] !== undefined) {\n      shareIndex = generatePrivateExcludingIndexes([new BN(0)], ecCurve);\n    }\n    points[shareIndex.toString(\"hex\", 64)] = new Point(shareIndex, new BN(generatePrivateKey(ecCurve, Buffer)), ecCurve);\n  }\n  points[\"0\"] = new Point(new BN(0), actualS, ecCurve);\n  return lagrangeInterpolatePolynomial(ecCurve, Object.values(points));\n}\n\nexport { generateRandomPolynomial, lagrangeInterpolatePolynomial, lagrangeInterpolation };\n", "import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport { KEY_TYPE, LEGACY_NETWORKS_ROUTE_MAP, TORUS_SAPPHIRE_NETWORK } from '@toruslabs/constants';\nimport { decrypt } from '@toruslabs/eccrypto';\nimport { post } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { keccak256 } from 'ethereum-cryptography/keccak';\nimport stringify from 'json-stable-stringify';\nimport log from 'loglevel';\nimport { SAPPHIRE_DEVNET_METADATA_URL, SAPPHIRE_METADATA_URL } from '../constants.js';\nimport { getKeyCurve, encParamsHexToBuf, keccak256 as keccak256$1 } from './common.js';\n\nconst getSecpKeyFromEd25519 = ed25519Scalar => {\n  const secp256k1Curve = getKeyCurve(KEY_TYPE.SECP256K1);\n  const ed25519Key = ed25519Scalar.toString(\"hex\", 64);\n  const keyHash = keccak256(Buffer.from(ed25519Key, \"hex\"));\n  const secpKey = new BN(keyHash).umod(secp256k1Curve.n).toString(\"hex\", 64);\n  const bufferKey = Buffer.from(secpKey, \"hex\");\n  const secpKeyPair = secp256k1Curve.keyFromPrivate(bufferKey);\n  if (bufferKey.length !== 32) {\n    throw new Error(`Key length must be equal to 32. got ${bufferKey.length}`);\n  }\n  return {\n    scalar: secpKeyPair.getPrivate(),\n    point: secpKeyPair.getPublic()\n  };\n};\nfunction convertMetadataToNonce(params) {\n  if (!params || !params.message) {\n    return new BN(0);\n  }\n  return new BN(params.message, 16);\n}\nasync function decryptNodeData(eciesData, ciphertextHex, privKey) {\n  const metadata = encParamsHexToBuf(eciesData);\n  const decryptedSigBuffer = await decrypt(privKey, _objectSpread(_objectSpread({}, metadata), {}, {\n    ciphertext: Buffer.from(ciphertextHex, \"hex\")\n  }));\n  return decryptedSigBuffer;\n}\nasync function decryptNodeDataWithPadding(eciesData, ciphertextHex, privKey) {\n  const metadata = encParamsHexToBuf(eciesData);\n  try {\n    const decryptedSigBuffer = await decrypt(privKey, _objectSpread(_objectSpread({}, metadata), {}, {\n      ciphertext: Buffer.from(ciphertextHex, \"hex\")\n    }));\n    return decryptedSigBuffer;\n  } catch (error) {\n    // ciphertext can be any length. not just 64. depends on input. we have this for legacy reason\n    const ciphertextHexPadding = ciphertextHex.padStart(64, \"0\");\n    log.warn(\"Failed to decrypt padded share cipher\", error);\n    // try without cipher text padding\n    return decrypt(privKey, _objectSpread(_objectSpread({}, metadata), {}, {\n      ciphertext: Buffer.from(ciphertextHexPadding, \"hex\")\n    }));\n  }\n}\nfunction generateMetadataParams(ecCurve, serverTimeOffset, message, privateKey) {\n  const key = ecCurve.keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n  const setData = {\n    data: message,\n    timestamp: new BN(~~(serverTimeOffset + Date.now() / 1000)).toString(16)\n  };\n  const sig = key.sign(keccak256$1(Buffer.from(stringify(setData), \"utf8\")).slice(2));\n  return {\n    pub_key_X: key.getPublic().getX().toString(\"hex\"),\n    // DO NOT PAD THIS. BACKEND DOESN'T\n    pub_key_Y: key.getPublic().getY().toString(\"hex\"),\n    // DO NOT PAD THIS. BACKEND DOESN'T\n    set_data: setData,\n    signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n  };\n}\nasync function getMetadata(legacyMetadataHost, data, options = {}) {\n  try {\n    const metadataResponse = await post(`${legacyMetadataHost}/get`, data, options, {\n      useAPIKey: true\n    });\n    if (!metadataResponse || !metadataResponse.message) {\n      return new BN(0);\n    }\n    return new BN(metadataResponse.message, 16); // nonce\n  } catch (error) {\n    log.error(\"get metadata error\", error);\n    return new BN(0);\n  }\n}\nfunction generateNonceMetadataParams(serverTimeOffset, operation, privateKey, keyType, nonce, seed) {\n  // metadata only uses secp for sig validation\n  const key = getKeyCurve(KEY_TYPE.SECP256K1).keyFromPrivate(privateKey.toString(\"hex\", 64), \"hex\");\n  const setData = {\n    operation,\n    timestamp: new BN(~~(serverTimeOffset + Date.now() / 1000)).toString(16)\n  };\n  if (nonce) {\n    setData.data = nonce.toString(\"hex\", 64);\n  }\n  if (seed) {\n    setData.seed = seed;\n  } else {\n    setData.seed = \"\"; // setting it as empty to keep ordering same while serializing the data on backend.\n  }\n  const sig = key.sign(keccak256$1(Buffer.from(stringify(setData), \"utf8\")).slice(2));\n  return {\n    pub_key_X: key.getPublic().getX().toString(\"hex\", 64),\n    pub_key_Y: key.getPublic().getY().toString(\"hex\", 64),\n    set_data: setData,\n    key_type: keyType,\n    signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n  };\n}\nasync function getOrSetNonce(metadataHost, ecCurve, serverTimeOffset, X, Y, privKey, getOnly = false, isLegacyMetadata = true, nonce = new BN(0), keyType = \"secp256k1\", seed = \"\") {\n  // for legacy metadata\n  if (isLegacyMetadata) {\n    let data;\n    const msg = getOnly ? \"getNonce\" : \"getOrSetNonce\";\n    if (privKey) {\n      data = generateMetadataParams(ecCurve, serverTimeOffset, msg, privKey);\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: {\n          data: msg\n        }\n      };\n    }\n    return post(`${metadataHost}/get_or_set_nonce`, data, undefined, {\n      useAPIKey: true\n    });\n  }\n\n  // for sapphire metadata\n  const operation = getOnly ? \"getNonce\" : \"getOrSetNonce\";\n  if (operation === \"getOrSetNonce\") {\n    if (!privKey) {\n      throw new Error(\"privKey is required while `getOrSetNonce` for non legacy metadata\");\n    }\n    if (nonce.cmp(new BN(0)) === 0) {\n      throw new Error(\"nonce is required while `getOrSetNonce` for non legacy metadata\");\n    }\n    if (keyType === KEY_TYPE.ED25519 && !seed) {\n      throw new Error(\"seed is required while `getOrSetNonce` for non legacy metadata for ed25519 key type\");\n    }\n    const data = generateNonceMetadataParams(serverTimeOffset, operation, privKey, keyType, nonce, seed);\n    return post(`${metadataHost}/get_or_set_nonce`, data, undefined, {\n      useAPIKey: true\n    });\n  }\n  const data = {\n    pub_key_X: X,\n    pub_key_Y: Y,\n    set_data: {\n      operation\n    },\n    key_type: keyType\n  };\n  return post(`${metadataHost}/get_or_set_nonce`, data, undefined, {\n    useAPIKey: true\n  });\n}\nasync function getNonce(legacyMetadataHost, ecCurve, serverTimeOffset, X, Y, privKey) {\n  return getOrSetNonce(legacyMetadataHost, ecCurve, serverTimeOffset, X, Y, privKey, true);\n}\nconst decryptSeedData = async (seedBase64, finalUserKey) => {\n  const decryptionKey = getSecpKeyFromEd25519(finalUserKey);\n  const seedUtf8 = Buffer.from(seedBase64, \"base64\").toString(\"utf-8\");\n  const seedJson = JSON.parse(seedUtf8);\n  const bufferMetadata = _objectSpread(_objectSpread({}, encParamsHexToBuf(seedJson.metadata)), {}, {\n    mode: \"AES256\"\n  });\n  const bufferKey = decryptionKey.scalar.toArrayLike(Buffer, \"be\", 32);\n  const decText = await decrypt(bufferKey, _objectSpread(_objectSpread({}, bufferMetadata), {}, {\n    ciphertext: Buffer.from(seedJson.enc_text, \"hex\")\n  }));\n  return decText;\n};\nasync function getOrSetSapphireMetadataNonce(network, X, Y, serverTimeOffset, privKey) {\n  if (LEGACY_NETWORKS_ROUTE_MAP[network]) {\n    throw new Error(\"getOrSetSapphireMetadataNonce should only be used for sapphire networks\");\n  }\n  let data = {\n    pub_key_X: X,\n    pub_key_Y: Y,\n    key_type: \"secp256k1\",\n    set_data: {\n      operation: \"getOrSetNonce\"\n    }\n  };\n  if (privKey) {\n    const key = getKeyCurve(KEY_TYPE.SECP256K1).keyFromPrivate(privKey.toString(\"hex\", 64), \"hex\");\n    const setData = {\n      operation: \"getOrSetNonce\",\n      timestamp: new BN(~~(serverTimeOffset + Date.now() / 1000)).toString(16)\n    };\n    const sig = key.sign(keccak256$1(Buffer.from(stringify(setData), \"utf8\")).slice(2));\n    data = _objectSpread(_objectSpread({}, data), {}, {\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(\"\").toString(16, 2), \"hex\").toString(\"base64\")\n    });\n  }\n  const metadataUrl = network === TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET ? SAPPHIRE_DEVNET_METADATA_URL : SAPPHIRE_METADATA_URL;\n  return post(`${metadataUrl}/get_or_set_nonce`, data, undefined, {\n    useAPIKey: true\n  });\n}\n\nexport { convertMetadataToNonce, decryptNodeData, decryptNodeDataWithPadding, decryptSeedData, generateMetadataParams, generateNonceMetadataParams, getMetadata, getNonce, getOrSetNonce, getOrSetSapphireMetadataNonce, getSecpKeyFromEd25519 };\n", "import { KEY_TYPE } from '@toruslabs/constants';\nimport { post, generateJsonRPCObject } from '@toruslabs/http-helpers';\nimport log from 'loglevel';\nimport { JRPC_METHODS } from '../constants.js';\nimport { Some } from '../some.js';\nimport { thresholdSame, normalizeKeysResult } from './common.js';\n\n// Note: Endpoints should be the sss node endpoints along with path\n\n// for ex: [https://node-1.node.web3auth.io/sss/jrpc, https://node-2.node.web3auth.io/sss/jrpc ....]\nconst GetOrSetTssDKGPubKey = async params => {\n  const {\n    endpoints,\n    verifier,\n    verifierId,\n    tssVerifierId,\n    keyType = KEY_TYPE.SECP256K1\n  } = params;\n  const minThreshold = ~~(endpoints.length / 2) + 1;\n  const lookupPromises = endpoints.map(x => post(x, generateJsonRPCObject(JRPC_METHODS.GET_OR_SET_KEY, {\n    distributed_metadata: true,\n    verifier,\n    verifier_id: verifierId,\n    extended_verifier_id: tssVerifierId,\n    one_key_flow: true,\n    key_type: keyType,\n    fetch_node_index: true,\n    client_time: Math.floor(Date.now() / 1000).toString()\n  }), {}, {\n    logTracingHeader: false\n  }).catch(err => log.error(`${JRPC_METHODS.GET_OR_SET_KEY} request failed`, err)));\n  const nodeIndexes = [];\n  const result = await Some(lookupPromises, async lookupResults => {\n    const lookupPubKeys = lookupResults.filter(x1 => {\n      if (x1 && !x1.error) {\n        return x1;\n      }\n      return false;\n    });\n    const errorResult = thresholdSame(lookupResults.map(x2 => x2 && x2.error), minThreshold);\n    const keyResult = thresholdSame(lookupPubKeys.map(x3 => x3 && normalizeKeysResult(x3.result)), minThreshold);\n    if (keyResult || errorResult) {\n      if (keyResult) {\n        lookupResults.forEach(x1 => {\n          if (x1 && x1.result) {\n            const currentNodePubKey = x1.result.keys[0].pub_key_X.toLowerCase();\n            const thresholdPubKey = keyResult.keys[0].pub_key_X.toLowerCase();\n            // push only those indexes for nodes who are returning pub key matching with threshold pub key.\n            // this check is important when different nodes have different keys assigned to a user.\n            if (currentNodePubKey === thresholdPubKey) {\n              const nodeIndex = Number.parseInt(x1.result.node_index);\n              if (nodeIndex) nodeIndexes.push(nodeIndex);\n            }\n          }\n        });\n      }\n      return Promise.resolve({\n        keyResult,\n        nodeIndexes,\n        errorResult\n      });\n    }\n    return Promise.reject(new Error(`invalid public key result: ${JSON.stringify(lookupResults)} for tssVerifierId: ${tssVerifierId} `));\n  });\n  if (result.errorResult) {\n    throw new Error(`invalid public key result,errorResult: ${JSON.stringify(result.errorResult)}`);\n  }\n  const key = result.keyResult.keys[0];\n  return {\n    key: {\n      pubKeyX: key.pub_key_X,\n      pubKeyY: key.pub_key_Y,\n      address: key.address,\n      createdAt: key.created_at\n    },\n    nodeIndexes: result.nodeIndexes,\n    isNewKey: result.keyResult.is_new_key\n  };\n};\n\nexport { GetOrSetTssDKGPubKey };\n"],
  "mappings": "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",
  "names": ["BN", "import_bn", "import_bn", "BN", "BN", "import_bn", "import_elliptic", "log$1", "ec$1", "sha512", "hash", "result", "sha512", "import_bn", "import_bn", "import_elliptic", "keccak256", "stringify", "ALPHABET", "import_bn", "import_elliptic", "sha512", "import_json_stable_stringify", "import_loglevel", "import_bn", "BN", "import_bn", "import_json_stable_stringify", "import_loglevel", "BN", "log", "keccak256", "stringify", "data", "log", "sha512", "BN", "keccak256", "stringify", "serverTimeOffset", "keccak256", "isNewKey", "BN", "BN", "import_loglevel", "log"]
}
