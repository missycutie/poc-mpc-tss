import {
  Torus,
  keccak256 as keccak2562,
  toChecksumAddress
} from "./chunk-LQPOXDXK.js";
import {
  CustomError,
  SessionManager,
  bowser_default,
  require_base64url,
  require_events
} from "./chunk-F7QGJUT4.js";
import {
  decryptData,
  encryptData,
  keccak256
} from "./chunk-UXA7HNRO.js";
import {
  _defineProperty,
  _objectSpread2,
  get,
  post,
  require_cjs,
  require_elliptic,
  require_loglevel
} from "./chunk-NYBMST6M.js";
import {
  require_bn
} from "./chunk-J3UDRN3X.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@chaitanyapotti/register-service-worker/index.js
var require_register_service_worker = __commonJS({
  "node_modules/@chaitanyapotti/register-service-worker/index.js"(exports) {
    var isLocalhost = function() {
      return Boolean(
        window.location.hostname === "localhost" || // [::1] is the IPv6 localhost address.
        window.location.hostname === "[::1]" || // 127.0.0.1/8 is considered localhost for IPv4.
        window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)
      );
    };
    var waitWindowLoad;
    if (typeof window !== "undefined") {
      if (typeof document !== "undefined" && (document.readyState === "interactive" || document.readyState === "complete")) {
        waitWindowLoad = Promise.resolve();
      } else if (typeof Promise !== "undefined") {
        waitWindowLoad = new Promise(function(resolve) {
          return window.addEventListener("load", resolve);
        });
      } else {
        waitWindowLoad = { then: function(cb) {
          return window.addEventListener("load", cb);
        } };
      }
    }
    exports.register = function register2(swUrl, hooks) {
      if (hooks === void 0) hooks = {};
      var registrationOptions = hooks.registrationOptions;
      if (registrationOptions === void 0) registrationOptions = {};
      delete hooks.registrationOptions;
      var emit2 = function(hook) {
        var args = [], len = arguments.length - 1;
        while (len-- > 0) args[len] = arguments[len + 1];
        if (hooks && hooks[hook]) {
          hooks[hook].apply(hooks, args);
        }
      };
      if ("serviceWorker" in navigator) {
        waitWindowLoad.then(function() {
          if (isLocalhost()) {
            checkValidServiceWorker(swUrl, emit2, registrationOptions);
            navigator.serviceWorker.ready.then(function(registration) {
              emit2("ready", registration);
            }).catch(function(error) {
              return handleError(emit2, error);
            });
          } else {
            registerValidSW(swUrl, emit2, registrationOptions);
            navigator.serviceWorker.ready.then(function(registration) {
              emit2("ready", registration);
            }).catch(function(error) {
              return handleError(emit2, error);
            });
          }
        });
      }
    };
    function handleError(emit2, error) {
      if (!navigator.onLine) {
        emit2("offline");
      }
      emit2("error", error);
    }
    function registerValidSW(swUrl, emit2, registrationOptions) {
      navigator.serviceWorker.register(swUrl, registrationOptions).then(function(registration) {
        emit2("registered", registration);
        if (registration.waiting) {
          emit2("updated", registration);
          return;
        }
        registration.onupdatefound = function() {
          emit2("updatefound", registration);
          var installingWorker = registration.installing;
          installingWorker.onstatechange = function() {
            if (installingWorker.state === "installed") {
              if (navigator.serviceWorker.controller) {
                emit2("updated", registration);
              } else {
                emit2("cached", registration);
              }
            }
          };
        };
      }).catch(function(error) {
        return handleError(emit2, error);
      });
    }
    function checkValidServiceWorker(swUrl, emit2, registrationOptions) {
      fetch(swUrl).then(function(response) {
        if (response.status === 404) {
          emit2("error", new Error("Service worker not found at " + swUrl));
          unregister();
        } else if (response.headers.get("content-type").indexOf("javascript") === -1) {
          emit2("error", new Error("Expected " + swUrl + " to have javascript content-type, but received " + response.headers.get("content-type")));
          unregister();
        } else {
          registerValidSW(swUrl, emit2, registrationOptions);
        }
      }).catch(function(error) {
        return handleError(emit2, error);
      });
    }
    exports.unregister = function unregister2() {
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.ready.then(function(registration) {
          registration.unregister();
        }).catch(function(error) {
          return handleError(emit, error);
        });
      }
    };
  }
});

// node_modules/@tkey/common-types/dist/lib.esm/baseTypes/commonTypes.js
var KeyType = function(KeyType2) {
  KeyType2["secp256k1"] = "secp256k1";
  KeyType2["ed25519"] = "ed25519";
  return KeyType2;
}({});

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/enums.js
var LOGIN = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  REDDIT: "reddit",
  DISCORD: "discord",
  TWITCH: "twitch",
  APPLE: "apple",
  GITHUB: "github",
  LINKEDIN: "linkedin",
  TWITTER: "twitter",
  WEIBO: "weibo",
  LINE: "line",
  EMAIL_PASSWORD: "email_password",
  PASSWORDLESS: "passwordless",
  EMAIL_PASSWORDLESS: "email_passwordless",
  SMS_PASSWORDLESS: "sms_passwordless",
  JWT: "jwt",
  PASSKEYS: "passkeys"
};
var AGGREGATE_VERIFIER = {
  SINGLE_VERIFIER_ID: "single_id_verifier"
  // AND_AGGREGATE_VERIFIER : "and_aggregate_verifier",
  // OR_AGGREGATE_VERIFIER : "or_aggregate_verifier",
};
var UX_MODE = {
  POPUP: "popup",
  REDIRECT: "redirect"
};
var REDIRECT_PARAMS_STORAGE_METHOD = {
  LOCAL_STORAGE: "localStorage",
  SESSION_STORAGE: "sessionStorage",
  SERVER: "server"
};
var TORUS_METHOD = {
  TRIGGER_LOGIN: "triggerLogin",
  TRIGGER_AGGREGATE_LOGIN: "triggerAggregateLogin"
};
var SENTRY_TXNS = {
  FETCH_NODE_DETAILS: "fetchNodeDetails",
  PUB_ADDRESS_LOOKUP: "pubAddressLookup",
  FETCH_SHARES: "fetchShares"
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/DiscordHandler.js
var import_deepmerge = __toESM(require_cjs());

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/AbstractLoginHandler.js
var import_base64url2 = __toESM(require_base64url());

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/helpers.js
var import_base64url = __toESM(require_base64url());

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/loglevel.js
var import_loglevel = __toESM(require_loglevel());
var log = import_loglevel.default.getLogger("customauth");

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/helpers.js
var loginToConnectionMap = {
  [LOGIN.APPLE]: "apple",
  [LOGIN.GITHUB]: "github",
  [LOGIN.LINKEDIN]: "linkedin",
  [LOGIN.TWITTER]: "twitter",
  [LOGIN.WEIBO]: "weibo",
  [LOGIN.LINE]: "line",
  [LOGIN.EMAIL_PASSWORD]: "Username-Password-Authentication",
  [LOGIN.PASSWORDLESS]: "email",
  [LOGIN.EMAIL_PASSWORDLESS]: "email",
  [LOGIN.SMS_PASSWORDLESS]: "sms"
};
var padUrlString = (url) => url.href.endsWith("/") ? url.href : `${url.href}/`;
var randomId = () => Math.random().toString(36).slice(2);
var broadcastChannelOptions = {
  // type: 'localstorage', // (optional) enforce a type, oneOf['native', 'idb', 'localstorage', 'node']
  webWorkerSupport: false
  // (optional) set this to false if you know that your channel will never be used in a WebWorker (increases performance)
};
function caseSensitiveField(field, isCaseSensitive) {
  return isCaseSensitive ? field : field.toLowerCase();
}
var getVerifierId = (userInfo, typeOfLogin, verifierIdField, isVerifierIdCaseSensitive = true) => {
  const {
    name,
    sub
  } = userInfo;
  if (verifierIdField) return caseSensitiveField(userInfo[verifierIdField], isVerifierIdCaseSensitive);
  switch (typeOfLogin) {
    case LOGIN.PASSWORDLESS:
    case LOGIN.EMAIL_PASSWORD:
    case LOGIN.EMAIL_PASSWORDLESS:
    case LOGIN.SMS_PASSWORDLESS:
      return caseSensitiveField(name, isVerifierIdCaseSensitive);
    case LOGIN.WEIBO:
    case LOGIN.GITHUB:
    case LOGIN.TWITTER:
    case LOGIN.APPLE:
    case LOGIN.LINKEDIN:
    case LOGIN.LINE:
    case LOGIN.JWT:
      return caseSensitiveField(sub, isVerifierIdCaseSensitive);
    default:
      throw new Error("Invalid login type to get verifier id");
  }
};
var handleRedirectParameters = (hash, queryParameters) => {
  const hashParameters = hash.split("&").reduce((result, item) => {
    const [part0, part1] = item.split("=");
    result[part0] = part1;
    return result;
  }, {});
  log.info(hashParameters, queryParameters);
  let instanceParameters = {};
  let error = "";
  if (Object.keys(hashParameters).length > 0 && hashParameters.state) {
    instanceParameters = JSON.parse(import_base64url.default.decode(decodeURIComponent(decodeURIComponent(hashParameters.state)))) || {};
    error = hashParameters.error_description || hashParameters.error || error;
  } else if (Object.keys(queryParameters).length > 0 && queryParameters.state) {
    instanceParameters = JSON.parse(import_base64url.default.decode(decodeURIComponent(decodeURIComponent(queryParameters.state)))) || {};
    if (queryParameters.error) error = queryParameters.error;
  }
  return {
    error,
    instanceParameters,
    hashParameters
  };
};
function storageAvailable(type) {
  let storage;
  try {
    storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (error) {
    const e = error;
    return e && // everything except Firefox
    (e.code === 22 || // Firefox
    e.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    e.name === "QuotaExceededError" || // Firefox
    e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0;
  }
}
function getPopupFeatures() {
  const dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screenX;
  const dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screenY;
  const w = 1200;
  const h = 700;
  const width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  const height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  const systemZoom = 1;
  const left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  const top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  const features = `titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=${h / systemZoom},width=${w / systemZoom},top=${top},left=${left}`;
  return features;
}
var isFirefox = () => {
  var _window;
  return ((_window = window) === null || _window === void 0 || (_window = _window.navigator) === null || _window === void 0 ? void 0 : _window.userAgent.toLowerCase().indexOf("firefox")) > -1 || false;
};
function constructURL(params) {
  const {
    baseURL,
    query,
    hash
  } = params;
  const url = new URL(baseURL);
  if (query) {
    Object.keys(query).forEach((key) => {
      url.searchParams.append(key, query[key]);
    });
  }
  if (hash) {
    const h = new URL(constructURL({
      baseURL,
      query: hash
    })).searchParams.toString();
    url.hash = h;
  }
  return url.toString();
}
function are3PCSupported() {
  var _navigator;
  const browserInfo = bowser_default.parse(navigator.userAgent);
  log.info(JSON.stringify(browserInfo), "current browser info");
  let thirdPartyCookieSupport = true;
  if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.brave) {
    thirdPartyCookieSupport = false;
  }
  if (browserInfo.engine.name === bowser_default.ENGINE_MAP.WebKit || browserInfo.engine.name === bowser_default.ENGINE_MAP.Gecko) {
    thirdPartyCookieSupport = false;
  }
  return thirdPartyCookieSupport;
}
var validateAndConstructUrl = (domain) => {
  try {
    const url = new URL(decodeURIComponent(domain));
    return url;
  } catch (error) {
    throw new Error(`${(error === null || error === void 0 ? void 0 : error.message) || ""}, Note: Your jwt domain: (i.e ${domain}) must have http:// or https:// prefix`);
  }
};
function isMobileOrTablet() {
  const browser = bowser_default.getParser(navigator.userAgent);
  const platform = browser.getPlatform();
  return platform.type === bowser_default.PLATFORMS_MAP.tablet || platform.type === bowser_default.PLATFORMS_MAP.mobile;
}
function getTimeout(typeOfLogin) {
  if ((typeOfLogin === LOGIN.FACEBOOK || typeOfLogin === LOGIN.LINE) && isMobileOrTablet()) {
    return 1e3 * 60;
  }
  return 1e3 * 10;
}
function decodeToken(token) {
  const [header, payload] = token.split(".");
  return {
    header: JSON.parse(import_base64url.default.decode(header)),
    payload: JSON.parse(import_base64url.default.decode(payload))
  };
}

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/PopupHandler.js
var import_events = __toESM(require_events());
var PopupHandler = class extends import_events.EventEmitter {
  constructor({
    url,
    target,
    features,
    timeout = 3e4
  }) {
    super();
    _defineProperty(this, "url", void 0);
    _defineProperty(this, "target", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "window", void 0);
    _defineProperty(this, "windowTimer", void 0);
    _defineProperty(this, "iClosedWindow", void 0);
    _defineProperty(this, "timeout", void 0);
    this.url = url;
    this.target = target || "_blank";
    this.features = features || getPopupFeatures();
    this.window = void 0;
    this.windowTimer = void 0;
    this.iClosedWindow = false;
    this.timeout = timeout;
    this._setupTimer();
  }
  _setupTimer() {
    this.windowTimer = Number(setInterval(() => {
      if (this.window && this.window.closed) {
        clearInterval(this.windowTimer);
        setTimeout(() => {
          if (!this.iClosedWindow) {
            this.emit("close");
          }
          this.iClosedWindow = false;
          this.window = void 0;
        }, this.timeout);
      }
      if (this.window === void 0) clearInterval(this.windowTimer);
    }, 500));
  }
  open() {
    var _this$window;
    this.window = window.open(this.url.href, this.target, this.features);
    if (!this.window) throw new Error("popup window is blocked");
    if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
    return Promise.resolve();
  }
  close() {
    this.iClosedWindow = true;
    if (this.window) this.window.close();
  }
  redirect(locationReplaceOnRedirect) {
    if (locationReplaceOnRedirect) {
      window.location.replace(this.url.href);
    } else {
      window.location.href = this.url.href;
    }
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/AbstractLoginHandler.js
var _excluded = ["access_token", "id_token"];
var AbstractLoginHandler = class {
  // Not using object constructor because of this issue
  // https://github.com/microsoft/TypeScript/issues/5326
  constructor(params) {
    _defineProperty(this, "nonce", randomId());
    _defineProperty(this, "finalURL", void 0);
    _defineProperty(this, "params", void 0);
    this.params = params;
  }
  get state() {
    return encodeURIComponent(import_base64url2.default.encode(JSON.stringify(_objectSpread2(_objectSpread2({}, this.params.customState || {}), {}, {
      instanceId: this.nonce,
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin,
      redirectToOpener: this.params.redirectToOpener || false
    }))));
  }
  async handleLoginWindow(params) {
    const verifierWindow = new PopupHandler({
      url: this.finalURL,
      features: params.popupFeatures,
      timeout: getTimeout(this.params.typeOfLogin)
    });
    if (this.params.uxMode === UX_MODE.REDIRECT) {
      verifierWindow.redirect(params.locationReplaceOnRedirect);
    } else {
      const {
        BroadcastChannel
      } = await import("./lib-4NJ4IY2F.js");
      return new Promise((resolve, reject) => {
        let bc;
        const handleData = async (ev) => {
          try {
            const {
              error,
              data
            } = ev;
            const _ref = data || {}, {
              instanceParams,
              hashParams: {
                access_token: accessToken,
                id_token: idToken
              }
            } = _ref, rest = _objectWithoutProperties(_ref.hashParams, _excluded);
            if (error) {
              log.error(ev);
              reject(new Error(`Error: ${error}. Info: ${JSON.stringify(ev.data || {})}`));
              return;
            }
            if (ev.data && instanceParams.verifier === this.params.verifier) {
              log.info(ev.data);
              if (!this.params.redirectToOpener && bc) await bc.postMessage({
                success: true
              });
              resolve(_objectSpread2(_objectSpread2({
                accessToken,
                idToken: idToken || ""
              }, rest), {}, {
                // State has to be last here otherwise it will be overwritten
                state: instanceParams
              }));
            }
          } catch (error) {
            log.error(error);
            reject(error);
          }
        };
        if (!this.params.redirectToOpener) {
          bc = new BroadcastChannel(`redirect_channel_${this.nonce}`, broadcastChannelOptions);
          bc.addEventListener("message", async (ev) => {
            await handleData(ev);
            bc.close();
            verifierWindow.close();
          });
        } else {
          const postMessageEventHandler = async (postMessageEvent) => {
            if (!postMessageEvent.data) return;
            const ev = postMessageEvent.data;
            if (ev.channel !== `redirect_channel_${this.nonce}`) return;
            window.removeEventListener("message", postMessageEventHandler);
            handleData(ev);
            verifierWindow.close();
          };
          window.addEventListener("message", postMessageEventHandler);
        }
        try {
          verifierWindow.open();
        } catch (error) {
          log.error(error);
          reject(error);
          return;
        }
        verifierWindow.once("close", () => {
          if (bc) bc.close();
          reject(new Error("user closed popup"));
        });
      });
    }
    return null;
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/DiscordHandler.js
var DiscordHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token");
    _defineProperty(this, "SCOPE", "identify email");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://discord.com/api/oauth2/authorize");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = (0, import_deepmerge.default)({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE
    }, clonedParams);
    Object.keys(finalJwtParams).forEach((key) => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://discord.com/api/users/@me", {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });
    const {
      id,
      avatar,
      email = "",
      username: name = "",
      discriminator = ""
    } = userInfo;
    const profileImage = avatar === null ? `https://cdn.discordapp.com/embed/avatars/${Number(discriminator) % 5}.png` : `https://cdn.discordapp.com/avatars/${id}/${avatar}.png?size=2048`;
    return {
      profileImage,
      name: `${name}#${discriminator}`,
      email,
      verifierId: id,
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin
    };
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/FacebookHandler.js
var import_deepmerge2 = __toESM(require_cjs());
var FacebookHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token");
    _defineProperty(this, "SCOPE", "public_profile email");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://www.facebook.com/v20.0/dialog/oauth");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = (0, import_deepmerge2.default)({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE
    }, clonedParams);
    Object.keys(finalJwtParams).forEach((key) => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://graph.facebook.com/me?fields=name,email,picture.type(large)", {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });
    const {
      name = "",
      id,
      picture,
      email = ""
    } = userInfo;
    return {
      email,
      name,
      profileImage: picture.data.url || "",
      verifier: this.params.verifier,
      verifierId: id,
      typeOfLogin: this.params.typeOfLogin
    };
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/GoogleHandler.js
var import_deepmerge3 = __toESM(require_cjs());
var GoogleHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "SCOPE", "profile email openid");
    _defineProperty(this, "PROMPT", "select_account");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://accounts.google.com/o/oauth2/v2/auth");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = (0, import_deepmerge3.default)({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      prompt: this.PROMPT,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE,
      nonce: this.nonce
    }, clonedParams);
    Object.keys(finalJwtParams).forEach((key) => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://www.googleapis.com/userinfo/v2/me", {
      headers: {
        Authorization: `Bearer ${accessToken}`
      }
    });
    const {
      picture: profileImage = "",
      email = "",
      name = ""
    } = userInfo;
    return {
      email,
      name,
      profileImage,
      verifier: this.params.verifier,
      verifierId: email.toLowerCase(),
      typeOfLogin: this.params.typeOfLogin
    };
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/JwtHandler.js
var import_deepmerge4 = __toESM(require_cjs());
var import_loglevel4 = __toESM(require_loglevel());
var JwtHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "SCOPE", "openid profile email");
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "PROMPT", "login");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      domain
    } = this.params.jwtParams;
    const finalUrl = validateAndConstructUrl(domain);
    finalUrl.pathname += finalUrl.pathname.endsWith("/") ? "authorize" : "/authorize";
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams));
    delete clonedParams.domain;
    const finalJwtParams = (0, import_deepmerge4.default)({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      prompt: this.PROMPT,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE,
      connection: loginToConnectionMap[this.params.typeOfLogin],
      nonce: this.nonce
    }, clonedParams);
    Object.keys(finalJwtParams).forEach((key) => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      idToken,
      accessToken
    } = params;
    const {
      domain,
      verifierIdField,
      isVerifierIdCaseSensitive,
      user_info_route = "userinfo"
    } = this.params.jwtParams;
    if (accessToken) {
      try {
        const domainUrl = new URL(domain);
        const userInfo = await get(`${padUrlString(domainUrl)}${user_info_route}`, {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        });
        const {
          picture,
          name,
          email
        } = userInfo;
        return {
          email,
          name,
          profileImage: picture,
          verifierId: getVerifierId(userInfo, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
          verifier: this.params.verifier,
          typeOfLogin: this.params.typeOfLogin
        };
      } catch (error) {
        import_loglevel4.default.warn(error, "Unable to get userinfo from endpoint");
      }
    }
    if (idToken) {
      const decodedToken = decodeToken(idToken).payload;
      const {
        name,
        email,
        picture
      } = decodedToken;
      return {
        profileImage: picture,
        name,
        email,
        verifierId: getVerifierId(decodedToken, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    }
    throw new Error("Access/id token not available");
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/MockLoginHandler.js
var import_deepmerge5 = __toESM(require_cjs());
var import_loglevel5 = __toESM(require_loglevel());
var MockLoginHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    this.setFinalUrl();
  }
  setFinalUrl() {
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams));
    delete clonedParams.domain;
    const finalJwtParams = (0, import_deepmerge5.default)({
      state: this.state,
      client_id: this.params.clientId,
      nonce: this.nonce
    }, clonedParams);
    this.finalURL = new URL(constructURL({
      baseURL: this.params.redirect_uri,
      query: null,
      hash: finalJwtParams
    }));
  }
  async getUserInfo(params) {
    const {
      idToken,
      accessToken
    } = params;
    const {
      domain,
      verifierIdField,
      isVerifierIdCaseSensitive,
      user_info_route = "userinfo"
    } = this.params.jwtParams;
    if (accessToken) {
      try {
        const domainUrl = new URL(domain);
        const userInfo = await get(`${padUrlString(domainUrl)}${user_info_route}`, {
          headers: {
            Authorization: `Bearer ${accessToken}`
          }
        });
        const {
          picture,
          name,
          email
        } = userInfo;
        return {
          email,
          name,
          profileImage: picture,
          verifierId: getVerifierId(userInfo, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
          verifier: this.params.verifier,
          typeOfLogin: this.params.typeOfLogin
        };
      } catch (error) {
        import_loglevel5.default.warn(error, "Unable to get userinfo from endpoint");
      }
    }
    if (idToken) {
      const decodedToken = decodeToken(idToken).payload;
      const {
        name,
        email,
        picture
      } = decodedToken;
      return {
        profileImage: picture,
        name,
        email,
        verifierId: getVerifierId(decodedToken, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    }
    throw new Error("Access/id token not available");
  }
  handleLoginWindow(params) {
    const {
      id_token: idToken,
      access_token: accessToken
    } = this.params.jwtParams;
    const verifierWindow = new PopupHandler({
      url: this.finalURL,
      features: params.popupFeatures
    });
    if (this.params.uxMode === UX_MODE.REDIRECT) {
      verifierWindow.redirect(params.locationReplaceOnRedirect);
    } else {
      return Promise.resolve({
        state: {},
        idToken,
        accessToken
      });
    }
    return null;
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/PasskeysHandler.js
var import_base64url3 = __toESM(require_base64url());
var import_deepmerge6 = __toESM(require_cjs());

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/sessionHelper.js
var import_loglevel6 = __toESM(require_loglevel());
async function fetchDataFromBroadcastServer(identifier, storageServerUrl) {
  try {
    const configManager = new SessionManager({
      sessionId: identifier,
      sessionServerBaseUrl: storageServerUrl,
      allowedOrigin: true
    });
    const data = await configManager.authorizeSession();
    return data;
  } catch (error) {
    import_loglevel6.default.error("fetch data from storage server error", error);
    throw new Error("Unable to retrieve data from storage server, invalid key or key expired.");
  }
}

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/PasskeysHandler.js
var PasskeysHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      passkeysHostUrl
    } = this.params.customState || {};
    if (!passkeysHostUrl) throw new Error("Invalid passkeys url.");
    const finalUrl = new URL(passkeysHostUrl);
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = (0, import_deepmerge6.default)({
      state: this.state,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri
    }, clonedParams);
    Object.keys(finalJwtParams).forEach((key) => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(parameters, storageServerUrl) {
    const {
      idToken,
      extraParams
    } = parameters;
    const {
      sessionId
    } = JSON.parse(import_base64url3.default.decode(extraParams)) || {};
    if (!sessionId) {
      throw new Error("sessionId not found");
    }
    const {
      verifier_id: verifierId,
      signature,
      clientDataJSON,
      authenticatorData,
      publicKey,
      challenge,
      rpOrigin,
      rpId,
      credId,
      transports,
      username
    } = await fetchDataFromBroadcastServer(sessionId, storageServerUrl);
    if (signature !== idToken) {
      throw new Error("idtoken should be equal to signature");
    }
    return {
      email: "",
      name: "Passkeys Login",
      profileImage: "",
      verifier: this.params.verifier,
      verifierId,
      typeOfLogin: this.params.typeOfLogin,
      extraVerifierParams: {
        signature,
        clientDataJSON,
        authenticatorData,
        publicKey,
        challenge,
        rpOrigin,
        rpId,
        credId,
        transports,
        username
      }
    };
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/PasswordlessHandler.js
var import_deepmerge7 = __toESM(require_cjs());
var _excluded2 = ["access_token", "id_token"];
var PasswordlessHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "SCOPE", "openid profile email");
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "PROMPT", "login");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      domain
    } = this.params.jwtParams;
    const domainUrl = validateAndConstructUrl(domain);
    domainUrl.pathname = "/passwordless/start";
    this.finalURL = domainUrl;
  }
  async getUserInfo(params) {
    const {
      idToken,
      accessToken
    } = params;
    const {
      domain,
      verifierIdField,
      isVerifierIdCaseSensitive
    } = this.params.jwtParams;
    try {
      const domainUrl = new URL(domain);
      const userInfo = await get(`${padUrlString(domainUrl)}userinfo`, {
        headers: {
          Authorization: `Bearer ${accessToken}`
        }
      });
      const {
        picture,
        name,
        email
      } = userInfo;
      return {
        email,
        name,
        profileImage: picture,
        verifierId: getVerifierId(userInfo, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    } catch (error) {
      log.error(error);
      const decodedToken = decodeToken(idToken).payload;
      const {
        name,
        email,
        picture
      } = decodedToken;
      return {
        profileImage: picture,
        name,
        email,
        verifierId: getVerifierId(decodedToken, this.params.typeOfLogin, verifierIdField, isVerifierIdCaseSensitive),
        verifier: this.params.verifier,
        typeOfLogin: this.params.typeOfLogin
      };
    }
  }
  async handleLoginWindow() {
    const {
      BroadcastChannel
    } = await import("./lib-4NJ4IY2F.js");
    return new Promise((resolve, reject) => {
      if (this.params.redirectToOpener) {
        reject(new Error("Cannot use redirect to opener for passwordless"));
        return;
      }
      const handleData = (ev) => {
        try {
          const {
            error,
            data
          } = ev;
          const _ref = data || {}, {
            instanceParams,
            hashParams: {
              access_token: accessToken,
              id_token: idToken
            }
          } = _ref, rest = _objectWithoutProperties(_ref.hashParams, _excluded2);
          if (error) {
            log.error(ev.error);
            reject(new Error(error));
            return;
          }
          if (ev.data && instanceParams.verifier === this.params.verifier) {
            log.info(ev.data);
            resolve(_objectSpread2(_objectSpread2({
              accessToken,
              idToken: idToken || ""
            }, rest), {}, {
              state: instanceParams
            }));
          }
        } catch (error) {
          log.error(error);
          reject(error);
        }
      };
      const bc = new BroadcastChannel(`redirect_channel_${this.nonce}`, broadcastChannelOptions);
      bc.addEventListener("message", async (ev) => {
        handleData(ev);
        bc.close();
      });
      try {
        const {
          connection = "email",
          login_hint
        } = this.params.jwtParams;
        const finalJwtParams = (0, import_deepmerge7.default)({
          client_id: this.params.clientId,
          connection,
          email: connection === "email" ? login_hint : void 0,
          phone_number: connection === "sms" ? login_hint : void 0,
          send: "link",
          authParams: {
            scope: this.SCOPE,
            state: this.state,
            response_type: this.RESPONSE_TYPE,
            redirect_uri: this.params.redirect_uri,
            nonce: this.nonce,
            prompt: this.PROMPT
          }
        }, {
          authParams: this.params.jwtParams
        });
        post(this.finalURL.href, JSON.parse(JSON.stringify(finalJwtParams))).then((response) => {
          log.info("posted", response);
          return void 0;
        }).catch((error) => {
          log.error(error);
          reject(error);
        });
      } catch (error) {
        log.error(error);
        reject(error);
      }
    });
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/TwitchHandler.js
var import_deepmerge8 = __toESM(require_cjs());
var TwitchHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "RESPONSE_TYPE", "token");
    _defineProperty(this, "SCOPE", "user:read:email");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const finalUrl = new URL("https://id.twitch.tv/oauth2/authorize");
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    const finalJwtParams = (0, import_deepmerge8.default)({
      state: this.state,
      response_type: this.RESPONSE_TYPE,
      client_id: this.params.clientId,
      redirect_uri: this.params.redirect_uri,
      scope: this.SCOPE,
      force_verify: "true"
    }, clonedParams);
    Object.keys(finalJwtParams).forEach((key) => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      accessToken
    } = params;
    const userInfo = await get("https://api.twitch.tv/helix/users", {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "Client-ID": this.params.clientId
      }
    });
    const [{
      profile_image_url: profileImage = "",
      display_name: name = "",
      email = "",
      id: verifierId
    }] = userInfo.data || [];
    return {
      profileImage,
      name,
      email,
      verifierId,
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin
    };
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/Web3AuthPasswordlessHandler.js
var import_deepmerge9 = __toESM(require_cjs());

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/interfaces.js
var EMAIL_FLOW = {
  link: "link",
  code: "code"
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/Web3AuthPasswordlessHandler.js
var Web3AuthPasswordlessHandler = class extends AbstractLoginHandler {
  constructor(params) {
    super(params);
    _defineProperty(this, "SCOPE", "openid profile email");
    _defineProperty(this, "RESPONSE_TYPE", "token id_token");
    _defineProperty(this, "PROMPT", "login");
    this.setFinalUrl();
  }
  setFinalUrl() {
    const {
      domain
    } = this.params.jwtParams || {};
    const finalUrl = validateAndConstructUrl(domain || "https://passwordless.web3auth.io/v6");
    finalUrl.pathname += finalUrl.pathname.endsWith("/") ? "authorize" : "/authorize";
    const clonedParams = JSON.parse(JSON.stringify(this.params.jwtParams || {}));
    delete clonedParams.domain;
    this.params.customState = _objectSpread2(_objectSpread2({}, this.params.customState || {}), {}, {
      client: this.params.web3AuthClientId
    });
    const finalJwtParams = (0, import_deepmerge9.default)({
      state: this.state,
      client_id: this.params.clientId || this.params.web3AuthClientId,
      redirect_uri: this.params.redirect_uri,
      nonce: this.nonce,
      network: this.params.web3AuthNetwork,
      connection: loginToConnectionMap[this.params.typeOfLogin],
      scope: this.SCOPE,
      response_type: this.RESPONSE_TYPE,
      prompt: this.PROMPT,
      flow_type: (clonedParams === null || clonedParams === void 0 ? void 0 : clonedParams.flow_type) || EMAIL_FLOW.code
    }, clonedParams);
    Object.keys(finalJwtParams).forEach((key) => {
      const localKey = key;
      if (finalJwtParams[localKey]) finalUrl.searchParams.append(localKey, finalJwtParams[localKey]);
    });
    this.finalURL = finalUrl;
  }
  async getUserInfo(params) {
    const {
      idToken
    } = params;
    const decodedToken = decodeToken(idToken).payload;
    const {
      name,
      email,
      picture
    } = decodedToken;
    return {
      profileImage: picture,
      name,
      email,
      verifierId: name.toLowerCase(),
      verifier: this.params.verifier,
      typeOfLogin: this.params.typeOfLogin
    };
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/handlers/HandlerFactory.js
var createHandler = (params) => {
  const {
    verifier,
    typeOfLogin,
    clientId,
    jwtParams
  } = params;
  if (!verifier || !typeOfLogin || !clientId) {
    throw new Error("Invalid params. Missing verifier, typeOfLogin or clientId");
  }
  const {
    domain,
    login_hint,
    id_token,
    access_token
  } = jwtParams || {};
  switch (typeOfLogin) {
    case LOGIN.GOOGLE:
      return new GoogleHandler(params);
    case LOGIN.FACEBOOK:
      return new FacebookHandler(params);
    case LOGIN.TWITCH:
      return new TwitchHandler(params);
    case LOGIN.DISCORD:
      return new DiscordHandler(params);
    case LOGIN.EMAIL_PASSWORDLESS:
    case LOGIN.SMS_PASSWORDLESS:
      if (!login_hint) throw new Error("Invalid params. Missing login_hint for web3auth passwordless login");
      return new Web3AuthPasswordlessHandler(params);
    case LOGIN.PASSWORDLESS:
      if (!domain || !login_hint) throw new Error("Invalid params. Missing domain or login_hint for passwordless login");
      return new PasswordlessHandler(params);
    case LOGIN.APPLE:
    case LOGIN.GITHUB:
    case LOGIN.LINKEDIN:
    case LOGIN.TWITTER:
    case LOGIN.WEIBO:
    case LOGIN.LINE:
    case LOGIN.EMAIL_PASSWORD:
    case LOGIN.JWT:
    case LOGIN.REDDIT:
      if (id_token || access_token) {
        return new MockLoginHandler(params);
      }
      if (!domain) throw new Error("Invalid params for jwt login. Missing domain");
      return new JwtHandler(params);
    case LOGIN.PASSKEYS:
      return new PasskeysHandler(params);
    default:
      throw new Error("Unsupported login type");
  }
};
var createHandler$1 = createHandler;

// node_modules/@toruslabs/fetch-node-details/node_modules/@toruslabs/constants/dist/lib.esm/constants.js
var TORUS_LEGACY_NETWORK = {
  MAINNET: "mainnet",
  TESTNET: "testnet",
  CYAN: "cyan",
  AQUA: "aqua",
  CELESTE: "celeste"
};
var TORUS_SAPPHIRE_NETWORK = {
  SAPPHIRE_DEVNET: "sapphire_devnet",
  SAPPHIRE_MAINNET: "sapphire_mainnet"
};
var PROXY_CONTRACT_ADDRESS = {
  [TORUS_LEGACY_NETWORK.MAINNET]: "0xf20336e16B5182637f09821c27BDe29b0AFcfe80",
  [TORUS_LEGACY_NETWORK.TESTNET]: "0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A",
  [TORUS_LEGACY_NETWORK.CYAN]: "0x9f072ba19b3370e512aa1b4bfcdaf97283168005",
  [TORUS_LEGACY_NETWORK.AQUA]: "0x29Dea82a0509153b91040ee13cDBba0f03efb625",
  [TORUS_LEGACY_NETWORK.CELESTE]: "0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c"
};
var MULTI_CLUSTER_NETWORKS = [
  // TORUS_LEGACY_NETWORK.AQUA,
  // TORUS_LEGACY_NETWORK.CELESTE,
  // TORUS_LEGACY_NETWORK.CYAN,
];
var LEGACY_NETWORKS_ROUTE_MAP = {
  [TORUS_LEGACY_NETWORK.AQUA]: {
    migrationCompleted: true,
    networkIdentifier: "aqua",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.CELESTE]: {
    migrationCompleted: true,
    networkIdentifier: "celeste",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.CYAN]: {
    migrationCompleted: true,
    networkIdentifier: "cyan",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.MAINNET]: {
    migrationCompleted: true,
    networkIdentifier: "mainnet",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.TESTNET]: {
    migrationCompleted: true,
    networkIdentifier: "teal",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET
  }
};
var NETWORK_MAP = {
  [TORUS_LEGACY_NETWORK.MAINNET]: "mainnet",
  [TORUS_LEGACY_NETWORK.TESTNET]: "goerli",
  [TORUS_LEGACY_NETWORK.CYAN]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK.AQUA]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK.CELESTE]: "polygon-mainnet"
};
var SIGNER_MAP = {
  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: "https://signer.web3auth.io",
  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK.MAINNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK.TESTNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK.CYAN]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK.AQUA]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK.CELESTE]: "https://signer-polygon.web3auth.io"
};
var METADATA_MAP = {
  [TORUS_LEGACY_NETWORK.MAINNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.TESTNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.CYAN]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.AQUA]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.CELESTE]: "https://metadata.web3auth.io"
};
var FND_SERVER = "https://fnd.web3auth.io";
var KEY_TYPE = {
  SECP256K1: "secp256k1",
  ED25519: "ed25519"
};

// node_modules/@toruslabs/fnd-base/node_modules/@toruslabs/constants/dist/lib.esm/constants.js
var TORUS_LEGACY_NETWORK2 = {
  MAINNET: "mainnet",
  TESTNET: "testnet",
  CYAN: "cyan",
  AQUA: "aqua",
  CELESTE: "celeste"
};
var TORUS_SAPPHIRE_NETWORK2 = {
  SAPPHIRE_DEVNET: "sapphire_devnet",
  SAPPHIRE_MAINNET: "sapphire_mainnet"
};
var PROXY_CONTRACT_ADDRESS2 = {
  [TORUS_LEGACY_NETWORK2.MAINNET]: "0xf20336e16B5182637f09821c27BDe29b0AFcfe80",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A",
  [TORUS_LEGACY_NETWORK2.CYAN]: "0x9f072ba19b3370e512aa1b4bfcdaf97283168005",
  [TORUS_LEGACY_NETWORK2.AQUA]: "0x29Dea82a0509153b91040ee13cDBba0f03efb625",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c"
};
var LEGACY_NETWORKS_ROUTE_MAP2 = {
  [TORUS_LEGACY_NETWORK2.AQUA]: {
    migrationCompleted: true,
    networkIdentifier: "aqua",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.CELESTE]: {
    migrationCompleted: true,
    networkIdentifier: "celeste",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.CYAN]: {
    migrationCompleted: true,
    networkIdentifier: "cyan",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.MAINNET]: {
    migrationCompleted: true,
    networkIdentifier: "mainnet",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.TESTNET]: {
    migrationCompleted: true,
    networkIdentifier: "teal",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_DEVNET
  }
};
var NETWORK_MAP2 = {
  [TORUS_LEGACY_NETWORK2.MAINNET]: "mainnet",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "goerli",
  [TORUS_LEGACY_NETWORK2.CYAN]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK2.AQUA]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "polygon-mainnet"
};
var SIGNER_MAP2 = {
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET]: "https://signer.web3auth.io",
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_DEVNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK2.MAINNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CYAN]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK2.AQUA]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "https://signer-polygon.web3auth.io"
};
var METADATA_MAP2 = {
  [TORUS_LEGACY_NETWORK2.MAINNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CYAN]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.AQUA]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "https://metadata.web3auth.io"
};
var KEY_TYPE2 = {
  SECP256K1: "secp256k1",
  ED25519: "ed25519"
};

// node_modules/@toruslabs/fnd-base/dist/lib.esm/endpoints.js
var SAPPHIRE_NETWORK_URLS = {
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_DEVNET]: ["https://node-1.dev-node.web3auth.io", "https://node-2.dev-node.web3auth.io", "https://node-3.dev-node.web3auth.io", "https://node-4.dev-node.web3auth.io", "https://node-5.dev-node.web3auth.io"],
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET]: ["https://node-1.node.web3auth.io", "https://node-2.node.web3auth.io", "https://node-3.node.web3auth.io", "https://node-4.node.web3auth.io", "https://node-5.node.web3auth.io"]
};
var getSSSEndpoints = (sapphireNetwork, legacyNetwork) => {
  const endpoints = SAPPHIRE_NETWORK_URLS[sapphireNetwork];
  if (!endpoints || endpoints.length === 0) {
    throw new Error(`Unsupported network: ${sapphireNetwork}`);
  }
  const routeIdentifier = LEGACY_NETWORKS_ROUTE_MAP2[legacyNetwork];
  return endpoints.map((e) => {
    if (routeIdentifier && routeIdentifier.networkIdentifier) {
      return `${e}/sss/${routeIdentifier.networkIdentifier}/jrpc`;
    }
    return `${e}/sss/jrpc`;
  });
};
var getRSSEndpoints = (sapphireNetwork, legacyNetwork) => {
  const endpoints = SAPPHIRE_NETWORK_URLS[sapphireNetwork];
  if (!endpoints || endpoints.length === 0) {
    throw new Error(`Unsupported network: ${sapphireNetwork}`);
  }
  const routeIdentifier = LEGACY_NETWORKS_ROUTE_MAP2[legacyNetwork];
  return endpoints.map((e) => {
    if (routeIdentifier && routeIdentifier.networkIdentifier) {
      return `${e}/rss/${routeIdentifier.networkIdentifier}`;
    }
    return `${e}/rss`;
  });
};
var getTSSEndpoints = (sapphireNetwork, legacyNetwork, keyType = KEY_TYPE2.SECP256K1) => {
  const endpoints = SAPPHIRE_NETWORK_URLS[sapphireNetwork];
  if (!endpoints || endpoints.length === 0) {
    throw new Error(`Unsupported network: ${sapphireNetwork}`);
  }
  const tssPath = keyType === KEY_TYPE2.ED25519 ? "tss-frost" : "tss";
  const routeIdentifier = LEGACY_NETWORKS_ROUTE_MAP2[legacyNetwork];
  return endpoints.map((e) => {
    if (routeIdentifier && routeIdentifier.networkIdentifier) {
      return `${e}/${tssPath}/${routeIdentifier.networkIdentifier}`;
    }
    return `${e}/${tssPath}`;
  });
};

// node_modules/@toruslabs/fnd-base/dist/lib.esm/pubKeys.js
var SAPPHIRE_NODE_PUB_KEYS = {
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET]: [{
    X: "e0925898fee0e9e941fdca7ee88deec99939ae9407e923535c4d4a3a3ff8b052",
    Y: "54b9fea924e3f3e40791f9987f4234ae4222412d65b74068032fa5d8b63375c1"
  }, {
    X: "9124cf1e280aab32ba50dffd2de81cecabc13d82d2c1fe9de82f3b3523f9b637",
    Y: "fca939a1ceb42ce745c55b21ef094f543b457630cb63a94ef4f1afeee2b1f107"
  }, {
    X: "555f681a63d469cc6c3a58a97e29ebd277425f0e6159708e7c7bf05f18f89476",
    Y: "606f2bcc0884fa5b64366fc3e8362e4939841b56acd60d5f4553cf36b891ac4e"
  }, {
    X: "2b5f58d8e340f1ab922e89b3a69a68930edfe51364644a456335e179bc130128",
    Y: "4b4daa05939426e3cbe7d08f0e773d2bf36f64c00d04620ee6df2a7af4d2247"
  }, {
    X: "3ecbb6a68afe72cf34ec6c0a12b5cb78a0d2e83ba402983b6adbc5f36219861a",
    Y: "dc1031c5cc8f0472bd521a62a64ebca9e163902c247bf05937daf4ae835091e4"
  }],
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_DEVNET]: [{
    X: "f74389b0a4c8d10d2a687ae575f69b20f412d41ab7f1fe6b358aa14871327247",
    Y: "54e3a73098ed9bced3ef8821736e9794f9264a1420c0c7ad15d2fa617ba35ef7"
  }, {
    X: "bc38813a6873e526087918507c78fc3a61624670ee851ecfb4f3bef55d027b5a",
    Y: "ac4b21229f662a0aefdfdac21cf17c3261a392c74a8790db218b34e3e4c1d56a"
  }, {
    X: "b56541684ea5fa40c8337b7688d502f0e9e092098962ad344c34e94f06d293fb",
    Y: "759a998cef79d389082f9a75061a29190eec0cac99b8c25ddcf6b58569dad55c"
  }, {
    X: "7bcb058d4c6ffc6ba4bfdfd93d141af35a66338a62c7c27cdad2ae3f8289b767",
    Y: "336ab1935e41ed4719e162587f0ab55518db4207a1eb36cc72303f1b86689d2b"
  }, {
    X: "bf12a136ef94399ea098f926f04e26a4ec4ac70f69cce274e8893704c4951773",
    Y: "bdd44828020f52ce510e026338216ada184a6867eb4e19fb4c2d495d4a7e15e4"
  }]
};

// node_modules/@toruslabs/fnd-base/dist/lib.esm/sapphireNetworkConfig.js
var getSapphireNodeDetails = (sapphireNetwork, legacyNetwork, keyType) => {
  return {
    currentEpoch: "1",
    torusNodeEndpoints: getSSSEndpoints(sapphireNetwork, legacyNetwork),
    torusNodeSSSEndpoints: getSSSEndpoints(sapphireNetwork, legacyNetwork),
    torusNodeRSSEndpoints: getRSSEndpoints(sapphireNetwork, legacyNetwork),
    torusNodeTSSEndpoints: getTSSEndpoints(sapphireNetwork, legacyNetwork, keyType),
    torusIndexes: [1, 2, 3, 4, 5],
    torusNodePub: SAPPHIRE_NODE_PUB_KEYS[sapphireNetwork]
  };
};

// node_modules/@toruslabs/fnd-base/dist/lib.esm/utils.js
function fetchLocalConfig(network, keyType) {
  if (Object.values(TORUS_SAPPHIRE_NETWORK2).includes(network)) {
    return getSapphireNodeDetails(network, void 0, keyType);
  }
  if (Object.values(TORUS_LEGACY_NETWORK2).includes(network)) {
    const legacyMap = LEGACY_NETWORKS_ROUTE_MAP2[network];
    if (legacyMap.migrationCompleted) return getSapphireNodeDetails(legacyMap.networkMigratedTo, network, keyType);
  }
  return void 0;
}

// node_modules/@toruslabs/fetch-node-details/dist/lib.esm/nodeDetailManager.js
var import_loglevel8 = __toESM(require_loglevel());
var log5 = import_loglevel8.default.getLogger("fnd");
var NodeDetailManager = class {
  constructor({
    network = TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET,
    keyType = KEY_TYPE.SECP256K1,
    fndServerEndpoint,
    enableLogging = false
  } = {}) {
    _defineProperty(this, "fndServerEndpoint", `${FND_SERVER}/node-details`);
    _defineProperty(this, "_currentEpoch", "1");
    _defineProperty(this, "_keyType", void 0);
    _defineProperty(this, "_torusNodeEndpoints", []);
    _defineProperty(this, "_torusNodeRSSEndpoints", []);
    _defineProperty(this, "_torusNodeSSSEndpoints", []);
    _defineProperty(this, "_torusNodeTSSEndpoints", []);
    _defineProperty(this, "_torusNodePub", []);
    _defineProperty(this, "_torusIndexes", []);
    _defineProperty(this, "updated", void 0);
    _defineProperty(this, "network", void 0);
    this.network = network;
    this._keyType = keyType;
    this.updated = false;
    if (fndServerEndpoint) {
      this.fndServerEndpoint = fndServerEndpoint;
    }
    if (enableLogging) {
      log5.enableAll();
    } else {
      log5.disableAll();
    }
  }
  get _nodeDetails() {
    return {
      currentEpoch: this._currentEpoch,
      torusNodeEndpoints: this._torusNodeEndpoints,
      torusNodeSSSEndpoints: this._torusNodeSSSEndpoints,
      torusNodeRSSEndpoints: this._torusNodeRSSEndpoints,
      torusNodeTSSEndpoints: this._torusNodeTSSEndpoints,
      torusNodePub: this._torusNodePub,
      torusIndexes: this._torusIndexes,
      updated: this.updated
    };
  }
  async getNodeDetails({
    verifier,
    verifierId
  }) {
    try {
      if (this.updated && !MULTI_CLUSTER_NETWORKS.includes(this.network)) return this._nodeDetails;
      try {
        const {
          nodeDetails: nodeDetails2
        } = await get(`${this.fndServerEndpoint}?network=${this.network}&verifier=${verifier}&verifierId=${verifierId}&keyType=${this._keyType}`);
        this.setNodeDetails(nodeDetails2);
        return this._nodeDetails;
      } catch (error) {
        log5.error("Failed to fetch node details from server, using local.", error);
      }
      const nodeDetails = fetchLocalConfig(this.network, this._keyType);
      if (!nodeDetails) throw new Error("Failed to fetch node details");
      this.setNodeDetails(nodeDetails);
      return this._nodeDetails;
    } catch (error) {
      log5.error("Failed to fetch node details", error);
      throw error;
    }
  }
  async getMetadataUrl() {
    if (Object.values(TORUS_LEGACY_NETWORK).includes(this.network)) {
      return METADATA_MAP[this.network];
    }
    const nodeDetails = await this.getNodeDetails({
      verifier: "test-verifier",
      verifierId: "test-verifier-id"
    });
    return nodeDetails.torusNodeEndpoints[0].replace("/sss/jrpc", "/metadata");
  }
  setNodeDetails(nodeDetails) {
    const {
      currentEpoch,
      torusNodeEndpoints,
      torusNodeSSSEndpoints,
      torusNodeRSSEndpoints,
      torusNodeTSSEndpoints,
      torusNodePub,
      torusIndexes
    } = nodeDetails;
    this._torusNodeEndpoints = torusNodeEndpoints;
    this._torusNodeSSSEndpoints = torusNodeSSSEndpoints || [];
    this._torusNodeRSSEndpoints = torusNodeRSSEndpoints || [];
    this._torusNodeTSSEndpoints = torusNodeTSSEndpoints || [];
    this._torusNodePub = torusNodePub;
    this._torusIndexes = torusIndexes;
    this._currentEpoch = currentEpoch;
    this.updated = true;
  }
};
var NodeDetailManager$1 = NodeDetailManager;

// node_modules/@toruslabs/customauth/dist/lib.esm/registerServiceWorker.js
var import_register_service_worker = __toESM(require_register_service_worker());
var registerServiceWorker = (baseUrl) => new Promise((resolve, reject) => {
  const swUrl = `${baseUrl}sw.js`;
  if ("serviceWorker" in window.navigator) {
    (0, import_register_service_worker.register)(swUrl, {
      ready() {
        log.info("App is being served from cache by a service worker.\n For more details, visit https://goo.gl/AFskqB");
        resolve(void 0);
      },
      registered() {
        log.info("Service worker has been registered.");
        resolve(void 0);
      },
      cached() {
        log.info("Content has been cached for offline use.");
        resolve(void 0);
      },
      updatefound() {
        log.info("New content is downloading.");
      },
      updated() {
        log.info("New content is available; please refresh.");
      },
      offline() {
        log.info("No internet connection found. App is running in offline mode.");
        reject(new Error("App is offline"));
      },
      error(error) {
        log.error("Error during service worker registration:", error);
        reject(error);
      }
    });
  } else {
    reject(new Error("Service workers are not supported"));
  }
});

// node_modules/@toruslabs/customauth/dist/lib.esm/sentry.js
var SentryHandler = class {
  constructor(sentry) {
    _defineProperty(this, "sentry", null);
    this.sentry = sentry;
  }
  startSpan(context, callback) {
    if (this.sentry) {
      return this.sentry.startSpan(context, callback);
    }
    return callback(null);
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/error.js
var serializeError = async (error) => {
  const isError = error instanceof Error;
  const isString = typeof error === "string";
  const isApiErrorIndex = error && typeof error === "object" && "status" in error && "type" in error;
  let err;
  if (isApiErrorIndex) {
    const apiError = error;
    const contentType = apiError.headers.get("content-type");
    if (contentType.includes("application/json")) {
      const errJson = await apiError.json();
      err = new Error((errJson === null || errJson === void 0 ? void 0 : errJson.error) || (errJson === null || errJson === void 0 ? void 0 : errJson.message) || JSON.stringify(errJson));
    } else if (contentType.includes("text/plain")) {
      err = new Error(await apiError.text());
    } else {
      err = new Error(`${apiError.status} ${apiError.type.toString()} ${apiError.statusText}`);
    }
  } else if (isString) {
    err = new Error(error);
  } else if (isError) {
    err = error;
  } else {
    err = new Error("Unknown error");
  }
  return err;
};

// node_modules/@toruslabs/customauth/node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js
var import_elliptic = __toESM(require_elliptic());
var ec = new import_elliptic.ec("secp256k1");
var browserCrypto = globalThis.crypto || globalThis.msCrypto || {};
var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
var ZERO32 = Buffer.alloc(32, 0);
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isScalar(x) {
  return Buffer.isBuffer(x) && x.length === 32;
}
function isValidPrivateKey(privateKey) {
  if (!isScalar(privateKey)) {
    return false;
  }
  return privateKey.compare(ZERO32) > 0 && // > 0
  privateKey.compare(EC_GROUP_ORDER) < 0;
}
function getAes(op) {
  return async function(iv, key, data) {
    if (subtle && subtle[op] && subtle.importKey) {
      const importAlgorithm = {
        name: "AES-CBC"
      };
      const cryptoKey = await subtle.importKey("raw", key, importAlgorithm, false, [op]);
      const encAlgorithm = {
        name: "AES-CBC",
        iv
      };
      const result = await subtle[op](encAlgorithm, cryptoKey, data);
      return Buffer.from(new Uint8Array(result));
    } else if (op === "encrypt" && browserCrypto.createCipheriv) {
      const cipher = browserCrypto.createCipheriv("aes-256-cbc", key, iv);
      const firstChunk = cipher.update(data);
      const secondChunk = cipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    } else if (op === "decrypt" && browserCrypto.createDecipheriv) {
      const decipher = browserCrypto.createDecipheriv("aes-256-cbc", key, iv);
      const firstChunk = decipher.update(data);
      const secondChunk = decipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    }
    throw new Error(`Unsupported operation: ${op}`);
  };
}
var aesCbcEncrypt = getAes("encrypt");
var aesCbcDecrypt = getAes("decrypt");
var getPublic = function(privateKey) {
  assert(privateKey.length === 32, "Bad private key");
  assert(isValidPrivateKey(privateKey), "Bad private key");
  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic("array"));
};
var sign = async function(privateKey, msg) {
  assert(privateKey.length === 32, "Bad private key");
  assert(isValidPrivateKey(privateKey), "Bad private key");
  assert(msg.length > 0, "Message should not be empty");
  assert(msg.length <= 32, "Message is too long");
  return Buffer.from(ec.sign(msg, privateKey, {
    canonical: true
  }).toDER());
};

// node_modules/@toruslabs/customauth/dist/lib.esm/utils/StorageHelper.js
var StorageHelper = class {
  constructor(serverUrl) {
    _defineProperty(this, "currentStorageMethod", REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE);
    _defineProperty(this, "isInitialized", false);
    _defineProperty(this, "storageServerUrl", "https://session.web3auth.io");
    _defineProperty(this, "localStorageAvailable", true);
    this.storageServerUrl = serverUrl;
  }
  get storageMethodUsed() {
    return this.currentStorageMethod;
  }
  init() {
    const support = are3PCSupported();
    const localStorageAvailable = storageAvailable(REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE);
    this.localStorageAvailable = localStorageAvailable;
    if (support && localStorageAvailable) {
      this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.LOCAL_STORAGE;
    } else {
      this.currentStorageMethod = REDIRECT_PARAMS_STORAGE_METHOD.SERVER;
    }
    this.isInitialized = true;
  }
  async storeLoginDetails(params, scope) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.currentStorageMethod === REDIRECT_PARAMS_STORAGE_METHOD.SERVER) {
      const privKey = keccak256(Buffer.from(scope, "utf8"));
      const privKeyHex = privKey.toString("hex");
      const publicKeyHex = getPublic(privKey).toString("hex");
      const encData = await encryptData(privKeyHex, params);
      const signature = (await sign(privKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex");
      await post(`${this.storageServerUrl}/store/set`, {
        key: publicKeyHex,
        data: encData,
        signature
      });
    }
    if (this.localStorageAvailable) window.localStorage.setItem(`torus_login_${scope}`, JSON.stringify(params));
  }
  async retrieveLoginDetails(scope) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.localStorageAvailable) {
      const loginDetails = window.localStorage.getItem(`torus_login_${scope}`);
      if (loginDetails) return JSON.parse(loginDetails || "{}");
    }
    if (this.currentStorageMethod === REDIRECT_PARAMS_STORAGE_METHOD.SERVER) {
      const privKey = keccak256(Buffer.from(scope, "utf8"));
      const privKeyHex = privKey.toString("hex");
      const publicKeyHex = getPublic(privKey).toString("hex");
      try {
        const encData = await get(`${this.storageServerUrl}/store/get?key=${publicKeyHex}`);
        if (encData.message) {
          const currentLoginDetails = await decryptData(privKeyHex, encData.message);
          return currentLoginDetails;
        }
      } catch (error) {
        if (error.status === 404) {
          log.warn(error, "Session likely expired");
        } else {
          throw error;
        }
      }
    }
  }
  clearLoginDetailsStorage(scope) {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (this.localStorageAvailable) window.localStorage.removeItem(`torus_login_${scope}`);
  }
  clearOrphanedLoginDetails() {
    if (!this.isInitialized) throw new Error("StorageHelper is not initialized");
    if (!this.localStorageAvailable) return;
    const allStorageKeys = Object.keys(window.localStorage);
    allStorageKeys.forEach((key) => {
      if (key.startsWith("torus_login_")) {
        window.localStorage.removeItem(key);
      }
    });
  }
};

// node_modules/@toruslabs/customauth/dist/lib.esm/login.js
var _excluded3 = ["access_token", "id_token"];
var _excluded22 = ["access_token", "id_token"];
var _excluded32 = ["args", "method"];
var CustomAuth = class {
  constructor({
    baseUrl,
    network,
    enableLogging = false,
    redirectToOpener = false,
    redirectPathName = "redirect",
    apiKey = "torus-default",
    uxMode = UX_MODE.POPUP,
    locationReplaceOnRedirect = false,
    popupFeatures,
    storageServerUrl = "https://session.web3auth.io",
    sentry,
    enableOneKey = false,
    web3AuthClientId,
    useDkg,
    metadataUrl = "https://metadata.tor.us",
    keyType = "secp256k1",
    serverTimeOffset = 0,
    nodeDetails,
    checkCommitment = true
  }) {
    _defineProperty(this, "isInitialized", void 0);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "torus", void 0);
    _defineProperty(this, "nodeDetailManager", void 0);
    _defineProperty(this, "storageHelper", void 0);
    _defineProperty(this, "sentryHandler", void 0);
    if (!web3AuthClientId) throw new Error("Please provide a valid web3AuthClientId in constructor");
    if (!network) throw new Error("Please provide a valid network in constructor");
    this.isInitialized = false;
    const baseUri = new URL(baseUrl);
    this.config = {
      baseUrl: padUrlString(baseUri),
      get redirect_uri() {
        return `${this.baseUrl}${redirectPathName}`;
      },
      redirectToOpener,
      uxMode,
      locationReplaceOnRedirect,
      popupFeatures,
      useDkg,
      web3AuthClientId,
      web3AuthNetwork: network,
      keyType,
      nodeDetails,
      checkCommitment
    };
    const torus = new Torus({
      network,
      enableOneKey,
      serverTimeOffset,
      clientId: web3AuthClientId,
      legacyMetadataHost: metadataUrl,
      keyType
    });
    Torus.setAPIKey(apiKey);
    this.torus = torus;
    this.nodeDetailManager = new NodeDetailManager$1({
      network
    });
    if (enableLogging) log.enableAll();
    else log.disableAll();
    this.storageHelper = new StorageHelper(storageServerUrl);
    this.sentryHandler = new SentryHandler(sentry);
  }
  async init({
    skipSw = false,
    skipInit = false,
    skipPrefetch = false
  } = {}) {
    this.storageHelper.init();
    if (skipInit) {
      this.isInitialized = true;
      return;
    }
    if (!skipSw) {
      const fetchSwResponse = await fetch(`${this.config.baseUrl}sw.js`, {
        cache: "reload"
      });
      if (fetchSwResponse.ok) {
        try {
          await registerServiceWorker(this.config.baseUrl);
          this.isInitialized = true;
          return;
        } catch (error) {
          log.warn(error);
        }
      } else {
        throw new Error("Service worker is not being served. Please serve it");
      }
    }
    if (!skipPrefetch) {
      if (isFirefox()) {
        this.isInitialized = true;
        return;
      }
      await this.handlePrefetchRedirectUri();
      return;
    }
    this.isInitialized = true;
  }
  async triggerLogin(args) {
    const {
      verifier,
      typeOfLogin,
      clientId,
      jwtParams,
      hash,
      queryParameters,
      customState
    } = args;
    log.info("Verifier: ", verifier);
    if (!this.isInitialized) {
      throw new Error("Not initialized yet");
    }
    const loginHandler = createHandler$1({
      typeOfLogin,
      clientId,
      verifier,
      redirect_uri: this.config.redirect_uri,
      redirectToOpener: this.config.redirectToOpener,
      jwtParams,
      uxMode: this.config.uxMode,
      customState,
      web3AuthClientId: this.config.web3AuthClientId,
      web3AuthNetwork: this.config.web3AuthNetwork
    });
    let loginParams;
    if (hash && queryParameters) {
      const {
        error,
        hashParameters,
        instanceParameters
      } = handleRedirectParameters(hash, queryParameters);
      if (error) throw new Error(error);
      const {
        access_token: accessToken,
        id_token: idToken
      } = hashParameters, rest = _objectWithoutProperties(hashParameters, _excluded3);
      loginParams = _objectSpread2(_objectSpread2({
        accessToken,
        idToken
      }, rest), {}, {
        state: instanceParameters
      });
    } else {
      this.storageHelper.clearOrphanedLoginDetails();
      if (this.config.uxMode === UX_MODE.REDIRECT) {
        await this.storageHelper.storeLoginDetails({
          method: TORUS_METHOD.TRIGGER_LOGIN,
          args
        }, loginHandler.nonce);
      }
      loginParams = await loginHandler.handleLoginWindow({
        locationReplaceOnRedirect: this.config.locationReplaceOnRedirect,
        popupFeatures: this.config.popupFeatures
      });
      if (this.config.uxMode === UX_MODE.REDIRECT) return null;
    }
    const userInfo = await loginHandler.getUserInfo(loginParams);
    const torusKey = await this.getTorusKey(verifier, userInfo.verifierId, {
      verifier_id: userInfo.verifierId
    }, loginParams.idToken || loginParams.accessToken, userInfo.extraVerifierParams);
    return _objectSpread2(_objectSpread2({}, torusKey), {}, {
      userInfo: _objectSpread2(_objectSpread2({}, userInfo), loginParams)
    });
  }
  async triggerAggregateLogin(args) {
    const {
      aggregateVerifierType,
      verifierIdentifier,
      subVerifierDetailsArray
    } = args;
    if (!this.isInitialized) {
      throw new Error("Not initialized yet");
    }
    if (!aggregateVerifierType || !verifierIdentifier || !Array.isArray(subVerifierDetailsArray)) {
      throw new Error("Invalid params. Missing aggregateVerifierType, verifierIdentifier or subVerifierDetailsArray");
    }
    if (aggregateVerifierType === AGGREGATE_VERIFIER.SINGLE_VERIFIER_ID && subVerifierDetailsArray.length !== 1) {
      throw new Error("Single id verifier can only have one sub verifier");
    }
    const userInfoPromises = [];
    const loginParamsArray = [];
    for (const subVerifierDetail of subVerifierDetailsArray) {
      const {
        clientId,
        typeOfLogin,
        verifier,
        jwtParams,
        hash,
        queryParameters,
        customState
      } = subVerifierDetail;
      const loginHandler = createHandler$1({
        typeOfLogin,
        clientId,
        verifier,
        redirect_uri: this.config.redirect_uri,
        redirectToOpener: this.config.redirectToOpener,
        jwtParams,
        uxMode: this.config.uxMode,
        customState,
        web3AuthClientId: this.config.web3AuthClientId,
        web3AuthNetwork: this.config.web3AuthNetwork
      });
      let loginParams;
      if (hash && queryParameters) {
        const {
          error,
          hashParameters,
          instanceParameters
        } = handleRedirectParameters(hash, queryParameters);
        if (error) throw new Error(error);
        const {
          access_token: accessToken,
          id_token: idToken
        } = hashParameters, rest = _objectWithoutProperties(hashParameters, _excluded22);
        loginParams = _objectSpread2(_objectSpread2({
          accessToken,
          idToken
        }, rest), {}, {
          state: instanceParameters
        });
      } else {
        this.storageHelper.clearOrphanedLoginDetails();
        if (this.config.uxMode === UX_MODE.REDIRECT) {
          await this.storageHelper.storeLoginDetails({
            method: TORUS_METHOD.TRIGGER_AGGREGATE_LOGIN,
            args
          }, loginHandler.nonce);
        }
        loginParams = await loginHandler.handleLoginWindow({
          locationReplaceOnRedirect: this.config.locationReplaceOnRedirect,
          popupFeatures: this.config.popupFeatures
        });
        if (this.config.uxMode === UX_MODE.REDIRECT) return null;
      }
      userInfoPromises.push(loginHandler.getUserInfo(loginParams));
      loginParamsArray.push(loginParams);
    }
    const _userInfoArray = await Promise.all(userInfoPromises);
    const userInfoArray = _userInfoArray.map((userInfo) => _objectSpread2(_objectSpread2({}, userInfo), {}, {
      aggregateVerifier: verifierIdentifier
    }));
    const aggregateVerifierParams = {
      verify_params: [],
      sub_verifier_ids: [],
      verifier_id: ""
    };
    const aggregateIdTokenSeeds = [];
    let aggregateVerifierId = "";
    let extraVerifierParams = {};
    for (let index = 0; index < subVerifierDetailsArray.length; index += 1) {
      const loginParams = loginParamsArray[index];
      const {
        idToken,
        accessToken
      } = loginParams;
      const userInfo = userInfoArray[index];
      aggregateVerifierParams.verify_params.push({
        verifier_id: userInfo.verifierId,
        idtoken: idToken || accessToken
      });
      aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
      aggregateIdTokenSeeds.push(idToken || accessToken);
      aggregateVerifierId = userInfo.verifierId;
      extraVerifierParams = userInfo.extraVerifierParams;
    }
    aggregateIdTokenSeeds.sort();
    const aggregateIdToken = keccak2562(Buffer.from(aggregateIdTokenSeeds.join(String.fromCharCode(29)), "utf8")).slice(2);
    aggregateVerifierParams.verifier_id = aggregateVerifierId;
    const torusKey = await this.getTorusKey(verifierIdentifier, aggregateVerifierId, aggregateVerifierParams, aggregateIdToken, extraVerifierParams);
    return _objectSpread2(_objectSpread2({}, torusKey), {}, {
      userInfo: userInfoArray.map((x, index) => _objectSpread2(_objectSpread2({}, x), loginParamsArray[index]))
    });
  }
  async getTorusKey(verifier, verifierId, verifierParams, idToken, additionalParams) {
    const nodeDetails = await this.sentryHandler.startSpan({
      name: SENTRY_TXNS.FETCH_NODE_DETAILS
    }, async () => {
      if (this.config.nodeDetails) {
        return this.config.nodeDetails;
      }
      return this.nodeDetailManager.getNodeDetails({
        verifier,
        verifierId
      });
    });
    log.debug("torus-direct/getTorusKey", {
      torusNodeEndpoints: nodeDetails.torusNodeEndpoints
    });
    const sharesResponse = await this.sentryHandler.startSpan({
      name: SENTRY_TXNS.FETCH_SHARES
    }, async () => {
      return this.torus.retrieveShares({
        endpoints: nodeDetails.torusNodeEndpoints,
        indexes: nodeDetails.torusIndexes,
        verifier,
        verifierParams,
        idToken,
        nodePubkeys: nodeDetails.torusNodePub,
        extraParams: _objectSpread2({}, additionalParams),
        useDkg: this.config.useDkg,
        checkCommitment: this.config.checkCommitment
      });
    });
    log.debug("torus-direct/getTorusKey", {
      retrieveShares: sharesResponse
    });
    return sharesResponse;
  }
  async getAggregateTorusKey(verifier, verifierId, subVerifierInfoArray) {
    const aggregateVerifierParams = {
      verify_params: [],
      sub_verifier_ids: [],
      verifier_id: ""
    };
    const aggregateIdTokenSeeds = [];
    let extraVerifierParams = {};
    for (let index = 0; index < subVerifierInfoArray.length; index += 1) {
      const userInfo = subVerifierInfoArray[index];
      aggregateVerifierParams.verify_params.push({
        verifier_id: verifierId,
        idtoken: userInfo.idToken
      });
      aggregateVerifierParams.sub_verifier_ids.push(userInfo.verifier);
      aggregateIdTokenSeeds.push(userInfo.idToken);
      extraVerifierParams = userInfo.extraVerifierParams;
    }
    aggregateIdTokenSeeds.sort();
    const aggregateIdToken = keccak2562(Buffer.from(aggregateIdTokenSeeds.join(String.fromCharCode(29)), "utf8")).slice(2);
    aggregateVerifierParams.verifier_id = verifierId;
    return this.getTorusKey(verifier, verifierId, aggregateVerifierParams, aggregateIdToken, extraVerifierParams);
  }
  async getRedirectResult({
    replaceUrl = true,
    clearLoginDetails = true
  } = {}) {
    await this.init({
      skipInit: true
    });
    const url = new URL(window.location.href);
    const hash = url.hash.substring(1);
    const queryParams = {};
    url.searchParams.forEach((value, key) => {
      queryParams[key] = value;
    });
    if (!hash && Object.keys(queryParams).length === 0) {
      throw new Error("Found Empty hash and query parameters. This can happen if user reloads the page");
    }
    const {
      error,
      instanceParameters,
      hashParameters
    } = handleRedirectParameters(hash, queryParams);
    const {
      instanceId
    } = instanceParameters;
    log.info(instanceId, "instanceId");
    const loginDetails = await this.storageHelper.retrieveLoginDetails(instanceId);
    const _ref = loginDetails || {}, {
      args,
      method
    } = _ref, rest = _objectWithoutProperties(_ref, _excluded32);
    log.info(args, method);
    if (error) {
      return {
        error,
        state: instanceParameters || {},
        method,
        result: {},
        hashParameters,
        args
      };
    }
    let result;
    try {
      if (method === TORUS_METHOD.TRIGGER_LOGIN) {
        const methodArgs = args;
        methodArgs.hash = hash;
        methodArgs.queryParameters = queryParams;
        result = await this.triggerLogin(methodArgs);
      } else if (method === TORUS_METHOD.TRIGGER_AGGREGATE_LOGIN) {
        const methodArgs = args;
        methodArgs.subVerifierDetailsArray.forEach((x) => {
          x.hash = hash;
          x.queryParameters = queryParams;
        });
        result = await this.triggerAggregateLogin(methodArgs);
      }
    } catch (err) {
      const serializedError = await serializeError(err);
      log.error(serializedError);
      if (clearLoginDetails) {
        this.storageHelper.clearLoginDetailsStorage(instanceId);
      }
      return _objectSpread2({
        error: `${serializedError.message || ""}`,
        state: instanceParameters || {},
        method,
        result: {},
        hashParameters,
        args
      }, rest);
    }
    if (!result) return _objectSpread2({
      error: `Init parameters not found. It might be because storage is not available. Please retry the login in a different browser. Used storage method: ${this.storageHelper.storageMethodUsed}`,
      state: instanceParameters || {},
      method,
      result: {},
      hashParameters,
      args
    }, rest);
    if (replaceUrl) {
      const cleanUrl = window.location.origin + window.location.pathname;
      window.history.replaceState(_objectSpread2(_objectSpread2({}, window.history.state), {}, {
        as: cleanUrl,
        url: cleanUrl
      }), "", cleanUrl);
    }
    if (clearLoginDetails) {
      this.storageHelper.clearLoginDetailsStorage(instanceId);
    }
    return _objectSpread2({
      method,
      result,
      state: instanceParameters || {},
      hashParameters,
      args
    }, rest);
  }
  async handlePrefetchRedirectUri() {
    if (!document) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const redirectHtml = document.createElement("link");
      redirectHtml.href = this.config.redirect_uri;
      if (window.location.origin !== new URL(this.config.redirect_uri).origin) redirectHtml.crossOrigin = "anonymous";
      redirectHtml.type = "text/html";
      redirectHtml.rel = "prefetch";
      const resolveFn = () => {
        this.isInitialized = true;
        resolve();
      };
      try {
        if (redirectHtml.relList && redirectHtml.relList.supports) {
          if (redirectHtml.relList.supports("prefetch")) {
            redirectHtml.onload = resolveFn;
            redirectHtml.onerror = () => {
              reject(new Error(`Please serve redirect.html present in serviceworker folder of this package on ${this.config.redirect_uri}`));
            };
            document.head.appendChild(redirectHtml);
          } else {
            resolveFn();
          }
        } else {
          resolveFn();
        }
      } catch (err) {
        resolveFn();
      }
    });
  }
};
var CustomAuth$1 = CustomAuth;

// node_modules/@tkey/common-types/node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js
var import_elliptic2 = __toESM(require_elliptic());
var ec2 = new import_elliptic2.ec("secp256k1");
var browserCrypto2 = globalThis.crypto || globalThis.msCrypto || {};
var subtle2 = browserCrypto2.subtle || browserCrypto2.webkitSubtle;
var EC_GROUP_ORDER2 = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
var ZERO322 = Buffer.alloc(32, 0);
function assert2(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isScalar2(x) {
  return Buffer.isBuffer(x) && x.length === 32;
}
function isValidPrivateKey2(privateKey) {
  if (!isScalar2(privateKey)) {
    return false;
  }
  return privateKey.compare(ZERO322) > 0 && // > 0
  privateKey.compare(EC_GROUP_ORDER2) < 0;
}
function equalConstTime(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  let res = 0;
  for (let i = 0; i < b1.length; i++) {
    res |= b1[i] ^ b2[i];
  }
  return res === 0;
}
function randomBytes(size) {
  if (typeof browserCrypto2.getRandomValues === "undefined") {
    return Buffer.from(browserCrypto2.randomBytes(size));
  }
  const arr = new Uint8Array(size);
  browserCrypto2.getRandomValues(arr);
  return Buffer.from(arr);
}
async function sha512(msg) {
  if (!browserCrypto2.createHash) {
    const hash2 = await subtle2.digest("SHA-512", msg);
    const result2 = new Uint8Array(hash2);
    return result2;
  }
  const hash = browserCrypto2.createHash("sha512");
  const result = hash.update(msg).digest();
  return new Uint8Array(result);
}
function getAes2(op) {
  return async function(iv, key, data) {
    if (subtle2 && subtle2[op] && subtle2.importKey) {
      const importAlgorithm = {
        name: "AES-CBC"
      };
      const cryptoKey = await subtle2.importKey("raw", key, importAlgorithm, false, [op]);
      const encAlgorithm = {
        name: "AES-CBC",
        iv
      };
      const result = await subtle2[op](encAlgorithm, cryptoKey, data);
      return Buffer.from(new Uint8Array(result));
    } else if (op === "encrypt" && browserCrypto2.createCipheriv) {
      const cipher = browserCrypto2.createCipheriv("aes-256-cbc", key, iv);
      const firstChunk = cipher.update(data);
      const secondChunk = cipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    } else if (op === "decrypt" && browserCrypto2.createDecipheriv) {
      const decipher = browserCrypto2.createDecipheriv("aes-256-cbc", key, iv);
      const firstChunk = decipher.update(data);
      const secondChunk = decipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    }
    throw new Error(`Unsupported operation: ${op}`);
  };
}
var aesCbcEncrypt2 = getAes2("encrypt");
var aesCbcDecrypt2 = getAes2("decrypt");
async function hmacSha256Sign(key, msg) {
  if (!browserCrypto2.createHmac) {
    const importAlgorithm = {
      name: "HMAC",
      hash: {
        name: "SHA-256"
      }
    };
    const cryptoKey = await subtle2.importKey("raw", new Uint8Array(key), importAlgorithm, false, ["sign", "verify"]);
    const sig = await subtle2.sign("HMAC", cryptoKey, msg);
    const result2 = Buffer.from(new Uint8Array(sig));
    return result2;
  }
  const hmac = browserCrypto2.createHmac("sha256", Buffer.from(key));
  hmac.update(msg);
  const result = hmac.digest();
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await hmacSha256Sign(key, msg);
  return equalConstTime(expectedSig, sig);
}
var generatePrivate = function() {
  let privateKey = randomBytes(32);
  while (!isValidPrivateKey2(privateKey)) {
    privateKey = randomBytes(32);
  }
  return privateKey;
};
var getPublic2 = function(privateKey) {
  assert2(privateKey.length === 32, "Bad private key");
  assert2(isValidPrivateKey2(privateKey), "Bad private key");
  return Buffer.from(ec2.keyFromPrivate(privateKey).getPublic("array"));
};
var derive = async function(privateKeyA, publicKeyB) {
  assert2(Buffer.isBuffer(privateKeyA), "Bad private key");
  assert2(Buffer.isBuffer(publicKeyB), "Bad public key");
  assert2(privateKeyA.length === 32, "Bad private key");
  assert2(isValidPrivateKey2(privateKeyA), "Bad private key");
  assert2(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
  if (publicKeyB.length === 65) {
    assert2(publicKeyB[0] === 4, "Bad public key");
  }
  if (publicKeyB.length === 33) {
    assert2(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
  }
  const keyA = ec2.keyFromPrivate(privateKeyA);
  const keyB = ec2.keyFromPublic(publicKeyB);
  const Px = keyA.derive(keyB.getPublic());
  return Buffer.from(Px.toArray());
};
var deriveUnpadded = derive;
var derivePadded = async function(privateKeyA, publicKeyB) {
  assert2(Buffer.isBuffer(privateKeyA), "Bad private key");
  assert2(Buffer.isBuffer(publicKeyB), "Bad public key");
  assert2(privateKeyA.length === 32, "Bad private key");
  assert2(isValidPrivateKey2(privateKeyA), "Bad private key");
  assert2(publicKeyB.length === 65 || publicKeyB.length === 33, "Bad public key");
  if (publicKeyB.length === 65) {
    assert2(publicKeyB[0] === 4, "Bad public key");
  }
  if (publicKeyB.length === 33) {
    assert2(publicKeyB[0] === 2 || publicKeyB[0] === 3, "Bad public key");
  }
  const keyA = ec2.keyFromPrivate(privateKeyA);
  const keyB = ec2.keyFromPublic(publicKeyB);
  const Px = keyA.derive(keyB.getPublic());
  return Buffer.from(Px.toString(16, 64), "hex");
};
var encrypt = async function(publicKeyTo, msg, opts) {
  opts = opts || {};
  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
  while (!isValidPrivateKey2(ephemPrivateKey)) {
    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);
  }
  const ephemPublicKey = getPublic2(ephemPrivateKey);
  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);
  const hash = await sha512(Px);
  const iv = opts.iv || randomBytes(16);
  const encryptionKey = hash.slice(0, 32);
  const macKey = hash.slice(32);
  const data = await aesCbcEncrypt2(iv, Buffer.from(encryptionKey), msg);
  const ciphertext = data;
  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);
  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);
  return {
    iv,
    ephemPublicKey,
    ciphertext,
    mac
  };
};
var decrypt = async function(privateKey, opts, _padding) {
  const padding = _padding !== null && _padding !== void 0 ? _padding : false;
  const deriveLocal = padding ? derivePadded : deriveUnpadded;
  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);
  const hash = await sha512(Px);
  const encryptionKey = hash.slice(0, 32);
  const macKey = hash.slice(32);
  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);
  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);
  if (!macGood && padding === false) {
    return decrypt(privateKey, opts, true);
  } else if (!macGood && padding === true) {
    throw new Error("bad MAC after trying padded");
  }
  const msg = await aesCbcDecrypt2(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);
  return Buffer.from(new Uint8Array(msg));
};

// node_modules/@tkey/common-types/dist/lib.esm/utils.js
var import_bn = __toESM(require_bn());
var import_elliptic3 = __toESM(require_elliptic());
var secp256k1 = new import_elliptic3.ec("secp256k1");
async function encrypt2(publicKey, msg) {
  const encryptedDetails = await encrypt(publicKey, msg);
  return {
    ciphertext: encryptedDetails.ciphertext.toString("hex"),
    ephemPublicKey: encryptedDetails.ephemPublicKey.toString("hex"),
    iv: encryptedDetails.iv.toString("hex"),
    mac: encryptedDetails.mac.toString("hex")
  };
}
async function decrypt2(privKey, msg) {
  const bufferEncDetails = {
    ciphertext: Buffer.from(msg.ciphertext, "hex"),
    ephemPublicKey: Buffer.from(msg.ephemPublicKey, "hex"),
    iv: Buffer.from(msg.iv, "hex"),
    mac: Buffer.from(msg.mac, "hex")
  };
  return decrypt(privKey, bufferEncDetails);
}
function isEmptyObject(obj) {
  return Object.keys(obj).length === 0 && obj.constructor === Object;
}
var isErrorObj = (err) => err && err.stack && err.message !== "";
async function prettyPrintError(error) {
  if (isErrorObj(error)) {
    return error;
  }
  return serializeError(error);
}
function generateAddressFromPublicKey(publicKey) {
  const ethAddressLower = `0x${keccak2562(publicKey).slice(64 - 38)}`;
  return toChecksumAddress(ethAddressLower);
}
function normalize(input) {
  if (!input) {
    return void 0;
  }
  let hexString;
  if (typeof input === "number") {
    hexString = input.toString(16);
    if (hexString.length % 2) {
      hexString = `0${hexString}`;
    }
  }
  if (typeof input === "string") {
    hexString = input.toLowerCase();
  }
  return `0x${hexString}`;
}
function generatePrivateExcludingIndexes(shareIndexes) {
  const key = new import_bn.default(generatePrivate());
  if (shareIndexes.find((el) => el.eq(key))) {
    return generatePrivateExcludingIndexes(shareIndexes);
  }
  return key;
}
var KEY_NOT_FOUND = "KEY_NOT_FOUND";
var SHARE_DELETED = "SHARE_DELETED";
function derivePubKeyXFromPolyID(polyID) {
  return polyID.split("|")[0].slice(2);
}
function stripHexPrefix(str) {
  if (str.slice(0, 2) === "0x") return str.slice(2);
  return str;
}
function generateID() {
  return `${Math.random().toString(36).substr(2, 9)}`;
}

// node_modules/@tkey/common-types/dist/lib.esm/base/Point.js
var import_bn2 = __toESM(require_bn());
var Point = class _Point {
  constructor(x, y) {
    _defineProperty(this, "x", void 0);
    _defineProperty(this, "y", void 0);
    this.x = new import_bn2.default(x, "hex");
    this.y = new import_bn2.default(y, "hex");
  }
  static fromScalar(s, ec4) {
    const p = ec4.g.mul(s);
    return _Point.fromElliptic(p);
  }
  /**
   * @deprecated Use `fromSEC1` instead.
   */
  static fromCompressedPub(value) {
    const key = secp256k1.keyFromPublic(value, "hex");
    const pt = key.getPublic();
    return new _Point(pt.getX(), pt.getY());
  }
  static fromJSON(value) {
    const {
      x,
      y
    } = value;
    return new _Point(x, y);
  }
  static fromElliptic(p) {
    if (p.isInfinity()) {
      return new _Point(null, null);
    }
    return new _Point(p.getX(), p.getY());
  }
  /**
   * Construct a point from SEC1 format.
   */
  static fromSEC1(ec4, encodedPoint) {
    if (encodedPoint.length === 2 && encodedPoint === "00") {
      const identity = ec4.g.mul(new import_bn2.default(0));
      return _Point.fromElliptic(identity);
    }
    const key = ec4.keyFromPublic(encodedPoint, "hex");
    const pt = key.getPublic();
    return _Point.fromElliptic(pt);
  }
  /**
   * @deprecated Use `toSEC1` instead.
   *
   * complies with EC and elliptic pub key types
   */
  encode(enc) {
    switch (enc) {
      case "arr":
        return Buffer.concat([Buffer.from("0x04", "hex"), Buffer.from(this.x.toString("hex"), "hex"), Buffer.from(this.y.toString("hex"), "hex")]);
      case "elliptic-compressed": {
        const ec4 = secp256k1;
        const key = ec4.keyFromPublic({
          x: this.x.toString("hex"),
          y: this.y.toString("hex")
        }, "hex");
        return Buffer.from(key.getPublic(true, "hex"));
      }
      default:
        throw new Error("encoding doesnt exist in Point");
    }
  }
  toEllipticPoint(ec4) {
    if (this.isIdentity()) {
      return ec4.g.mul(new import_bn2.default(0));
    }
    const keyPair = ec4.keyFromPublic({
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    }, "hex");
    return keyPair.getPublic();
  }
  /**
   * Returns this point encoded in SEC1 format.
   * @param ec - Curve which point is on.
   * @param compressed - Whether to use compressed format.
   * @returns The SEC1-encoded point.
   */
  toSEC1(ec4, compressed = false) {
    if (this.isIdentity()) {
      return Buffer.from("00", "hex");
    }
    const p = this.toEllipticPoint(ec4);
    return Buffer.from(p.encode("hex", compressed), "hex");
  }
  toJSON() {
    return {
      x: this.x.toString("hex"),
      y: this.y.toString("hex")
    };
  }
  isIdentity() {
    return this.x === null && this.y === null;
  }
  equals(p) {
    if (this.isIdentity()) {
      return p.isIdentity();
    }
    return this.x.eq(p.x) && this.y.eq(p.y);
  }
};
var Point$1 = Point;

// node_modules/@tkey/common-types/dist/lib.esm/base/Polynomial.js
var import_bn6 = __toESM(require_bn());

// node_modules/@tkey/common-types/dist/lib.esm/base/BNUtils.js
var import_bn3 = __toESM(require_bn());
var toPrivKeyEC = (bn) => secp256k1.keyFromPrivate(bn.toString("hex", 64));
var toPrivKeyECC = (bn) => {
  const tmp = new import_bn3.default(bn, "hex");
  return Buffer.from(tmp.toString("hex", 64), "hex");
};
var getPubKeyEC = (bn) => secp256k1.keyFromPrivate(bn.toString("hex", 64)).getPublic();
var getPubKeyECC = (bn) => getPublic2(toPrivKeyECC(bn));
var getPubKeyPoint = (bn) => {
  const pubKeyEc = getPubKeyEC(bn);
  return new Point$1(pubKeyEc.getX().toString("hex"), pubKeyEc.getY().toString("hex"));
};

// node_modules/@tkey/common-types/dist/lib.esm/base/PublicPolynomial.js
var PublicPolynomial = class _PublicPolynomial {
  constructor(polynomialCommitments) {
    _defineProperty(this, "polynomialCommitments", void 0);
    _defineProperty(this, "polynomialId", void 0);
    this.polynomialCommitments = polynomialCommitments;
  }
  static fromJSON(value) {
    const points = value.polynomialCommitments.map((x) => Point$1.fromJSON(x));
    return new _PublicPolynomial(points);
  }
  getThreshold() {
    return this.polynomialCommitments.length;
  }
  getPolynomialID() {
    let idSeed = "";
    for (let i = 0; i < this.polynomialCommitments.length; i += 1) {
      let nextChunk = this.polynomialCommitments[i].encode("elliptic-compressed").toString();
      if (i !== 0) {
        nextChunk = `|${nextChunk}`;
      }
      idSeed += nextChunk;
    }
    this.polynomialId = idSeed;
    return this.polynomialId;
  }
  toJSON() {
    return {
      polynomialCommitments: this.polynomialCommitments
    };
  }
};
var PublicPolynomial$1 = PublicPolynomial;

// node_modules/@tkey/common-types/dist/lib.esm/base/Share.js
var import_bn5 = __toESM(require_bn());

// node_modules/@tkey/common-types/dist/lib.esm/base/PublicShare.js
var import_bn4 = __toESM(require_bn());
var PublicShare = class _PublicShare {
  constructor(shareIndex, shareCommitment) {
    _defineProperty(this, "shareCommitment", void 0);
    _defineProperty(this, "shareIndex", void 0);
    this.shareCommitment = new Point$1(shareCommitment.x, shareCommitment.y);
    this.shareIndex = new import_bn4.default(shareIndex, "hex");
  }
  static fromJSON(value) {
    const {
      shareCommitment,
      shareIndex
    } = value;
    return new _PublicShare(shareIndex, Point$1.fromJSON(shareCommitment));
  }
  toJSON() {
    return {
      shareCommitment: this.shareCommitment,
      shareIndex: this.shareIndex.toString("hex")
    };
  }
};
var PublicShare$1 = PublicShare;

// node_modules/@tkey/common-types/dist/lib.esm/base/Share.js
var Share = class _Share {
  constructor(shareIndex, share) {
    _defineProperty(this, "share", void 0);
    _defineProperty(this, "shareIndex", void 0);
    this.share = new import_bn5.default(share, "hex");
    this.shareIndex = new import_bn5.default(shareIndex, "hex");
  }
  static fromJSON(value) {
    const {
      share,
      shareIndex
    } = value;
    return new _Share(shareIndex, share);
  }
  getPublicShare() {
    return new PublicShare$1(this.shareIndex, getPubKeyPoint(this.share));
  }
  toJSON() {
    return {
      share: this.share.toString("hex"),
      shareIndex: this.shareIndex.toString("hex")
    };
  }
};
var Share$1 = Share;

// node_modules/@tkey/common-types/dist/lib.esm/base/Polynomial.js
var Polynomial = class _Polynomial {
  constructor(polynomial) {
    _defineProperty(this, "polynomial", void 0);
    _defineProperty(this, "publicPolynomial", void 0);
    this.polynomial = polynomial;
  }
  static fromJSON(value) {
    const {
      polynomial
    } = value;
    return new _Polynomial(polynomial.map((x) => new import_bn6.default(x, "hex")));
  }
  getThreshold() {
    return this.polynomial.length;
  }
  polyEval(x) {
    const tmpX = new import_bn6.default(x, "hex");
    let xi = new import_bn6.default(tmpX);
    let sum = new import_bn6.default(0);
    sum = sum.add(this.polynomial[0]);
    for (let i = 1; i < this.polynomial.length; i += 1) {
      const tmp = xi.mul(this.polynomial[i]);
      sum = sum.add(tmp);
      sum = sum.umod(secp256k1.curve.n);
      xi = xi.mul(new import_bn6.default(tmpX));
      xi = xi.umod(secp256k1.curve.n);
    }
    return sum;
  }
  generateShares(shareIndexes) {
    const newShareIndexes = shareIndexes.map((index) => {
      if (typeof index === "number") {
        return new import_bn6.default(index);
      }
      if (index instanceof import_bn6.default) {
        return index;
      }
      if (typeof index === "string") {
        return new import_bn6.default(index, "hex");
      }
      return index;
    });
    const shares = {};
    for (let x = 0; x < newShareIndexes.length; x += 1) {
      shares[newShareIndexes[x].toString("hex")] = new Share$1(newShareIndexes[x], this.polyEval(newShareIndexes[x]));
    }
    return shares;
  }
  getPublicPolynomial() {
    const polynomialCommitments = [];
    for (let i = 0; i < this.polynomial.length; i += 1) {
      polynomialCommitments.push(getPubKeyPoint(this.polynomial[i]));
    }
    this.publicPolynomial = new PublicPolynomial$1(polynomialCommitments);
    return this.publicPolynomial;
  }
  getPolynomialID() {
    return this.publicPolynomial.polynomialId;
  }
  toJSON() {
    return {
      polynomial: this.polynomial.map((x) => x.toString("hex"))
    };
  }
};
var Polynomial$1 = Polynomial;

// node_modules/@tkey/common-types/dist/lib.esm/base/ShareStore.js
var ShareStore = class _ShareStore {
  constructor(share, polynomialID) {
    _defineProperty(this, "share", void 0);
    _defineProperty(this, "polynomialID", void 0);
    this.share = share;
    this.polynomialID = polynomialID;
  }
  static fromJSON(value) {
    const {
      share,
      polynomialID
    } = value;
    return new _ShareStore(Share$1.fromJSON(share), polynomialID);
  }
  toJSON() {
    return {
      share: this.share,
      polynomialID: this.polynomialID.toString()
    };
  }
};
var ShareStore$1 = ShareStore;

// node_modules/@tkey/common-types/dist/lib.esm/base/Error.js
var TkeyError = class extends CustomError {
  constructor(code, message) {
    super(message);
    _defineProperty(this, "code", void 0);
    _defineProperty(this, "message", void 0);
    this.code = code;
    this.message = message || "";
    Object.defineProperty(this, "name", {
      value: "TkeyError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};

// node_modules/@tkey/common-types/dist/lib.esm/base/OneKey.js
var ONE_KEY_DELETE_NONCE = "__ONE_KEY_DELETE_NONCE__";
var ONE_KEY_NAMESPACE = "noncev2";

export {
  KeyType,
  AGGREGATE_VERIFIER,
  UX_MODE,
  TORUS_METHOD,
  fetchLocalConfig,
  CustomAuth$1,
  secp256k1,
  encrypt2 as encrypt,
  decrypt2 as decrypt,
  isEmptyObject,
  isErrorObj,
  prettyPrintError,
  generateAddressFromPublicKey,
  normalize,
  generatePrivateExcludingIndexes,
  KEY_NOT_FOUND,
  SHARE_DELETED,
  derivePubKeyXFromPolyID,
  stripHexPrefix,
  generateID,
  Point$1,
  toPrivKeyEC,
  toPrivKeyECC,
  getPubKeyEC,
  getPubKeyECC,
  getPubKeyPoint,
  PublicPolynomial$1,
  PublicShare$1,
  Share$1,
  Polynomial$1,
  ShareStore$1,
  TkeyError,
  ONE_KEY_DELETE_NONCE,
  ONE_KEY_NAMESPACE
};
//# sourceMappingURL=chunk-CW4ZZO2K.js.map
