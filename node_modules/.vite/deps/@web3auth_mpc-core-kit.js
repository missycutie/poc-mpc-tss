import {
  CoreError$1,
  TKeyTSS,
  TSSTorusServiceProvider,
  factorKeyCurve,
  generatePrivateBN,
  getPubKeyPoint as getPubKeyPoint2,
  lagrangeInterpolation
} from "./chunk-WAZ3JWJ6.js";
import {
  AGGREGATE_VERIFIER,
  KEY_NOT_FOUND,
  KeyType,
  ONE_KEY_DELETE_NONCE,
  ONE_KEY_NAMESPACE,
  Point$1,
  SHARE_DELETED,
  ShareStore$1,
  TORUS_METHOD,
  TkeyError,
  UX_MODE,
  decrypt,
  encrypt,
  fetchLocalConfig,
  getPubKeyECC,
  getPubKeyPoint,
  prettyPrintError,
  secp256k1,
  toPrivKeyEC,
  toPrivKeyECC
} from "./chunk-CW4ZZO2K.js";
import {
  Torus,
  keccak256 as keccak2563
} from "./chunk-LQPOXDXK.js";
import "./chunk-URIYOKWX.js";
import {
  require_color,
  sha256
} from "./chunk-AMH65E4N.js";
import "./chunk-MCU2GF72.js";
import {
  lookup
} from "./chunk-A4ET6CEC.js";
import {
  SessionManager,
  bowser_default,
  require_base64url
} from "./chunk-F7QGJUT4.js";
import {
  keccak256 as keccak2562
} from "./chunk-UXA7HNRO.js";
import "./chunk-H6CUK76M.js";
import {
  _defineProperty,
  _objectSpread2,
  post,
  require_elliptic,
  require_json_stable_stringify,
  require_loglevel
} from "./chunk-NYBMST6M.js";
import {
  keccak256
} from "./chunk-O35336FG.js";
import {
  require_empty_module
} from "./chunk-FNF3WOFV.js";
import {
  require_bn
} from "./chunk-J3UDRN3X.js";
import "./chunk-4SXSSCV7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(o) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperty2(e, r, t) {
      return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }
    module.exports = _defineProperty2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@toruslabs/tss-client-util/dist/tssClientUtil.cjs.js
var require_tssClientUtil_cjs = __commonJS({
  "node_modules/@toruslabs/tss-client-util/dist/tssClientUtil.cjs.js"(exports, module) {
    (() => {
      "use strict";
      var __webpack_require__ = {};
      (() => {
        __webpack_require__.n = (module2) => {
          var getter = module2 && module2.__esModule ? (
            /******/
            () => module2["default"]
          ) : (
            /******/
            () => module2
          );
          __webpack_require__.d(getter, { a: getter });
          return getter;
        };
      })();
      (() => {
        __webpack_require__.d = (exports2, definition) => {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      })();
      (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      })();
      (() => {
        __webpack_require__.r = (exports2) => {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      })();
      var __webpack_exports__ = {};
      __webpack_require__.r(__webpack_exports__);
      __webpack_require__.d(__webpack_exports__, {
        AwaitableMap: () => (
          /* reexport */
          AwaitableMap
        ),
        MapQueue: () => (
          /* reexport */
          MapQueue2
        ),
        deriveShareCoefficients: () => (
          /* reexport */
          deriveShareCoefficients2
        ),
        fraction: () => (
          /* reexport */
          fraction2
        ),
        lagrangeCoefficient: () => (
          /* reexport */
          lagrangeCoefficient2
        ),
        lagrangeCoefficients: () => (
          /* reexport */
          lagrangeCoefficients2
        )
      });
      ;
      const defineProperty_namespaceObject = require_defineProperty();
      var defineProperty_default = __webpack_require__.n(defineProperty_namespaceObject);
      ;
      class AwaitableMap {
        constructor() {
          defineProperty_default()(this, "map", /* @__PURE__ */ new Map());
          defineProperty_default()(this, "queue", /* @__PURE__ */ new Map());
        }
        get size() {
          return this.map.size;
        }
        getSync(k) {
          return this.map.get(k);
        }
        /**
         * Gets the value at key `k`, or waits for the duration of `timeout` for a
         * corresponding value to be set. If `timeout` is reached, returns
         * `undefined`.
         */
        async get(k, timeout = 0) {
          const v = this.map.get(k);
          if (v) {
            return v;
          }
          return new Promise((resolve) => {
            const prom = {
              resolve,
              timeout: setTimeout(() => {
                const proms2 = this.queue.get(k);
                if (proms2) {
                  const i = proms2.indexOf(prom);
                  if (i >= 0) {
                    proms2.splice(i, 1);
                  }
                }
                resolve(void 0);
              }, timeout)
            };
            let proms = this.queue.get(k);
            if (!proms) {
              proms = [];
              this.queue.set(k, proms);
            }
            proms.push(prom);
          });
        }
        set(k, v) {
          this.map.set(k, v);
          const proms = this.queue.get(k);
          if (proms) {
            for (const prom of proms) {
              clearTimeout(prom.timeout);
              prom.resolve(v);
            }
            this.queue.delete(k);
          }
        }
        delete(k) {
          this.map.delete(k);
          this.queue.delete(k);
        }
        forEach(callbackfn) {
          this.map.forEach(callbackfn);
        }
        clear() {
          this.map.clear();
          this.queue.clear();
        }
      }
      class MapQueue2 {
        constructor() {
          defineProperty_default()(this, "buffer", /* @__PURE__ */ new Map());
          defineProperty_default()(this, "queue", /* @__PURE__ */ new Map());
        }
        /**
         * Pops the next value queued for key `k` from the buffer, or waits for the
         * duration of `timeout` for a corresponding value to arrive. If `timeout` is
         * reached, returns `undefined`.
         */
        async pop(k, timeout = 0) {
          const vals = this.buffer.get(k);
          if (vals && vals.length > 0) {
            const val = vals.splice(0, 1)[0];
            return val;
          }
          return new Promise((resolve) => {
            const prom = {
              resolve,
              timeout: setTimeout(() => {
                const proms2 = this.queue.get(k);
                if (proms2) {
                  const i = proms2.indexOf(prom);
                  if (i >= 0) {
                    proms2.splice(i, 1);
                  }
                }
                resolve(void 0);
              }, timeout)
            };
            let proms = this.queue.get(k);
            if (!proms) {
              proms = [];
              this.queue.set(k, proms);
            }
            proms.push(prom);
          });
        }
        push(k, v) {
          const proms = this.queue.get(k);
          if (proms && proms.length > 0) {
            const prom = proms.splice(0, 1)[0];
            clearTimeout(prom.timeout);
            prom.resolve(v);
            return;
          }
          let vals = this.buffer.get(k);
          if (!vals) {
            vals = [];
            this.buffer.set(k, vals);
          }
          vals.push(v);
        }
        delete(k) {
          this.buffer.delete(k);
          this.queue.delete(k);
        }
        forEach(callbackfn) {
          this.buffer.forEach((vals, k) => {
            vals.forEach((v) => {
              callbackfn(v, k);
            });
          });
        }
        clear() {
          this.buffer.clear();
          this.queue.clear();
        }
      }
      ;
      const external_bn_js_namespaceObject = require_bn();
      var external_bn_js_default = __webpack_require__.n(external_bn_js_namespaceObject);
      ;
      function fraction2(nom, denom, modulus) {
        return nom.mul(denom.invm(modulus)).umod(modulus);
      }
      function lagrangeCoefficient2(x_coords, target_coeff, target_x, modulus) {
        return x_coords.filter((_, i) => i !== target_coeff).reduce((prev, cur) => {
          const frac = fraction2(target_x.sub(cur), x_coords[target_coeff].sub(cur), modulus);
          return prev.mul(frac).umod(modulus);
        }, new (external_bn_js_default())(1));
      }
      function lagrangeCoefficients2(x_coords, target_x, modulus) {
        const x_coords_BN = x_coords.map((i) => new (external_bn_js_default())(i));
        const target_x_BN = new (external_bn_js_default())(target_x);
        return x_coords_BN.map((_value, i) => lagrangeCoefficient2(x_coords_BN, i, target_x_BN, modulus));
      }
      function deriveShareCoefficients2(serverXCoords, clientXCoord, modulus, serversXCoordL1 = 1, clientXCoordL1 = 2) {
        const l1Coefficients = lagrangeCoefficients2([serversXCoordL1, clientXCoordL1], 0, modulus);
        const l2Coefficients = lagrangeCoefficients2(serverXCoords, 0, modulus);
        if (serverXCoords.includes(clientXCoord)) {
          throw new Error(`Invalid server x-coordinates: overlapping with client x-coordinate: ${serverXCoords} ${clientXCoord}`);
        }
        const targetCoefficients = lagrangeCoefficients2([clientXCoord, ...serverXCoords], 0, modulus);
        const serverCoefficients = l2Coefficients.map((coeff, i) => fraction2(l1Coefficients[0].mul(coeff), targetCoefficients[i + 1], modulus));
        const clientCoefficient = fraction2(l1Coefficients[1], targetCoefficients[0], modulus);
        return {
          serverCoefficients,
          clientCoefficient
        };
      }
      ;
      module.exports = __webpack_exports__;
    })();
  }
});

// node_modules/@web3auth/mpc-core-kit/node_modules/@toruslabs/constants/dist/lib.esm/constants.js
var TORUS_LEGACY_NETWORK = {
  MAINNET: "mainnet",
  TESTNET: "testnet",
  CYAN: "cyan",
  AQUA: "aqua",
  CELESTE: "celeste"
};
var TORUS_SAPPHIRE_NETWORK = {
  SAPPHIRE_DEVNET: "sapphire_devnet",
  SAPPHIRE_MAINNET: "sapphire_mainnet"
};
var PROXY_CONTRACT_ADDRESS = {
  [TORUS_LEGACY_NETWORK.MAINNET]: "0xf20336e16B5182637f09821c27BDe29b0AFcfe80",
  [TORUS_LEGACY_NETWORK.TESTNET]: "0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A",
  [TORUS_LEGACY_NETWORK.CYAN]: "0x9f072ba19b3370e512aa1b4bfcdaf97283168005",
  [TORUS_LEGACY_NETWORK.AQUA]: "0x29Dea82a0509153b91040ee13cDBba0f03efb625",
  [TORUS_LEGACY_NETWORK.CELESTE]: "0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c"
};
var LEGACY_NETWORKS_ROUTE_MAP = {
  [TORUS_LEGACY_NETWORK.AQUA]: {
    migrationCompleted: true,
    networkIdentifier: "aqua",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.CELESTE]: {
    migrationCompleted: true,
    networkIdentifier: "celeste",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.CYAN]: {
    migrationCompleted: true,
    networkIdentifier: "cyan",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.MAINNET]: {
    migrationCompleted: true,
    networkIdentifier: "mainnet",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK.TESTNET]: {
    migrationCompleted: true,
    networkIdentifier: "teal",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET
  }
};
var NETWORK_MAP = {
  [TORUS_LEGACY_NETWORK.MAINNET]: "mainnet",
  [TORUS_LEGACY_NETWORK.TESTNET]: "goerli",
  [TORUS_LEGACY_NETWORK.CYAN]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK.AQUA]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK.CELESTE]: "polygon-mainnet"
};
var SIGNER_MAP = {
  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET]: "https://signer.web3auth.io",
  [TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK.MAINNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK.TESTNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK.CYAN]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK.AQUA]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK.CELESTE]: "https://signer-polygon.web3auth.io"
};
var METADATA_MAP = {
  [TORUS_LEGACY_NETWORK.MAINNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.TESTNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.CYAN]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.AQUA]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK.CELESTE]: "https://metadata.web3auth.io"
};
var KEY_TYPE = {
  SECP256K1: "secp256k1",
  ED25519: "ed25519"
};

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/constants.js
var WEB3AUTH_NETWORK = {
  MAINNET: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_MAINNET,
  DEVNET: TORUS_SAPPHIRE_NETWORK.SAPPHIRE_DEVNET
};
var USER_PATH = {
  NEW: "NewAccount",
  EXISTING: "ExistingAccount",
  REHYDRATE: "RehydrateAccount",
  RECOVER: "RecoverAccount"
};
var FactorKeyTypeShareDescription = function(FactorKeyTypeShareDescription2) {
  FactorKeyTypeShareDescription2["HashedShare"] = "hashedShare";
  FactorKeyTypeShareDescription2["SecurityQuestions"] = "tssSecurityQuestions";
  FactorKeyTypeShareDescription2["DeviceShare"] = "deviceShare";
  FactorKeyTypeShareDescription2["SeedPhrase"] = "seedPhrase";
  FactorKeyTypeShareDescription2["PasswordShare"] = "passwordShare";
  FactorKeyTypeShareDescription2["SocialShare"] = "socialShare";
  FactorKeyTypeShareDescription2["Other"] = "Other";
  return FactorKeyTypeShareDescription2;
}({});
var DELIMITERS = {
  Delimiter1: "",
  Delimiter2: "",
  Delimiter3: "",
  Delimiter4: ""
};
var ERRORS = {
  TKEY_SHARES_REQUIRED: "required more shares",
  INVALID_BACKUP_SHARE: "invalid backup share"
};
var SOCIAL_FACTOR_INDEX = 1;
var TssShareType = function(TssShareType2) {
  TssShareType2[TssShareType2["DEVICE"] = 2] = "DEVICE";
  TssShareType2[TssShareType2["RECOVERY"] = 3] = "RECOVERY";
  return TssShareType2;
}({});
var VALID_SHARE_INDICES = [TssShareType.DEVICE, TssShareType.RECOVERY];
var SCALAR_LEN = 32;
var FIELD_ELEMENT_HEX_LEN = 32 * 2;
var MAX_FACTORS = 10;
var SOCIAL_TKEY_INDEX = 1;

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/helper/errors.js
function fixProto(target, prototype) {
  const {
    setPrototypeOf
  } = Object;
  if (setPrototypeOf) {
    setPrototypeOf(target, prototype);
  } else {
    target.__proto__ = prototype;
  }
}
function fixStack(target, fn = target.constructor) {
  const {
    captureStackTrace
  } = Error;
  if (captureStackTrace) {
    captureStackTrace(target, fn);
  }
}
var CustomError = class extends Error {
  constructor(message, options) {
    super(message, options);
    _defineProperty(this, "name", void 0);
    Object.defineProperty(this, "name", {
      value: new.target.name,
      enumerable: false,
      configurable: true
    });
    fixProto(this, new.target.prototype);
    fixStack(this);
  }
};
var AbstractCoreKitError = class extends CustomError {
  constructor(code, message) {
    super(message);
    _defineProperty(this, "code", void 0);
    _defineProperty(this, "message", void 0);
    this.code = code;
    this.message = message || "";
    Object.defineProperty(this, "name", {
      value: "TkeyError"
    });
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message
    };
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
};
var CoreKitError = class _CoreKitError extends AbstractCoreKitError {
  constructor(code, message) {
    super(code, message);
    Object.defineProperty(this, "name", {
      value: "CoreKitError"
    });
  }
  static fromCode(code, extraMessage = "") {
    return new _CoreKitError(code, `${_CoreKitError.messages[code]} ${extraMessage}`);
  }
  static default(extraMessage = "") {
    return new _CoreKitError(1e3, `${_CoreKitError.messages[1e3]} ${extraMessage}`);
  }
  // Configuration errors
  static chainConfigInvalid(extraMessage = "") {
    return _CoreKitError.fromCode(1001, extraMessage);
  }
  static clientIdInvalid(extraMessage = "") {
    return _CoreKitError.fromCode(1002, extraMessage);
  }
  static storageTypeUnsupported(extraMessage = "") {
    return _CoreKitError.fromCode(1003, extraMessage);
  }
  static oauthLoginUnsupported(extraMessage = "") {
    return _CoreKitError.fromCode(1004, extraMessage);
  }
  static noValidStorageOptionFound(extraMessage = "") {
    return _CoreKitError.fromCode(1005, extraMessage);
  }
  static noDataFoundInStorage(extraMessage = "") {
    return _CoreKitError.fromCode(1006, extraMessage);
  }
  static invalidConfig(extraMessage = "") {
    return _CoreKitError.fromCode(1007, extraMessage);
  }
  // TSS and key management errors
  static tssLibRequired(extraMessage = "") {
    return _CoreKitError.fromCode(1101, extraMessage);
  }
  static tkeyInstanceUninitialized(extraMessage = "") {
    return _CoreKitError.fromCode(1102, extraMessage);
  }
  static duplicateTssIndex(extraMessage = "") {
    return _CoreKitError.fromCode(1103, extraMessage);
  }
  static nodeDetailsRetrievalFailed(extraMessage = "") {
    return _CoreKitError.fromCode(1104, extraMessage);
  }
  static prefetchValueExceeded(extraMessage = "") {
    return _CoreKitError.fromCode(1105, extraMessage);
  }
  static invalidTorusLoginResponse(extraMessage = "") {
    return _CoreKitError.fromCode(1106, extraMessage);
  }
  static invalidTorusAggregateLoginResponse(extraMessage = "") {
    return _CoreKitError.fromCode(1107, extraMessage);
  }
  static unsupportedRedirectMethod(extraMessage = "") {
    return _CoreKitError.fromCode(1108, extraMessage);
  }
  static postBoxKeyMissing(extraMessage = "") {
    return _CoreKitError.fromCode(1109, extraMessage);
  }
  static tssShareTypeIndexMissing(extraMessage = "") {
    return _CoreKitError.fromCode(1110, extraMessage);
  }
  static tssPublicKeyOrEndpointsMissing(extraMessage = "") {
    return _CoreKitError.fromCode(1111, extraMessage);
  }
  static activeSessionNotFound(extraMessage = "") {
    return _CoreKitError.fromCode(1112, extraMessage);
  }
  static tssNoncesMissing(extraMessage = "") {
    return _CoreKitError.fromCode(1113, extraMessage);
  }
  static tssKeyImportNotAllowed(extraMessage = "") {
    return _CoreKitError.fromCode(1114, extraMessage);
  }
  // Factor key and authentication errors
  static factorKeyNotPresent(extraMessage = "") {
    return _CoreKitError.fromCode(1201, extraMessage);
  }
  static factorKeyAlreadyExists(extraMessage = "") {
    return _CoreKitError.fromCode(1202, extraMessage);
  }
  static mfaAlreadyEnabled(extraMessage = "") {
    return _CoreKitError.fromCode(1203, extraMessage);
  }
  static cannotDeleteLastFactor(extraMessage = "") {
    return _CoreKitError.fromCode(1204, extraMessage);
  }
  static factorInUseCannotBeDeleted(extraMessage = "") {
    return _CoreKitError.fromCode(1205, extraMessage);
  }
  static userNotLoggedIn(extraMessage = "") {
    return _CoreKitError.fromCode(1206, extraMessage);
  }
  static providedFactorKeyInvalid(extraMessage = "") {
    return _CoreKitError.fromCode(1207, extraMessage);
  }
  static factorEncsMissing(extraMessage = "") {
    return _CoreKitError.fromCode(1208, extraMessage);
  }
  static noMetadataFound(extraMessage = "") {
    return _CoreKitError.fromCode(1209, extraMessage);
  }
  static newShareIndexInvalid(extraMessage = "") {
    return _CoreKitError.fromCode(1210, extraMessage);
  }
  static maximumFactorsReached(extraMessage = "") {
    return _CoreKitError.fromCode(1211, extraMessage);
  }
  static noMetadataShareFound(extraMessage = "") {
    return _CoreKitError.fromCode(1212, extraMessage);
  }
  static signaturesNotPresent(extraMessage = "") {
    return _CoreKitError.fromCode(1213, extraMessage);
  }
  static factorPubsMissing(extraMessage = "") {
    return _CoreKitError.fromCode(1214, extraMessage);
  }
  // Initialization and session management
  static commitChangesBeforeMFA(extraMessage = "") {
    return _CoreKitError.fromCode(1301, extraMessage);
  }
  static mpcCoreKitNotInitialized(extraMessage = "") {
    return _CoreKitError.fromCode(1302, extraMessage);
  }
};
_defineProperty(CoreKitError, "messages", {
  // Configuration errors
  1001: "You must specify a valid eip155 chain configuration in the options.",
  1002: "You must specify a web3auth clientId.",
  1003: "Unsupported storage type in this UX mode.",
  1004: "OAuth login is NOT supported in this UX mode.",
  1005: "No valid storage option found.",
  1006: "No data found in storage.",
  1007: "Invalid config.",
  // TSS and key management errors
  1101: "'tssLib' is required when running in this UX mode.",
  1102: "'tkey' instance has not been initialized.",
  1103: "Duplicate TSS index found. Ensure that each TSS index is unique.",
  1104: "Failed to retrieve node details. Please check your network connection and try again.",
  1105: "The prefetch TSS public keys exceeds the maximum allowed limit of 3.",
  1106: "Invalid 'TorusLoginResponse' data provided.",
  1107: "Invalid 'TorusAggregateLoginResponse' data provided.",
  1108: "Unsupported method type encountered in redirect result.",
  1109: "OAuthKey not present in state.",
  1110: "TSS Share Type (Index) not present in state when getting current factor key.",
  1111: "'tssPubKey' or 'torusNodeTSSEndpoints' are missing.",
  1112: "No active session found.",
  1113: "tssNonces not present in metadata when getting tss nonce.",
  1114: "A TSS key cannot be imported for an existing user who already has a key configured.",
  // Factor key and authentication errors
  1201: "factorKey not present in state when required.",
  1202: "A factor with the same key already exists.",
  1203: "MFA is already enabled.",
  1204: "Cannot delete the last remaining factor as at least one factor is required.",
  1205: "The factor currently in use cannot be deleted.",
  1206: "User is not logged in.",
  1207: "Provided factor key is invalid.",
  1208: "'factorEncs' mpt [resemt].",
  1209: "No metadata found for the provided factor key. Consider resetting your account if this error persists.",
  1210: "The new share index is not valid. It must be one of the valid share indices.",
  1211: "The maximum number of allowable factors (10) has been reached.",
  1212: "No metadata share found in the current polynomial.",
  1213: "No signatures found.",
  1214: "Factor public keys not present",
  // Initialization and session management
  1301: "The 'CommitChanges' method must be called before enabling MFA.",
  1302: "The MPC Core Kit is not initialized. Please ensure you call the 'init()' method to initialize the kit properly before attempting any operations."
});

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/helper/browserStorage.js
var MemoryStorage = class {
  constructor() {
    _defineProperty(this, "_store", {});
  }
  getItem(key) {
    return this._store[key] || null;
  }
  setItem(key, value) {
    this._store[key] = value;
  }
  removeItem(key) {
    delete this._store[key];
  }
  clear() {
    this._store = {};
  }
};
var AsyncStorage = class {
  constructor(storeKey, storage) {
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_storeKey", void 0);
    this.storage = storage;
    this._storeKey = storeKey;
  }
  async toJSON() {
    const result = await this.storage.getItem(this._storeKey);
    if (!result) {
      throw CoreKitError.noDataFoundInStorage(`No data found in storage under key '${this._storeKey}'.`);
    }
    return result;
  }
  async resetStore() {
    const currStore = await this.getStore();
    await this.storage.setItem(this._storeKey, JSON.stringify({}));
    return currStore;
  }
  async getStore() {
    return JSON.parse(await this.storage.getItem(this._storeKey) || "{}");
  }
  async get(key) {
    const store = JSON.parse(await this.storage.getItem(this._storeKey) || "{}");
    return store[key];
  }
  async set(key, value) {
    const store = JSON.parse(await this.storage.getItem(this._storeKey) || "{}");
    store[key] = value;
    await this.storage.setItem(this._storeKey, JSON.stringify(store));
  }
  async remove(key) {
    const store = JSON.parse(await this.storage.getItem(this._storeKey) || "{}");
    delete store[key];
    await this.storage.setItem(this._storeKey, JSON.stringify(store));
  }
};

// node_modules/@tkey/share-serialization/dist/lib.esm/errors.js
var ShareSerializationError = class _ShareSerializationError extends TkeyError {
  constructor(code, message) {
    super(code, message);
    Object.defineProperty(this, "name", {
      value: "ShareSerializationError"
    });
  }
  static fromCode(code, extraMessage = "") {
    return new _ShareSerializationError(code, `${_ShareSerializationError.messages[code]}${extraMessage}`);
  }
  static default(extraMessage = "") {
    return new _ShareSerializationError(7e3, `${_ShareSerializationError.messages[7e3]}${extraMessage}`);
  }
  // Custom methods
  static typeNotSupported(extraMessage = "") {
    return _ShareSerializationError.fromCode(7010, extraMessage);
  }
  static invalidEntropy(extraMessage = "") {
    return _ShareSerializationError.fromCode(7011, extraMessage);
  }
  static invalidChecksum(extraMessage = "") {
    return _ShareSerializationError.fromCode(7012, extraMessage);
  }
  static invalidMnemonic(extraMessage = "") {
    return _ShareSerializationError.fromCode(7013, extraMessage);
  }
};
_defineProperty(ShareSerializationError, "messages", {
  7e3: "Custom",
  // Misc
  7010: "Type is not supported",
  7011: "Invalid Entropy",
  7012: "Invalid Checksum",
  7013: "Invalid mnemonic"
});
var ShareSerializationError$1 = ShareSerializationError;

// node_modules/@tkey/share-serialization/dist/lib.esm/ShareSerializationModule.js
var import_bn = __toESM(require_bn());

// node_modules/@tkey/share-serialization/dist/lib.esm/english.js
var english = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"];

// node_modules/@tkey/share-serialization/dist/lib.esm/utils.js
function normalize(str) {
  return (str || "").normalize("NFKD");
}
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function lpad(str, padString, length) {
  let string = str;
  while (string.length < length) {
    string = padString + string;
  }
  return string;
}
function bytesToBinary(bytes) {
  return bytes.map((x) => lpad(x.toString(2), "0", 8)).join("");
}
function deriveChecksumBits(entropyBuffer) {
  const ENT = entropyBuffer.length * 8;
  const CS = ENT / 32;
  const hash = sha256(entropyBuffer);
  return bytesToBinary(Array.from(hash)).slice(0, CS);
}
function entropyToMnemonic(entropy, english2) {
  let newEntropy;
  if (!Buffer.isBuffer(entropy)) {
    newEntropy = Buffer.from(entropy, "hex");
  }
  if (newEntropy.length < 16) {
    throw ShareSerializationError$1.invalidEntropy();
  }
  if (newEntropy.length > 32) {
    throw ShareSerializationError$1.invalidEntropy();
  }
  if (newEntropy.length % 4 !== 0) {
    throw ShareSerializationError$1.invalidEntropy();
  }
  const entropyBits = bytesToBinary(Array.from(newEntropy));
  const checksumBits = deriveChecksumBits(newEntropy);
  const bits = entropyBits + checksumBits;
  const chunks = bits.match(/(.{1,11})/g);
  const words = chunks.map((binary) => {
    const index = binaryToByte(binary);
    return english2[index];
  });
  return english2[0] === "あいこくしん" ? words.join("　") : words.join(" ");
}
function mnemonicToEntropy(mnemonic, english2) {
  const words = normalize(mnemonic).split(" ");
  if (words.length % 3 !== 0) {
    throw ShareSerializationError$1.invalidMnemonic();
  }
  const bits = words.map((word) => {
    const index = english2.indexOf(word);
    if (index === -1) {
      throw ShareSerializationError$1.invalidMnemonic();
    }
    return lpad(index.toString(2), "0", 11);
  }).join("");
  const dividerIndex = Math.floor(bits.length / 33) * 32;
  const entropyBits = bits.slice(0, dividerIndex);
  const checksumBits = bits.slice(dividerIndex);
  const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
  if (entropyBytes.length < 16) {
    throw ShareSerializationError$1.invalidEntropy();
  }
  if (entropyBytes.length > 32) {
    throw ShareSerializationError$1.invalidEntropy();
  }
  if (entropyBytes.length % 4 !== 0) {
    throw ShareSerializationError$1.invalidEntropy();
  }
  const entropy = Buffer.from(entropyBytes);
  const newChecksum = deriveChecksumBits(entropy);
  if (newChecksum !== checksumBits) {
    throw ShareSerializationError$1.invalidChecksum();
  }
  return entropy.toString("hex");
}

// node_modules/@tkey/share-serialization/dist/lib.esm/ShareSerializationModule.js
var SHARE_SERIALIZATION_MODULE_NAME = "shareSerialization";
var ShareSerializationModule = class _ShareSerializationModule {
  constructor() {
    _defineProperty(this, "moduleName", void 0);
    _defineProperty(this, "tbSDK", void 0);
    this.moduleName = SHARE_SERIALIZATION_MODULE_NAME;
  }
  static serializeMnemonic(share) {
    return entropyToMnemonic(share.toString("hex").padStart(64, "0"), english);
  }
  static deserializeMnemonic(share) {
    return new import_bn.default(mnemonicToEntropy(share, english), "hex");
  }
  setModuleReferences(tbSDK) {
    this.tbSDK = tbSDK;
    this.tbSDK._addShareSerializationMiddleware(this.serialize.bind(this), this.deserialize.bind(this));
  }
  // eslint-disable-next-line
  async initialize() {
  }
  async serialize(share, type) {
    if (type === "mnemonic") {
      return _ShareSerializationModule.serializeMnemonic(share);
    }
    throw ShareSerializationError$1.typeNotSupported();
  }
  async deserialize(serializedShare, type) {
    if (type === "mnemonic") return _ShareSerializationModule.deserializeMnemonic(serializedShare);
    throw ShareSerializationError$1.typeNotSupported();
  }
};
var ShareSerializationModule$1 = ShareSerializationModule;

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/helper/factorSerialization.js
var import_bn2 = __toESM(require_bn());
function mnemonicToKey(shareMnemonic) {
  const factorKey = ShareSerializationModule$1.deserializeMnemonic(shareMnemonic);
  return factorKey.toString("hex");
}
function keyToMnemonic(shareHex) {
  const shareBN = new import_bn2.default(shareHex, "hex");
  const mnemonic = ShareSerializationModule$1.serializeMnemonic(shareBN);
  return mnemonic;
}

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/helper/securityQuestion.js
var import_bn3 = __toESM(require_bn());
var TssSecurityQuestionStore = class _TssSecurityQuestionStore {
  constructor(shareIndex, factorPublicKey, question) {
    _defineProperty(this, "shareIndex", void 0);
    _defineProperty(this, "factorPublicKey", void 0);
    _defineProperty(this, "question", void 0);
    this.shareIndex = shareIndex;
    this.factorPublicKey = factorPublicKey;
    this.question = question;
  }
  static fromJSON(json) {
    const {
      shareIndex,
      factorPublicKey,
      question
    } = json;
    return new _TssSecurityQuestionStore(shareIndex, factorPublicKey, question);
  }
  toJSON() {
    return {
      shareIndex: this.shareIndex,
      factorPublicKey: this.factorPublicKey,
      question: this.question
    };
  }
};
var TssSecurityQuestion = class {
  constructor() {
    _defineProperty(this, "storeDomainName", "tssSecurityQuestion");
  }
  async setSecurityQuestion(params) {
    const {
      mpcCoreKit,
      question,
      answer,
      description
    } = params;
    let {
      shareType
    } = params;
    if (!mpcCoreKit.tKey) {
      throw new Error("Tkey not initialized, call init first.");
    }
    if (!question || !answer) {
      throw new Error("question and answer are required");
    }
    const domainKey = `${this.storeDomainName}:${params.mpcCoreKit.tKey.tssTag}`;
    if (!shareType) {
      shareType = TssShareType.RECOVERY;
    } else if (!VALID_SHARE_INDICES.includes(shareType)) {
      throw new Error(`invalid share type: must be one of ${VALID_SHARE_INDICES}`);
    }
    const tkey = mpcCoreKit.tKey;
    const storeDomain = tkey.metadata.getGeneralStoreDomain(domainKey);
    if (storeDomain && storeDomain.question) {
      throw new Error("Security question already exists");
    }
    const pubKey = tkey.getKeyDetails().pubKey.toSEC1(secp256k1, true).toString("hex") + tkey.tssTag;
    let hash = keccak2563(Buffer.from(answer + pubKey, "utf8"));
    hash = hash.startsWith("0x") ? hash.slice(2) : hash;
    const factorKeyBN = new import_bn3.default(hash, "hex");
    const descriptionFinal = _objectSpread2({
      question
    }, description);
    await mpcCoreKit.createFactor({
      factorKey: factorKeyBN,
      shareType,
      shareDescription: FactorKeyTypeShareDescription.SecurityQuestions,
      additionalMetadata: descriptionFinal
    });
    const tkeyPt = getPubKeyPoint2(factorKeyBN, factorKeyCurve);
    const factorPub = tkeyPt.toSEC1(factorKeyCurve, true).toString("hex");
    const storeData = new TssSecurityQuestionStore(shareType.toString(), factorPub, question);
    tkey.metadata.setGeneralStoreDomain(domainKey, storeData.toJSON());
    if (!tkey.manualSync) await tkey._syncShareMetadata();
    return factorKeyBN.toString("hex").padStart(64, "0");
  }
  async changeSecurityQuestion(params) {
    const {
      mpcCoreKit,
      newQuestion,
      newAnswer,
      answer
    } = params;
    if (!newQuestion || !newAnswer || !answer) {
      throw new Error("question and answer are required");
    }
    const tkey = mpcCoreKit.tKey;
    const pubKey = tkey.getKeyDetails().pubKey.toSEC1(secp256k1, true).toString("hex") + tkey.tssTag;
    const domainKey = `${this.storeDomainName}:${params.mpcCoreKit.tKey.tssTag}`;
    const storeDomain = tkey.metadata.getGeneralStoreDomain(domainKey);
    if (!storeDomain || !storeDomain.question) {
      throw new Error("Security question does not exists");
    }
    const store = TssSecurityQuestionStore.fromJSON(storeDomain);
    const preHash = answer + pubKey;
    let hash = keccak2563(Buffer.from(preHash, "utf8"));
    hash = hash.startsWith("0x") ? hash.slice(2) : hash;
    const factorKeyBN = new import_bn3.default(hash, "hex");
    const factorKeyPt = getPubKeyPoint2(factorKeyBN, factorKeyCurve);
    if (factorKeyPt.toSEC1(factorKeyCurve, true).toString("hex") !== store.factorPublicKey) {
      throw new Error("Invalid answer");
    }
    const prenewHash = newAnswer + pubKey;
    let newHash = keccak2563(Buffer.from(prenewHash, "utf8"));
    newHash = newHash.startsWith("0x") ? newHash.slice(2) : newHash;
    const newAnswerBN = new import_bn3.default(newHash, "hex");
    const newFactorPt = Point$1.fromScalar(newAnswerBN, factorKeyCurve);
    await mpcCoreKit.createFactor({
      factorKey: newAnswerBN,
      shareType: parseInt(store.shareIndex),
      shareDescription: FactorKeyTypeShareDescription.SecurityQuestions
    });
    if (mpcCoreKit.state.factorKey.eq(factorKeyBN)) {
      await mpcCoreKit.inputFactorKey(newAnswerBN);
    }
    await mpcCoreKit.deleteFactor(factorKeyPt, factorKeyBN);
    store.factorPublicKey = newFactorPt.toSEC1(factorKeyCurve, true).toString("hex");
    store.question = newQuestion;
    tkey.metadata.setGeneralStoreDomain(domainKey, store.toJSON());
    if (!tkey.manualSync) await tkey._syncShareMetadata();
  }
  // Should we check with answer before deleting?
  async deleteSecurityQuestion(mpcCoreKit, deleteFactorKey = true) {
    if (!mpcCoreKit.tKey) {
      throw new Error("Tkey not initialized, call init first.");
    }
    const domainKey = `${this.storeDomainName}:${mpcCoreKit.tKey.tssTag}`;
    const tkey = mpcCoreKit.tKey;
    if (deleteFactorKey) {
      const storeDomain = tkey.metadata.getGeneralStoreDomain(domainKey);
      if (!storeDomain || !storeDomain.question) {
        throw new Error("Security question does not exists");
      }
      const store = TssSecurityQuestionStore.fromJSON(storeDomain);
      if (store.factorPublicKey) {
        await mpcCoreKit.deleteFactor(Point$1.fromSEC1(factorKeyCurve, store.factorPublicKey));
      }
    }
    tkey.metadata.deleteGeneralStoreDomain(domainKey);
    if (!tkey.manualSync) await tkey._syncShareMetadata();
  }
  async recoverFactor(mpcCoreKit, answer) {
    if (!mpcCoreKit.tKey) {
      throw new Error("Tkey not initialized, call init first.");
    }
    if (!answer) {
      throw new Error("question and answer are required");
    }
    const tkey = mpcCoreKit.tKey;
    const domainKey = `${this.storeDomainName}:${mpcCoreKit.tKey.tssTag}`;
    const storeDomain = tkey.metadata.getGeneralStoreDomain(domainKey);
    if (!storeDomain || !storeDomain.question) {
      throw new Error("Security question does not exists");
    }
    const store = TssSecurityQuestionStore.fromJSON(storeDomain);
    const pubKey = tkey.getKeyDetails().pubKey.toSEC1(secp256k1, true).toString("hex") + tkey.tssTag;
    let hash = keccak2563(Buffer.from(answer + pubKey, "utf8"));
    hash = hash.startsWith("0x") ? hash.slice(2) : hash;
    const factorKeyBN = new import_bn3.default(hash, "hex");
    const factorKeyPt = Point$1.fromScalar(factorKeyBN, factorKeyCurve);
    if (factorKeyPt.toSEC1(factorKeyCurve, true).toString("hex") !== store.factorPublicKey) {
      throw new Error("Invalid answer");
    }
    return hash;
  }
  getQuestion(mpcCoreKit) {
    if (!mpcCoreKit.tKey) {
      throw new Error("Tkey not initialized, call init first.");
    }
    const tkey = mpcCoreKit.tKey;
    const domainKey = `${this.storeDomainName}:${mpcCoreKit.tKey.tssTag}`;
    const storeDomain = tkey.metadata.getGeneralStoreDomain(domainKey);
    if (!storeDomain || !storeDomain.question) {
      throw new Error("Security question does not exists");
    }
    const store = TssSecurityQuestionStore.fromJSON(storeDomain);
    return store.question;
  }
};

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/interfaces.js
var COREKIT_STATUS = function(COREKIT_STATUS2) {
  COREKIT_STATUS2["NOT_INITIALIZED"] = "NOT_INITIALIZED";
  COREKIT_STATUS2["INITIALIZED"] = "INITIALIZED";
  COREKIT_STATUS2["REQUIRED_SHARE"] = "REQUIRED_SHARE";
  COREKIT_STATUS2["LOGGED_IN"] = "LOGGED_IN";
  return COREKIT_STATUS2;
}({});

// node_modules/@tkey/storage-layer-torus/dist/lib.esm/MockStorageLayer.js
var import_json_stable_stringify = __toESM(require_json_stable_stringify());

// node_modules/@tkey/storage-layer-torus/dist/lib.esm/TorusStorageLayer.js
var import_base64url = __toESM(require_base64url());
var import_bn4 = __toESM(require_bn());
var import_json_stable_stringify2 = __toESM(require_json_stable_stringify());
function signDataWithPrivKey(data, privKey) {
  const sig = secp256k1.sign(keccak256(Buffer.from((0, import_json_stable_stringify2.default)(data), "utf8")), toPrivKeyECC(privKey), "utf-8");
  return sig.toDER("hex");
}
var TorusStorageLayer = class _TorusStorageLayer {
  constructor({
    enableLogging = false,
    hostUrl = "http://localhost:5051",
    serverTimeOffset = 0
  }) {
    _defineProperty(this, "enableLogging", void 0);
    _defineProperty(this, "hostUrl", void 0);
    _defineProperty(this, "storageLayerName", void 0);
    _defineProperty(this, "serverTimeOffset", void 0);
    this.enableLogging = enableLogging;
    this.hostUrl = hostUrl;
    this.storageLayerName = "TorusStorageLayer";
    this.serverTimeOffset = serverTimeOffset;
  }
  static async serializeMetadataParamsInput(el, serviceProvider, privKey) {
    if (typeof el === "object") {
      const obj = el;
      const isCommandMessage = obj.message === ONE_KEY_DELETE_NONCE;
      if (isCommandMessage) return obj.message;
    }
    const bufferMetadata = Buffer.from((0, import_json_stable_stringify2.default)(el));
    let encryptedDetails;
    if (privKey) {
      encryptedDetails = await encrypt(getPubKeyECC(privKey), bufferMetadata);
    } else {
      encryptedDetails = await serviceProvider.encrypt(bufferMetadata);
    }
    const serializedEncryptedDetails = import_base64url.default.encode((0, import_json_stable_stringify2.default)(encryptedDetails));
    return serializedEncryptedDetails;
  }
  static fromJSON(value) {
    const {
      enableLogging,
      hostUrl,
      storageLayerName,
      serverTimeOffset = 0
    } = value;
    if (storageLayerName !== "TorusStorageLayer") return void 0;
    return new _TorusStorageLayer({
      enableLogging,
      hostUrl,
      serverTimeOffset
    });
  }
  /**
   *  Get metadata for a key
   * @param privKey - If not provided, it will use service provider's share for decryption
   */
  async getMetadata(params) {
    const {
      serviceProvider,
      privKey
    } = params;
    const keyDetails = this.generateMetadataParams({}, serviceProvider, privKey);
    const metadataResponse = await post(`${this.hostUrl}/get`, keyDetails);
    if (metadataResponse.message === "") {
      return {
        message: KEY_NOT_FOUND
      };
    }
    const encryptedMessage = JSON.parse(import_base64url.default.decode(metadataResponse.message));
    let decrypted;
    if (privKey) {
      decrypted = await decrypt(toPrivKeyECC(privKey), encryptedMessage);
    } else {
      decrypted = await serviceProvider.decrypt(encryptedMessage);
    }
    return JSON.parse(decrypted.toString());
  }
  /**
   * Set Metadata for a key
   * @param input - data to post
   * @param privKey - If not provided, it will use service provider's share for encryption
   */
  async setMetadata(params) {
    try {
      const {
        serviceProvider,
        privKey,
        input
      } = params;
      const metadataParams = this.generateMetadataParams(await _TorusStorageLayer.serializeMetadataParamsInput(input, serviceProvider, privKey), serviceProvider, privKey);
      return await post(`${this.hostUrl}/set`, metadataParams);
    } catch (error) {
      const prettyError = await prettyPrintError(error);
      throw prettyError;
    }
  }
  async setMetadataStream(params) {
    try {
      const {
        serviceProvider,
        privKey,
        input
      } = params;
      const newInput = input;
      const finalMetadataParams = await Promise.all(newInput.map(async (el, i) => this.generateMetadataParams(await _TorusStorageLayer.serializeMetadataParamsInput(el, serviceProvider, privKey[i]), serviceProvider, privKey[i])));
      const FD = new FormData();
      finalMetadataParams.forEach((el, index) => {
        FD.append(index.toString(), JSON.stringify(el));
      });
      const options = {
        mode: "cors",
        method: "POST",
        headers: {
          // don't set ContentType header here. it's handled in http-helpers
        }
      };
      const customOptions = {
        isUrlEncodedData: true,
        timeout: 600 * 1e3
        // 10 mins of timeout for excessive shares case
      };
      return await post(`${this.hostUrl}/bulk_set_stream`, FD, options, customOptions);
    } catch (error) {
      const prettyError = await prettyPrintError(error);
      throw prettyError;
    }
  }
  generateMetadataParams(message, serviceProvider, privKey) {
    let sig;
    let pubX;
    let pubY;
    let namespace = "tkey";
    const setTKeyStore = {
      data: message,
      timestamp: new import_bn4.default(~~(this.serverTimeOffset + Date.now() / 1e3)).toString(16)
    };
    if (message === ONE_KEY_DELETE_NONCE) {
      namespace = ONE_KEY_NAMESPACE;
      setTKeyStore.data = "<deleted>";
    }
    const hash = keccak256(Buffer.from((0, import_json_stable_stringify2.default)(setTKeyStore), "utf8"));
    if (privKey) {
      const unparsedSig = toPrivKeyEC(privKey).sign(hash);
      sig = Buffer.from(unparsedSig.r.toString(16, 64) + unparsedSig.s.toString(16, 64) + new import_bn4.default(0).toString(16, 2), "hex").toString("base64");
      const pubK = getPubKeyPoint(privKey);
      pubX = pubK.x.toString("hex");
      pubY = pubK.y.toString("hex");
    } else {
      const point = serviceProvider.retrievePubKeyPoint();
      sig = serviceProvider.sign(new import_bn4.default(hash));
      pubX = point.getX().toString("hex");
      pubY = point.getY().toString("hex");
    }
    return {
      pub_key_X: pubX,
      pub_key_Y: pubY,
      set_data: setTKeyStore,
      signature: sig,
      namespace
    };
  }
  async acquireWriteLock(params) {
    const {
      serviceProvider,
      privKey
    } = params;
    const data = {
      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1e3)
    };
    let signature;
    if (privKey) {
      signature = signDataWithPrivKey(data, privKey);
    } else {
      signature = serviceProvider.sign(new import_bn4.default(keccak256(Buffer.from((0, import_json_stable_stringify2.default)(data), "utf8"))));
    }
    const metadataParams = {
      key: toPrivKeyEC(privKey).getPublic("hex"),
      data,
      signature
    };
    return post(`${this.hostUrl}/acquireLock`, metadataParams);
  }
  async releaseWriteLock(params) {
    const {
      serviceProvider,
      privKey,
      id
    } = params;
    const data = {
      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1e3)
    };
    let signature;
    if (privKey) {
      signature = signDataWithPrivKey(data, privKey);
    } else {
      signature = serviceProvider.sign(new import_bn4.default(keccak256(Buffer.from((0, import_json_stable_stringify2.default)(data), "utf8"))));
    }
    const metadataParams = {
      key: toPrivKeyEC(privKey).getPublic("hex"),
      data,
      signature,
      id
    };
    return post(`${this.hostUrl}/releaseLock`, metadataParams);
  }
  toJSON() {
    return {
      enableLogging: this.enableLogging,
      hostUrl: this.hostUrl,
      storageLayerName: this.storageLayerName
    };
  }
};
var TorusStorageLayer$1 = TorusStorageLayer;

// node_modules/@toruslabs/elliptic-wrapper/dist/ellipticWrapper.esm.js
var import_bn5 = __toESM(require_bn());
var import_elliptic = __toESM(require_elliptic());
var Ed25519Curve = class extends import_elliptic.default.ec {
  constructor() {
    super("ed25519");
  }
  bufferToScalar(b) {
    return new import_bn5.default(b, "le");
  }
  generateScalar() {
    return this.genKeyPair().getPrivate();
  }
  scalarToBuffer(s, buf) {
    s.toString("hex");
    return s.toArrayLike(buf, "le", 32);
  }
  pointToBuffer(p, buf) {
    const x = p.getX();
    const y = p.getY();
    const b = y.toArrayLike(buf, "le", 32);
    b[b.length - 1] |= x.and(new import_bn5.default(1)).eqn(1) ? 128 : 0;
    return b;
  }
};

// node_modules/@toruslabs/eccrypto/dist/eccrypto.esm.js
var import_crypto = __toESM(require_empty_module());
var import_elliptic2 = __toESM(require_elliptic());
var ec = new import_elliptic2.ec("secp256k1");
var browserCrypto = global.crypto || global.msCrypto || {};
var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
var ZERO32 = Buffer.alloc(32, 0);
function isScalar(x) {
  return Buffer.isBuffer(x) && x.length === 32;
}
function isValidPrivateKey(privateKey) {
  if (!isScalar(privateKey)) {
    return false;
  }
  return privateKey.compare(ZERO32) > 0 && // > 0
  privateKey.compare(EC_GROUP_ORDER) < 0;
}
function randomBytes(size) {
  const arr = new Uint8Array(size);
  if (typeof browserCrypto.getRandomValues === "undefined") {
    return Buffer.from(import_crypto.default.randomBytes(size));
  }
  browserCrypto.getRandomValues(arr);
  return Buffer.from(arr);
}
function getAes(op) {
  return async function(iv, key, data) {
    if (subtle) {
      const importAlgorithm = {
        name: "AES-CBC"
      };
      const cryptoKey = await subtle.importKey("raw", key, importAlgorithm, false, [op]);
      const encAlgorithm = {
        name: "AES-CBC",
        iv
      };
      const result = await subtle[op](encAlgorithm, cryptoKey, data);
      return Buffer.from(new Uint8Array(result));
    } else if (op === "encrypt") {
      const cipher = import_crypto.default.createCipheriv("aes-256-cbc", key, iv);
      const firstChunk = cipher.update(data);
      const secondChunk = cipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    } else if (op === "decrypt") {
      const decipher = import_crypto.default.createDecipheriv("aes-256-cbc", key, iv);
      const firstChunk = decipher.update(data);
      const secondChunk = decipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    }
    throw new Error(`Unsupported operation: ${op}`);
  };
}
var aesCbcEncrypt = getAes("encrypt");
var aesCbcDecrypt = getAes("decrypt");
var generatePrivate = function() {
  let privateKey = randomBytes(32);
  while (!isValidPrivateKey(privateKey)) {
    privateKey = randomBytes(32);
  }
  return privateKey;
};

// node_modules/@toruslabs/tss-client/dist/tssClient.esm.js
var import_bn6 = __toESM(require_bn());
var import_elliptic3 = __toESM(require_elliptic());
var WEB3_SESSION_HEADER_KEY = "x-web3-session-id";
var DELIMITERS2 = {
  Delimiter1: "",
  Delimiter2: "",
  Delimiter3: "",
  Delimiter4: ""
};
function getEc() {
  return new import_elliptic3.ec("secp256k1");
}
function getLagrangeCoeffs(_allIndexes, _myIndex) {
  let _target = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const ec4 = getEc();
  const allIndexes = _allIndexes.map((i) => new import_bn6.default(i));
  const myIndex = new import_bn6.default(_myIndex);
  const target = new import_bn6.default(_target);
  let upper = new import_bn6.default(1);
  let lower = new import_bn6.default(1);
  for (let j = 0; j < allIndexes.length; j += 1) {
    if (myIndex.cmp(allIndexes[j]) !== 0) {
      let tempUpper = target.sub(allIndexes[j]);
      tempUpper = tempUpper.umod(ec4.curve.n);
      upper = upper.mul(tempUpper);
      upper = upper.umod(ec4.curve.n);
      let tempLower = myIndex.sub(allIndexes[j]);
      tempLower = tempLower.umod(ec4.curve.n);
      lower = lower.mul(tempLower).umod(ec4.curve.n);
    }
  }
  return upper.mul(lower.invm(ec4.curve.n)).umod(ec4.curve.n);
}
var getAdditiveCoeff = (isUser, participatingServerIndexes, userTSSIndex, serverIndex) => {
  const ec4 = getEc();
  if (isUser) {
    return getLagrangeCoeffs([1, userTSSIndex], userTSSIndex);
  }
  const serverLagrangeCoeff = getLagrangeCoeffs(participatingServerIndexes, serverIndex);
  const masterLagrangeCoeff = getLagrangeCoeffs([1, userTSSIndex], 1);
  const additiveLagrangeCoeff = serverLagrangeCoeff.mul(masterLagrangeCoeff).umod(ec4.curve.n);
  return additiveLagrangeCoeff;
};
var getDenormaliseCoeff = (party, parties) => {
  if (parties.indexOf(party) === -1) throw new Error(`party ${party} not found in parties ${parties}`);
  const ec4 = getEc();
  const denormaliseLagrangeCoeff = getLagrangeCoeffs(parties, party).invm(ec4.curve.n).umod(ec4.curve.n);
  return denormaliseLagrangeCoeff;
};
var getDKLSCoeff = (isUser, participatingServerIndexes, userTSSIndex, serverIndex) => {
  const sortedServerIndexes = participatingServerIndexes.sort((a, b) => a - b);
  for (let i = 0; i < sortedServerIndexes.length; i++) {
    if (sortedServerIndexes[i] !== participatingServerIndexes[i]) throw new Error("server indexes must be sorted");
  }
  const parties = [];
  let serverPartyIndex = 0;
  for (let i = 0; i < participatingServerIndexes.length; i++) {
    const currentPartyIndex = i + 1;
    parties.push(currentPartyIndex);
    if (participatingServerIndexes[i] === serverIndex) serverPartyIndex = currentPartyIndex;
  }
  const userPartyIndex = parties.length + 1;
  parties.push(userPartyIndex);
  if (isUser) {
    const additiveCoeff2 = getAdditiveCoeff(isUser, participatingServerIndexes, userTSSIndex, serverIndex);
    const denormaliseCoeff2 = getDenormaliseCoeff(userPartyIndex, parties);
    const ec5 = getEc();
    return denormaliseCoeff2.mul(additiveCoeff2).umod(ec5.curve.n);
  }
  const additiveCoeff = getAdditiveCoeff(isUser, participatingServerIndexes, userTSSIndex, serverIndex);
  const denormaliseCoeff = getDenormaliseCoeff(serverPartyIndex, parties);
  const ec4 = getEc();
  const coeff = denormaliseCoeff.mul(additiveCoeff).umod(ec4.curve.n);
  return coeff;
};
var createSockets = async (wsEndpoints, sessionId) => {
  return wsEndpoints.map((wsEndpoint) => {
    if (wsEndpoint === null || wsEndpoint === void 0) {
      return null;
    }
    return lookup(wsEndpoint, {
      path: "/tss/socket.io",
      query: {
        sessionId
      },
      transports: ["websocket", "polling"],
      withCredentials: true,
      reconnectionDelayMax: 1e4,
      reconnectionAttempts: 5
    });
  });
};
var setupSockets = async (tssWSEndpoints, sessionId) => {
  const sockets = await createSockets(tssWSEndpoints, sessionId);
  await new Promise((resolve) => {
    const checkConnectionTimer = setInterval(() => {
      for (let i = 0; i < sockets.length; i++) {
        if (sockets[i] !== null && !sockets[i].connected) return;
      }
      clearInterval(checkConnectionTimer);
      resolve(true);
    }, 100);
  });
  return sockets;
};
if (globalThis.tss_clients === void 0) {
  globalThis.tss_clients = /* @__PURE__ */ new Map();
}
if (globalThis.js_read_msg === void 0) {
  globalThis.js_read_msg = async function(session, self_index, party, msg_type) {
    const tss_client = globalThis.tss_clients.get(session);
    tss_client.log(`reading msg, ${msg_type}`);
    if (msg_type === "ga1_worker_support") {
      return "unsupported";
    }
    const mm = tss_client.msgQueue.find((m) => m.sender === party && m.recipient === self_index && m.msg_type === msg_type);
    if (!mm) {
      return new Promise((resolve, reject) => {
        let counter = 0;
        const timer = setInterval(() => {
          const found = tss_client.msgQueue.find((m) => m.sender === party && m.recipient === self_index && m.msg_type === msg_type);
          if (found !== void 0) {
            clearInterval(timer);
            resolve(found.msg_data);
          }
          if (counter >= 1e3) {
            clearInterval(timer);
            reject("Message not received in a reasonable time");
          }
          counter++;
        }, 10);
      });
    }
    return mm.msg_data;
  };
}
if (globalThis.js_send_msg === void 0) {
  globalThis.js_send_msg = async function(session, self_index, party, msg_type, msg_data) {
    const tss_client = globalThis.tss_clients.get(session);
    tss_client.log(`sending msg, ${msg_type}`);
    if (msg_type.indexOf("ga1_data_unprocessed") > -1) {
      throw new Error("ga1_data_unprocessed should not be sent directly");
    }
    if (tss_client.websocketOnly) {
      const socket = tss_client.sockets[party];
      socket.emit("send_msg", {
        session,
        sender: self_index,
        recipient: party,
        msg_type,
        msg_data
      });
    } else {
      const sid = session.split(DELIMITERS2.Delimiter4)[1];
      const endpoint = tss_client.lookupEndpoint(session, party);
      fetch(`${endpoint}/send`, {
        method: "POST",
        headers: {
          [WEB3_SESSION_HEADER_KEY]: sid,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          session,
          sender: self_index,
          recipient: party,
          msg_type,
          msg_data
        })
      });
    }
    return true;
  };
}
var Client = class {
  // Note: create sockets externally before passing it in in the constructor to allow socket reuse
  constructor(_session, _index, _parties, _endpoints, _sockets, _share, _pubKey, _websocketOnly, _tssLib) {
    _defineProperty(this, "session", void 0);
    _defineProperty(this, "index", void 0);
    _defineProperty(this, "parties", void 0);
    _defineProperty(this, "msgQueue", []);
    _defineProperty(this, "sockets", void 0);
    _defineProperty(this, "endpoints", void 0);
    _defineProperty(this, "share", void 0);
    _defineProperty(this, "pubKey", void 0);
    _defineProperty(this, "websocketOnly", void 0);
    _defineProperty(this, "tssLib", void 0);
    _defineProperty(this, "_startPrecomputeTime", void 0);
    _defineProperty(this, "_endPrecomputeTime", void 0);
    _defineProperty(this, "_startSignTime", void 0);
    _defineProperty(this, "_endSignTime", void 0);
    _defineProperty(this, "log", void 0);
    _defineProperty(this, "_consumed", void 0);
    _defineProperty(this, "_sLessThanHalf", void 0);
    _defineProperty(this, "_precomputeComplete", []);
    _defineProperty(this, "_precomputeFailed", []);
    _defineProperty(this, "precomputed_value", null);
    _defineProperty(this, "_ready", false);
    _defineProperty(this, "_signer", void 0);
    _defineProperty(this, "_rng", void 0);
    _defineProperty(this, "_readyResolve", null);
    if (_parties.length !== _sockets.length) {
      throw new Error("parties and sockets length must be equal, add null for client if necessary");
    }
    if (_parties.length !== _endpoints.length) {
      throw new Error("parties and endpoints length must be equal, add null for client if necessary");
    }
    this.session = _session;
    this.index = _index;
    this.parties = _parties;
    this.endpoints = _endpoints;
    this.sockets = _sockets;
    this.share = _share;
    this.pubKey = _pubKey;
    this.websocketOnly = _websocketOnly;
    this.log = console.log;
    this._consumed = false;
    this._sLessThanHalf = true;
    this.tssLib = _tssLib;
    _sockets.forEach((socket) => {
      if (socket) {
        if (socket.hasListeners("send")) {
          socket.off("send");
        }
        socket.on("send", async (data, cb) => {
          const {
            session,
            sender,
            recipient,
            msg_type,
            msg_data
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this.msgQueue.push({
            session,
            sender,
            recipient,
            msg_type,
            msg_data
          });
          if (cb) cb();
        });
        socket.on("precompute_complete", async (data, cb) => {
          const {
            session,
            party
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this._precomputeComplete.push(party);
          if (cb) cb();
        });
        socket.on("precompute_failed", async (data, cb) => {
          const {
            session,
            party
          } = data;
          if (session !== this.session) {
            this.log(`ignoring message for a different session... client session: ${this.session}, message session: ${session}`);
            return;
          }
          this._precomputeFailed.push(party);
          if (cb) cb();
        });
      }
    });
    globalThis.tss_clients.set(this.session, this);
  }
  get sid() {
    return this.session.split(DELIMITERS2.Delimiter4)[1];
  }
  async ready() {
    if (this._readyResolve != null) {
      await this._readyResolve;
    } else {
      throw new Error("Precompute needs to be called before ready");
    }
    await new Promise((resolve, reject) => {
      let counter = 0;
      const timer = setInterval(() => {
        if (this._precomputeFailed.length === 0 && this._precomputeComplete.filter((x, i, a) => a.indexOf(x) === i).length === this.parties.length && this.precomputed_value != null) {
          clearInterval(timer);
          this._ready = true;
          resolve();
        } else if (this._precomputeFailed.length > 0) {
          reject(new Error("Peer failure detected, please try again"));
        }
        if (counter >= 500) {
          clearInterval(timer);
          reject(new Error("Client is not ready"));
        }
        counter++;
      }, 10);
    });
  }
  precompute(additionalParams) {
    this.sockets.forEach((socket, party) => {
      if (socket !== null) {
        if (socket.id === void 0) {
          throw new Error(`socket not connected yet, session: ${this.session}, party: ${party}`);
        }
      }
    });
    const precomputePromises = [];
    for (let i = 0; i < this.parties.length; i++) {
      const party = this.parties[i];
      if (party !== this.index) {
        precomputePromises.push(new Promise((resolve, reject) => {
          fetch(`${this.lookupEndpoint(this.session, party)}/precompute`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              [WEB3_SESSION_HEADER_KEY]: this.sid
            },
            body: JSON.stringify(_objectSpread2({
              endpoints: this.endpoints.map((endpoint, j) => {
                if (j !== this.index) {
                  return endpoint;
                }
                return `websocket:${this.sockets[party].id}`;
              }),
              session: this.session,
              parties: this.parties,
              player_index: party,
              threshold: this.parties.length,
              pubkey: this.pubKey,
              notifyWebsocketId: this.sockets[party].id,
              sendWebsocket: this.sockets[party].id
            }, additionalParams))
          }).then(async (resp) => {
            const json = await resp.json();
            if (resp.status !== 200) {
              throw new Error(`precompute route failed on ${this.lookupEndpoint(this.session, party)} with status ${resp.status} 
 ${JSON.stringify(json)} `);
            }
            return resolve(resp);
          }).catch((err) => {
            reject(err);
          });
        }));
      }
    }
    const setupPrecompute = async () => {
      this._startPrecomputeTime = Date.now();
      await Promise.all(precomputePromises);
      this._signer = await this.tssLib.threshold_signer(this.session, this.index, this.parties.length, this.parties.length, this.share, this.pubKey);
      this._rng = await this.tssLib.random_generator(Buffer.from(generatePrivate()).toString("base64"));
      await this.tssLib.setup(this._signer, this._rng);
      const precomputeResult = await this.tssLib.precompute(new Uint8Array(this.parties), this._signer, this._rng);
      this.precomputed_value = precomputeResult;
      this._precomputeComplete.push(this.index);
      this._consumed = false;
      this._endPrecomputeTime = Date.now();
    };
    this._readyResolve = setupPrecompute().catch((e) => {
      this._precomputeFailed.push(this.index);
      console.error(e);
    });
  }
  async sign(msg, hash_only, original_message, hash_algo, additionalParams) {
    if (this._consumed === true) {
      throw new Error("This instance has already signed a message and cannot be reused");
    }
    if (this._ready === false) {
      throw new Error("client is not ready");
    }
    if (!hash_only) {
      if (hash_algo === "keccak256") {
        if (Buffer.from(keccak256(Buffer.from(original_message))).toString("base64") !== msg) {
          throw new Error("hash of original message does not match msg");
        }
      } else {
        throw new Error(`hash algo ${hash_algo} not supported`);
      }
    }
    this._startSignTime = Date.now();
    const sigFragments = [];
    const fragmentPromises = [];
    for (let i = 0; i < this.parties.length; i++) {
      const party = i;
      if (party === this.index) {
        sigFragments.push(await this.tssLib.local_sign(msg, hash_only, this.precomputed_value));
      } else {
        fragmentPromises.push(new Promise((resolve, reject) => {
          const endpoint = this.lookupEndpoint(this.session, party);
          fetch(`${endpoint}/sign`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              [WEB3_SESSION_HEADER_KEY]: this.sid
            },
            body: JSON.stringify(_objectSpread2({
              session: this.session,
              sender: this.index,
              recipient: party,
              msg,
              hash_only,
              original_message,
              hash_algo
            }, additionalParams))
          }).then((res) => res.json()).then((res) => resolve(res.sig)).catch((err) => {
            reject(err);
          });
        }));
      }
    }
    const peerFragments = await Promise.all(fragmentPromises);
    peerFragments.forEach((fragment) => {
      sigFragments.push(fragment);
    });
    const R = await this.tssLib.get_r_from_precompute(this.precomputed_value);
    const sig = await this.tssLib.local_verify(msg, hash_only, R, sigFragments, this.pubKey);
    this._endSignTime = Date.now();
    const sigHex = Buffer.from(sig, "base64").toString("hex");
    const r = new import_bn6.default(sigHex.slice(0, 64), 16);
    let s = new import_bn6.default(sigHex.slice(64), 16);
    let recoveryParam = Buffer.from(R, "base64")[63] % 2;
    if (this._sLessThanHalf) {
      const ec4 = getEc();
      const halfOfSecp256k1n = ec4.n.div(new import_bn6.default(2));
      if (s.gt(halfOfSecp256k1n)) {
        s = ec4.n.sub(s);
        recoveryParam = (recoveryParam + 1) % 2;
      }
    }
    this._consumed = true;
    this._ready = false;
    this._readyResolve = null;
    return {
      r,
      s,
      recoveryParam
    };
  }
  lookupEndpoint(session, party) {
    if (session !== this.session) throw new Error("incorrect session when looking up endpoint");
    return this.endpoints[party];
  }
  async cleanup(additionalParams) {
    this.tssLib.random_generator_free(this._rng);
    this.tssLib.threshold_signer_free(this._signer);
    this._precomputeComplete = [];
    this._precomputeFailed = [];
    this.precomputed_value = null;
    this._endPrecomputeTime = null;
    this._startPrecomputeTime = null;
    this._endSignTime = null;
    this._startSignTime = null;
    this._consumed = false;
    this._ready = false;
    this._readyResolve = null;
    globalThis.tss_clients.delete(this.session);
    this.sockets.forEach((soc) => {
      if (soc && soc.connected) {
        soc.close();
      }
    });
    await Promise.all(this.parties.map(async (party) => {
      if (party !== this.index) {
        await fetch(`${this.lookupEndpoint(this.session, party)}/cleanup`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            [WEB3_SESSION_HEADER_KEY]: this.sid
          },
          body: JSON.stringify(_objectSpread2({
            session: this.session
          }, additionalParams))
        });
      }
      return Promise.resolve(true);
    }));
  }
};
var WebDb = class {
  constructor() {
    _defineProperty(this, "get", (key) => {
      return new Promise((resolve) => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          const value = globalThis.localStorage.getItem(key);
          resolve(value);
        } else {
          chrome.storage.local.get(key, (result) => {
            resolve(result[key]);
            return result;
          });
        }
      });
    });
    _defineProperty(this, "set", (key, value) => {
      return new Promise((resolve) => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          globalThis.localStorage.setItem(key, value);
          resolve();
        } else {
          chrome.storage.local.set({
            [key]: value
          }, () => {
            resolve();
          });
        }
      });
    });
    _defineProperty(this, "delete", (key) => {
      return new Promise((resolve) => {
        if (globalThis !== null && globalThis !== void 0 && globalThis.localStorage) {
          globalThis.localStorage.removeItem(key);
          resolve();
        } else {
          chrome.storage.local.remove(key);
          resolve();
        }
      });
    });
  }
};
var localStorageDB = new WebDb();

// node_modules/@toruslabs/tss-frost-common/dist/tssFrostCommon.esm.js
function base64ToBytes(base64) {
  const binString = atob(base64);
  return Uint8Array.from(binString, (m) => m.codePointAt(0));
}
function bytesToBase64(bytes) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}
var MemoryManager = class {
  constructor() {
    _defineProperty(this, "items", void 0);
    this.items = [];
  }
  // Add object to collection.
  add(obj) {
    this.items.push(obj);
    return obj;
  }
  // Free all collected objects.
  free() {
    this.items.forEach((e) => {
      try {
        e.free();
      } catch (err) {
        console.log(`Warning: freeing value: ${err}`);
      }
    });
    this.items = [];
  }
};

// node_modules/@toruslabs/tss-frost-client/dist/tssFrostClient.esm.js
var import_tss_client_util = __toESM(require_tssClientUtil_cjs());
var READ_TIMEOUT = 1e4;
var CONNECT_TIMEOUT = 1e4;
function messageKey(sender, receiver, type) {
  return JSON.stringify([sender, receiver, type]);
}
var MessageBroker = class {
  constructor(session, sender) {
    _defineProperty(this, "session_id", void 0);
    _defineProperty(this, "sender_id", void 0);
    _defineProperty(this, "messages", new import_tss_client_util.MapQueue());
    _defineProperty(this, "sockets", /* @__PURE__ */ new Map());
    this.session_id = session;
    this.sender_id = sender;
  }
  getSocket(server_id) {
    return this.sockets.get(server_id);
  }
  // Connects to the remote endpoints and populates the sockets map.
  //
  // If already connected, clears existing connections first.
  async connect(ids, endpoints) {
    if (ids.length !== endpoints.length) {
      throw new Error("ids must have same length as endpoints");
    }
    this.close();
    const sockets = endpoints.map((wsEndpoint) => {
      const url = new URL("socket.io", wsEndpoint);
      return lookup(url.origin, {
        path: url.pathname,
        transports: ["websocket", "polling"],
        withCredentials: true,
        reconnectionDelayMax: 1e4,
        reconnectionAttempts: 3
      });
    });
    const proms = sockets.map((socket) => {
      return new Promise((resolve, reject) => {
        socket.on("connect", resolve);
        setTimeout(() => {
          reject(new Error("Connection timeout"));
        }, CONNECT_TIMEOUT);
      });
    });
    await Promise.all(proms);
    sockets.forEach((socket, i) => {
      const serverId = ids[i];
      socket.on("send", async (msg, cb) => {
        if (msg.sender !== serverId) {
          console.log(`ignoring message: wrong sender: expected ${serverId}, got ${msg.sender}`);
          return;
        }
        if (msg.session !== this.session_id) {
          console.log(`ignoring message: wrong session: expected ${this.session_id}, got ${msg.session}`);
          return;
        }
        const m = {
          sender: msg.sender,
          data: base64ToBytes(msg.msg_data),
          receiver: msg.recipient,
          type: msg.msg_type
        };
        const k = messageKey(m.sender, m.receiver, m.type);
        this.messages.push(k, m);
        if (cb) cb();
      });
      this.sockets.set(serverId, socket);
    });
  }
  // Closes connections and cleans up memory.
  close() {
    this.sockets.forEach((socket) => socket.disconnect());
    this.sockets.clear();
  }
  async send(to, mtype, mdata) {
    const socket = this.sockets.get(to);
    if (!socket) {
      throw new Error("Socket not found");
    }
    const msg = {
      msg_data: bytesToBase64(mdata),
      msg_type: mtype,
      recipient: to,
      sender: this.sender_id,
      session: this.session_id
    };
    socket.emit("send_msg", msg);
  }
  async receive(from, mtype) {
    const k = messageKey(from, this.sender_id, mtype);
    const msg = await this.messages.pop(k, READ_TIMEOUT);
    if (!msg) {
      throw new Error("Timeout");
    }
    return msg.data;
  }
};
async function requestSign(server, session, server_id, pubkey, server_ids, server_endpoints, client_id, socket_id, msg, signatures, share_coefficient) {
  const parties = server_ids.slice();
  const endpoints = server_endpoints.slice().map((ep) => ep.endsWith("/") ? ep.slice(0, -1) : ep);
  parties.push(client_id);
  endpoints.push(`websocket:${socket_id.id}`);
  const body = {
    session,
    msg: bytesToBase64(msg),
    player_index: server_id,
    pubkey,
    parties,
    endpoints,
    signatures,
    share_coefficient
  };
  const url = new URL("sign", server);
  const resp = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });
  if (!resp.ok) {
    const errMsg = (await resp.json()).message;
    throw new Error(errMsg);
  }
}
function generateRngSeed() {
  const buf = new Uint8Array(32);
  crypto.getRandomValues(buf);
  return buf;
}
async function sign(wasmLib, session, signatures, server_ids, server_endpoints, client_index, keyshare, pubkey, msg, server_coefficients = void 0) {
  const mb = new MessageBroker(session, client_index);
  await mb.connect(server_ids, server_endpoints);
  server_ids.forEach((p, i) => {
    const socket = mb.getSocket(p);
    if (socket === void 0) {
      throw new Error(`socket not found: party ${p}`);
    }
    requestSign(new URL(server_endpoints[i]), session, p, pubkey, server_ids, server_endpoints, client_index, socket, msg, signatures, server_coefficients ? server_coefficients[i] : void 0).catch((error) => {
      console.error(`Server ${i}: ${error}`);
    });
  });
  const seed = generateRngSeed();
  const mem = new MemoryManager();
  try {
    const seedWasm = mem.add(new wasmLib.RngSeed(seed));
    const keyWasm = mem.add(wasmLib.KeyShare.from_raw(client_index, keyshare, pubkey));
    const sig = mem.add(await wasmLib.sign(seedWasm, mb, new Uint32Array(server_ids), keyWasm, msg));
    return sig.to_hex();
  } finally {
    mem.free();
    mb.close();
  }
}

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/mpcCoreKit.js
var import_bn8 = __toESM(require_bn());
var import_elliptic5 = __toESM(require_elliptic());

// node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_base64url2 = __toESM(require_base64url());

// node_modules/@toruslabs/constants/dist/constants.esm.js
var TORUS_LEGACY_NETWORK2 = {
  MAINNET: "mainnet",
  TESTNET: "testnet",
  CYAN: "cyan",
  AQUA: "aqua",
  CELESTE: "celeste"
};
var TORUS_SAPPHIRE_NETWORK2 = {
  SAPPHIRE_DEVNET: "sapphire_devnet",
  SAPPHIRE_MAINNET: "sapphire_mainnet"
};
var PROXY_CONTRACT_ADDRESS2 = {
  [TORUS_LEGACY_NETWORK2.MAINNET]: "0xf20336e16B5182637f09821c27BDe29b0AFcfe80",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "0xd084604e5FA387FbC2Da8bAab07fDD6aDED4614A",
  [TORUS_LEGACY_NETWORK2.CYAN]: "0x9f072ba19b3370e512aa1b4bfcdaf97283168005",
  [TORUS_LEGACY_NETWORK2.AQUA]: "0x29Dea82a0509153b91040ee13cDBba0f03efb625",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "0x6Bffb4e89453069E7487f0fa5c9f4a2D771cce6c"
};
var LEGACY_NETWORKS_ROUTE_MAP2 = {
  [TORUS_LEGACY_NETWORK2.AQUA]: {
    migrationCompleted: true,
    networkIdentifier: "aqua",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.CELESTE]: {
    migrationCompleted: true,
    networkIdentifier: "celeste",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.CYAN]: {
    migrationCompleted: true,
    networkIdentifier: "cyan",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.MAINNET]: {
    migrationCompleted: true,
    networkIdentifier: "mainnet",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET
  },
  [TORUS_LEGACY_NETWORK2.TESTNET]: {
    migrationCompleted: true,
    networkIdentifier: "teal",
    networkMigratedTo: TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_DEVNET
  }
};
var NETWORK_MAP2 = {
  [TORUS_LEGACY_NETWORK2.MAINNET]: "mainnet",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "goerli",
  [TORUS_LEGACY_NETWORK2.CYAN]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK2.AQUA]: "polygon-mainnet",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "polygon-mainnet"
};
var SIGNER_MAP2 = {
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_MAINNET]: "https://signer.web3auth.io",
  [TORUS_SAPPHIRE_NETWORK2.SAPPHIRE_DEVNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK2.MAINNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "https://signer.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CYAN]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK2.AQUA]: "https://signer-polygon.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "https://signer-polygon.web3auth.io"
};
var METADATA_MAP2 = {
  [TORUS_LEGACY_NETWORK2.MAINNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.TESTNET]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CYAN]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.AQUA]: "https://metadata.web3auth.io",
  [TORUS_LEGACY_NETWORK2.CELESTE]: "https://metadata.web3auth.io"
};

// node_modules/@toruslabs/openlogin-utils/dist/openloginUtils.esm.js
var import_color = __toESM(require_color());
var base64url2 = import_base64url2.default;
function safeatob(str) {
  return base64url2.decode(str);
}
function storageAvailable(type) {
  let storageExists = false;
  let storageLength = 0;
  let storage;
  try {
    storage = window[type];
    storageExists = true;
    storageLength = storage.length;
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (err) {
    const error = err;
    return error && // everything except Firefox
    (error.code === 22 || // Firefox
    error.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    error.name === "QuotaExceededError" || // Firefox
    error.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storageExists && storageLength !== 0;
  }
}
var MemoryStore = class {
  constructor() {
    _defineProperty(this, "store", /* @__PURE__ */ new Map());
  }
  getItem(key) {
    return this.store.get(key) || null;
  }
  setItem(key, value) {
    this.store.set(key, value);
  }
  removeItem(key) {
    this.store.delete(key);
  }
};
var BrowserStorage = class {
  constructor(storeKey, storage) {
    _defineProperty(this, "storage", void 0);
    _defineProperty(this, "_storeKey", void 0);
    this.storage = storage;
    this._storeKey = storeKey;
    try {
      if (!storage.getItem(storeKey)) {
        this.resetStore();
      }
    } catch (error) {
    }
  }
  static getInstance(key) {
    let storageKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
    if (!this.instanceMap.has(key)) {
      let storage;
      if (storageKey === "local" && storageAvailable("localStorage")) {
        storage = window.localStorage;
      } else if (storageKey === "session" && storageAvailable("sessionStorage")) {
        storage = window.sessionStorage;
      } else {
        storage = new MemoryStore();
      }
      this.instanceMap.set(key, new this(key, storage));
    }
    return this.instanceMap.get(key);
  }
  toJSON() {
    return this.storage.getItem(this._storeKey);
  }
  resetStore() {
    const currStore = this.getStore();
    this.storage.removeItem(this._storeKey);
    return currStore;
  }
  getStore() {
    return JSON.parse(this.storage.getItem(this._storeKey) || "{}");
  }
  get(key) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    return store[key];
  }
  set(key, value) {
    const store = JSON.parse(this.storage.getItem(this._storeKey) || "{}");
    store[key] = value;
    this.storage.setItem(this._storeKey, JSON.stringify(store));
  }
};
_defineProperty(BrowserStorage, "instanceMap", /* @__PURE__ */ new Map());
var OPENLOGIN_NETWORK = _objectSpread2(_objectSpread2({}, TORUS_SAPPHIRE_NETWORK2), TORUS_LEGACY_NETWORK2);

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/utils.js
var import_bn7 = __toESM(require_bn());
var import_elliptic4 = __toESM(require_elliptic());
var import_loglevel = __toESM(require_loglevel());
var ed25519 = () => {
  return new import_elliptic4.eddsa("ed25519");
};
function randomBytes2(bytesLength = 32) {
  const crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
function generateEd25519Seed() {
  return Buffer.from(randomBytes2(32));
}
var generateFactorKey = () => {
  const keyPair = factorKeyCurve.genKeyPair();
  const pub = Point$1.fromElliptic(keyPair.getPublic());
  return {
    private: keyPair.getPrivate(),
    pub
  };
};
var generateTSSEndpoints = (tssNodeEndpoints, parties, clientIndex, nodeIndexes) => {
  const endpoints = [];
  const tssWSEndpoints = [];
  const partyIndexes = [];
  const nodeIndexesReturned = [];
  for (let i = 0; i < parties; i++) {
    partyIndexes.push(i);
    if (i === clientIndex) {
      endpoints.push(null);
      tssWSEndpoints.push(null);
    } else {
      const targetNodeIndex = nodeIndexes[i] - 1;
      endpoints.push(tssNodeEndpoints[targetNodeIndex]);
      tssWSEndpoints.push(new URL(tssNodeEndpoints[targetNodeIndex]).origin);
      nodeIndexesReturned.push(nodeIndexes[i]);
    }
  }
  return {
    endpoints,
    tssWSEndpoints,
    partyIndexes,
    nodeIndexesReturned
  };
};
async function storageAvailable2(storage) {
  try {
    const x = "__storage_test__";
    const rand = Math.random().toString();
    await storage.setItem(x, rand);
    const value = await storage.getItem(rand);
    if (value !== rand) {
      throw new Error("Value mismatch");
    }
    return true;
  } catch (error) {
    return false;
  }
}
function parseToken(token) {
  const payload = token.split(".")[1];
  return JSON.parse(safeatob(payload));
}
var getHashedPrivateKey = (postboxKey, clientId) => {
  const uid = `${postboxKey}_${clientId}`;
  let hashUid = keccak2563(Buffer.from(uid, "utf8"));
  hashUid = hashUid.replace("0x", "");
  return new import_bn7.default(hashUid, "hex");
};
function scalarBNToBufferSEC1(s) {
  return s.toArrayLike(Buffer, "be", SCALAR_LEN);
}
function sampleEndpoints(endpoints, n) {
  if (n > endpoints.length) {
    throw new Error("Invalid number of endpoints");
  }
  const shuffledEndpoints = endpoints.slice().sort(() => Math.random() - 0.5);
  return shuffledEndpoints.slice(0, n).sort((a, b) => a.index - b.index);
}
function fraction(curve, nom, denom) {
  return nom.mul(denom.invm(curve.n)).umod(curve.n);
}
function lagrangeCoefficient(curve, xCoords, targetCoeff, targetX) {
  return xCoords.filter((_, i) => i !== targetCoeff).reduce((prev, cur) => {
    const frac = fraction(curve, targetX.sub(cur), xCoords[targetCoeff].sub(cur));
    return prev.mul(frac).umod(curve.n);
  }, new import_bn7.default(1));
}
function lagrangeCoefficients(curve, xCoords, targetX) {
  const xCoordsBN = xCoords.map((i) => new import_bn7.default(i));
  const targetXBN = new import_bn7.default(targetX);
  return xCoordsBN.map((_value, i) => lagrangeCoefficient(curve, xCoordsBN, i, targetXBN));
}
var SERVER_XCOORD_L1 = 1;
var CLIENT_XCOORD_L1 = 2;
function deriveShareCoefficients(ec4, serverXCoords, targetClientXCoord, sourceClientXCoord = CLIENT_XCOORD_L1) {
  const l1Coefficients = lagrangeCoefficients(ec4, [SERVER_XCOORD_L1, sourceClientXCoord], 0);
  const l2Coefficients = lagrangeCoefficients(ec4, serverXCoords, 0);
  if (serverXCoords.includes(targetClientXCoord)) {
    throw new Error(`Invalid server x-coordinates: overlapping with client x-coordinate: ${serverXCoords} ${targetClientXCoord}`);
  }
  const targetCoefficients = lagrangeCoefficients(ec4, [targetClientXCoord, ...serverXCoords], 0);
  const serverCoefficients = l2Coefficients.map((coeff, i) => fraction(ec4, l1Coefficients[0].mul(coeff), targetCoefficients[i + 1]));
  const clientCoefficient = fraction(ec4, l1Coefficients[1], targetCoefficients[0]);
  return {
    serverCoefficients,
    clientCoefficient
  };
}
function generateSessionNonce() {
  return keccak2563(Buffer.from(generatePrivateBN().toString("hex") + Date.now(), "utf8"));
}
function getSessionId(verifier, verifierId, tssTag, tssNonce, sessionNonce) {
  return `${verifier}${DELIMITERS.Delimiter1}${verifierId}${DELIMITERS.Delimiter2}${tssTag}${DELIMITERS.Delimiter3}${tssNonce}${DELIMITERS.Delimiter4}${sessionNonce}`;
}
function sigToRSV(sig) {
  if (sig.length !== 65) {
    throw new Error(`Invalid signature length: expected 65, got ${sig.length}`);
  }
  return {
    r: Buffer.from(sig.subarray(0, 32)),
    s: Buffer.from(sig.subarray(32, 64)),
    v: sig[64]
  };
}
function makeEthereumSigner(kit) {
  if (kit.keyType !== KeyType.secp256k1) {
    throw new Error(`Invalid key type: expected secp256k1, got ${kit.keyType}`);
  }
  return {
    sign: async (msgHash) => {
      const sig = await kit.sign(msgHash, true);
      return sigToRSV(sig);
    },
    getPublic: async () => {
      const pk = Point$1.fromSEC1(secp256k1, kit.getPubKey().toString("hex"));
      return pk.toSEC1(secp256k1).subarray(1);
    }
  };
}
var log = import_loglevel.default.getLogger("mpc-core-kit");
log.disableAll();

// node_modules/@web3auth/mpc-core-kit/dist/lib.esm/mpcCoreKit.js
var Web3AuthMPCCoreKit = class {
  constructor(options) {
    var _window;
    _defineProperty(this, "state", {
      accountIndex: 0
    });
    _defineProperty(this, "torusSp", null);
    _defineProperty(this, "options", void 0);
    _defineProperty(this, "storageLayer", null);
    _defineProperty(this, "tkey", null);
    _defineProperty(this, "sessionManager", void 0);
    _defineProperty(this, "currentStorage", void 0);
    _defineProperty(this, "_storageBaseKey", "corekit_store");
    _defineProperty(this, "enableLogging", false);
    _defineProperty(this, "ready", false);
    _defineProperty(this, "_tssLib", void 0);
    _defineProperty(this, "wasmLib", void 0);
    _defineProperty(this, "_keyType", void 0);
    _defineProperty(this, "atomicCallStackCounter", 0);
    _defineProperty(this, "preSigningHook", void 0);
    _defineProperty(this, "getTssFactorPub", () => {
      this.checkReady();
      if (!this.state.factorKey) {
        throw CoreKitError.factorKeyNotPresent("factorKey not present in state when getting tss factor public key.");
      }
      const factorPubsList = this.tKey.metadata.factorPubs[this.tKey.tssTag];
      return factorPubsList.map((factorPub) => factorPub.toSEC1(factorKeyCurve, true).toString("hex"));
    });
    if (!options.web3AuthClientId) {
      throw CoreKitError.clientIdInvalid();
    }
    this._tssLib = options.tssLib;
    this._keyType = options.tssLib.keyType;
    const isNodejsOrRN = this.isNodejsOrRN(options.uxMode);
    if (options.enableLogging) {
      log.enableAll();
      this.enableLogging = true;
    } else log.setLevel("error");
    if (typeof options.manualSync !== "boolean") options.manualSync = false;
    if (!options.web3AuthNetwork) options.web3AuthNetwork = WEB3AUTH_NETWORK.MAINNET;
    if (!options.sessionTime) options.sessionTime = 86400;
    if (!options.serverTimeOffset) options.serverTimeOffset = 0;
    if (!options.uxMode) options.uxMode = UX_MODE.REDIRECT;
    if (!options.redirectPathName) options.redirectPathName = "redirect";
    if (!options.baseUrl) options.baseUrl = isNodejsOrRN ? "https://localhost" : `${(_window = window) === null || _window === void 0 ? void 0 : _window.location.origin}/serviceworker`;
    if (!options.disableHashedFactorKey) options.disableHashedFactorKey = false;
    if (!options.hashedFactorNonce) options.hashedFactorNonce = options.web3AuthClientId;
    if (options.disableSessionManager === void 0) options.disableSessionManager = false;
    this.options = options;
    this.currentStorage = new AsyncStorage(this._storageBaseKey, options.storage);
    if (!options.disableSessionManager) {
      this.sessionManager = new SessionManager({
        sessionTime: options.sessionTime
      });
    }
    Torus.setSessionTime(this.options.sessionTime);
  }
  get tKey() {
    if (this.tkey === null) {
      throw CoreKitError.tkeyInstanceUninitialized();
    }
    return this.tkey;
  }
  get keyType() {
    return this._keyType;
  }
  get signatures() {
    var _this$state;
    return (_this$state = this.state) !== null && _this$state !== void 0 && _this$state.signatures ? this.state.signatures : [];
  }
  get _storageKey() {
    return this._storageBaseKey;
  }
  get status() {
    try {
      const {
        tkey
      } = this;
      if (!tkey) return COREKIT_STATUS.NOT_INITIALIZED;
      if (!tkey.metadata) return COREKIT_STATUS.INITIALIZED;
      if (!tkey.secp256k1Key || !this.state.factorKey) return COREKIT_STATUS.REQUIRED_SHARE;
      return COREKIT_STATUS.LOGGED_IN;
    } catch (e) {
    }
    return COREKIT_STATUS.NOT_INITIALIZED;
  }
  get sessionId() {
    var _this$sessionManager;
    return (_this$sessionManager = this.sessionManager) === null || _this$sessionManager === void 0 ? void 0 : _this$sessionManager.sessionId;
  }
  get supportsAccountIndex() {
    return this._keyType !== KeyType.ed25519;
  }
  get verifier() {
    var _this$state$userInfo, _this$state2;
    if ((_this$state$userInfo = this.state.userInfo) !== null && _this$state$userInfo !== void 0 && _this$state$userInfo.aggregateVerifier) {
      return this.state.userInfo.aggregateVerifier;
    }
    return (_this$state2 = this.state) !== null && _this$state2 !== void 0 && (_this$state2 = _this$state2.userInfo) !== null && _this$state2 !== void 0 && _this$state2.verifier ? this.state.userInfo.verifier : "";
  }
  get verifierId() {
    var _this$state3;
    return (_this$state3 = this.state) !== null && _this$state3 !== void 0 && (_this$state3 = _this$state3.userInfo) !== null && _this$state3 !== void 0 && _this$state3.verifierId ? this.state.userInfo.verifierId : "";
  }
  get isRedirectMode() {
    return this.options.uxMode === UX_MODE.REDIRECT;
  }
  get useClientGeneratedTSSKey() {
    return this.keyType === KeyType.ed25519 && this.options.useClientGeneratedTSSKey === void 0 ? true : !!this.options.useClientGeneratedTSSKey;
  }
  // RecoverTssKey only valid for user that enable MFA where user has 2 type shares :
  // TssShareType.DEVICE and TssShareType.RECOVERY
  // if the factors key provided is the same type recovery will not works
  async _UNSAFE_recoverTssKey(factorKey) {
    this.checkReady();
    const factorKeyBN = new import_bn8.default(factorKey[0], "hex");
    const shareStore0 = await this.getFactorKeyMetadata(factorKeyBN);
    await this.tKey.initialize({
      withShare: shareStore0
    });
    const tssShares = [];
    const tssIndexes = [];
    const tssIndexesBN = [];
    for (let i = 0; i < factorKey.length; i++) {
      const factorKeyBNInput = new import_bn8.default(factorKey[i], "hex");
      const {
        tssIndex,
        tssShare
      } = await this.tKey.getTSSShare(factorKeyBNInput);
      if (tssIndexes.includes(tssIndex)) {
        await this.init();
        throw CoreKitError.duplicateTssIndex();
      }
      tssIndexes.push(tssIndex);
      tssIndexesBN.push(new import_bn8.default(tssIndex));
      tssShares.push(tssShare);
    }
    const finalKey = lagrangeInterpolation(this.tkey.tssCurve, tssShares, tssIndexesBN);
    await this.init();
    return finalKey.toString("hex", 64);
  }
  async init(params = {
    handleRedirectResult: true
  }) {
    var _window2, _window3;
    this.resetState();
    if (params.rehydrate === void 0) params.rehydrate = true;
    const nodeDetails = fetchLocalConfig(this.options.web3AuthNetwork, this.keyType);
    if (this.keyType === KEY_TYPE.ED25519 && this.options.useDKG) {
      throw CoreKitError.invalidConfig("DKG is not supported for ed25519 key type");
    }
    this.torusSp = new TSSTorusServiceProvider({
      customAuthArgs: {
        web3AuthClientId: this.options.web3AuthClientId,
        baseUrl: this.options.baseUrl,
        uxMode: this.isNodejsOrRN(this.options.uxMode) ? UX_MODE.REDIRECT : this.options.uxMode,
        network: this.options.web3AuthNetwork,
        redirectPathName: this.options.redirectPathName,
        locationReplaceOnRedirect: true,
        serverTimeOffset: this.options.serverTimeOffset,
        keyType: this.keyType,
        useDkg: this.options.useDKG
      }
    });
    this.storageLayer = new TorusStorageLayer$1({
      hostUrl: `${new URL(nodeDetails.torusNodeEndpoints[0]).origin}/metadata`,
      enableLogging: this.enableLogging
    });
    const shareSerializationModule = new ShareSerializationModule$1();
    this.tkey = new TKeyTSS({
      enableLogging: this.enableLogging,
      serviceProvider: this.torusSp,
      storageLayer: this.storageLayer,
      manualSync: this.options.manualSync,
      modules: {
        shareSerialization: shareSerializationModule
      },
      tssKeyType: this.keyType
    });
    if (this.isRedirectMode) {
      await this.torusSp.init({
        skipSw: true,
        skipPrefetch: true
      });
    } else if (this.options.uxMode === UX_MODE.POPUP) {
      await this.torusSp.init({});
    }
    this.ready = true;
    if (params.handleRedirectResult && this.options.uxMode === UX_MODE.REDIRECT && ((_window2 = window) !== null && _window2 !== void 0 && _window2.location.hash.includes("#state") || (_window3 = window) !== null && _window3 !== void 0 && _window3.location.hash.includes("#access_token"))) {
      await this.handleRedirectResult();
      return;
    } else if (params.rehydrate && this.sessionManager) {
      const sessionId = await this.currentStorage.get("sessionId");
      if (sessionId) {
        this.sessionManager.sessionId = sessionId;
        const sessionResult = await this.sessionManager.authorizeSession().catch(async (err) => {
          log.error("rehydrate session error", err);
        });
        if (sessionResult) {
          await this.rehydrateSession(sessionResult);
          return;
        }
      }
    }
    await this.featureRequest();
  }
  async loginWithOAuth(params) {
    this.checkReady();
    if (this.isNodejsOrRN(this.options.uxMode)) {
      throw CoreKitError.oauthLoginUnsupported(`Oauth login is NOT supported in ${this.options.uxMode} mode.`);
    }
    const {
      importTssKey,
      registerExistingSFAKey
    } = params;
    const tkeyServiceProvider = this.torusSp;
    if (registerExistingSFAKey && importTssKey) {
      throw CoreKitError.invalidConfig("Cannot import TSS key and register SFA key at the same time.");
    }
    if (this.isRedirectMode && (importTssKey || registerExistingSFAKey)) {
      throw CoreKitError.invalidConfig("key import is not supported in redirect mode");
    }
    try {
      const verifierParams = params;
      const aggregateParams = params;
      let loginResponse;
      if (verifierParams.subVerifierDetails) {
        var _loginResponse$nodesD;
        loginResponse = await tkeyServiceProvider.triggerLogin(params.subVerifierDetails);
        if (this.isRedirectMode) return;
        this.updateState({
          postBoxKey: this._getPostBoxKey(loginResponse),
          postboxKeyNodeIndexes: (_loginResponse$nodesD = loginResponse.nodesData) === null || _loginResponse$nodesD === void 0 ? void 0 : _loginResponse$nodesD.nodeIndexes,
          userInfo: loginResponse.userInfo,
          signatures: this._getSignatures(loginResponse.sessionData.sessionTokenData)
        });
      } else if (aggregateParams.subVerifierDetailsArray) {
        var _loginResponse$nodesD2;
        loginResponse = await tkeyServiceProvider.triggerAggregateLogin({
          aggregateVerifierType: aggregateParams.aggregateVerifierType || AGGREGATE_VERIFIER.SINGLE_VERIFIER_ID,
          verifierIdentifier: aggregateParams.aggregateVerifierIdentifier,
          subVerifierDetailsArray: aggregateParams.subVerifierDetailsArray
        });
        if (this.isRedirectMode) return;
        this.updateState({
          postBoxKey: this._getPostBoxKey(loginResponse),
          postboxKeyNodeIndexes: (_loginResponse$nodesD2 = loginResponse.nodesData) === null || _loginResponse$nodesD2 === void 0 ? void 0 : _loginResponse$nodesD2.nodeIndexes,
          userInfo: loginResponse.userInfo[0],
          signatures: this._getSignatures(loginResponse.sessionData.sessionTokenData)
        });
      }
      if (loginResponse && registerExistingSFAKey && loginResponse.finalKeyData.privKey) {
        if (loginResponse.metadata.typeOfUser === "v1") {
          throw CoreKitError.invalidConfig("Cannot register existing SFA key for v1 users, please contact web3auth support.");
        }
        const existingSFAKey = loginResponse.finalKeyData.privKey.padStart(64, "0");
        await this.setupTkey(existingSFAKey, loginResponse, true);
      } else {
        await this.setupTkey(importTssKey, loginResponse, false);
      }
    } catch (err) {
      log.error("login error", err);
      if (err instanceof CoreError$1) {
        if (err.code === 1302) {
          throw CoreKitError.default(ERRORS.TKEY_SHARES_REQUIRED);
        }
      }
      throw CoreKitError.default(err.message);
    }
  }
  async loginWithJWT(params) {
    this.checkReady();
    const {
      prefetchTssPublicKeys = 1
    } = params;
    if (prefetchTssPublicKeys > 3) {
      throw CoreKitError.prefetchValueExceeded(`The prefetch value '${prefetchTssPublicKeys}' exceeds the maximum allowed limit of 3.`);
    }
    const {
      verifier,
      verifierId,
      idToken,
      importTssKey,
      registerExistingSFAKey
    } = params;
    this.torusSp.verifierName = verifier;
    this.torusSp.verifierId = verifierId;
    if (registerExistingSFAKey && importTssKey) {
      throw CoreKitError.invalidConfig("Cannot import TSS key and register SFA key at the same time.");
    }
    try {
      var _loginResponse$nodesD3;
      const prefetchTssPubs = [];
      for (let i = 0; i < prefetchTssPublicKeys; i++) {
        prefetchTssPubs.push(this.torusSp.getTSSPubKey(this.tkey.tssTag, i));
      }
      let loginPromise;
      if (!params.subVerifier) {
        loginPromise = this.torusSp.customAuthInstance.getTorusKey(verifier, verifierId, {
          verifier_id: verifierId
        }, idToken, _objectSpread2(_objectSpread2({}, params.extraVerifierParams), params.additionalParams));
      } else {
        loginPromise = this.torusSp.customAuthInstance.getAggregateTorusKey(verifier, verifierId, [{
          verifier: params.subVerifier,
          idToken,
          extraVerifierParams: params.extraVerifierParams
        }]);
      }
      const [loginResponse] = await Promise.all([loginPromise, ...prefetchTssPubs]);
      const postBoxKey = this._getPostBoxKey(loginResponse);
      this.torusSp.postboxKey = new import_bn8.default(postBoxKey, "hex");
      this.updateState({
        postBoxKey,
        postboxKeyNodeIndexes: ((_loginResponse$nodesD3 = loginResponse.nodesData) === null || _loginResponse$nodesD3 === void 0 ? void 0 : _loginResponse$nodesD3.nodeIndexes) || [],
        userInfo: _objectSpread2(_objectSpread2({}, parseToken(idToken)), {}, {
          verifier,
          verifierId
        }),
        signatures: this._getSignatures(loginResponse.sessionData.sessionTokenData)
      });
      if (registerExistingSFAKey && loginResponse.finalKeyData.privKey) {
        if (loginResponse.metadata.typeOfUser === "v1") {
          throw CoreKitError.invalidConfig("Cannot register existing SFA key for v1 users, please contact web3auth support.");
        }
        const existingSFAKey = loginResponse.finalKeyData.privKey.padStart(64, "0");
        await this.setupTkey(existingSFAKey, loginResponse, true);
      } else {
        await this.setupTkey(importTssKey, loginResponse, false);
      }
    } catch (err) {
      log.error("login error", err);
      if (err instanceof CoreError$1) {
        if (err.code === 1302) {
          const newError2 = CoreKitError.default(ERRORS.TKEY_SHARES_REQUIRED);
          newError2.stack = err.stack;
          throw newError2;
        }
      }
      const newError = CoreKitError.default(err.message);
      newError.stack = err.stack;
      throw newError;
    }
  }
  setPreSigningHook(preSigningHook) {
    this.preSigningHook = preSigningHook;
  }
  async handleRedirectResult() {
    this.checkReady();
    try {
      const result = await this.torusSp.customAuthInstance.getRedirectResult();
      let loginResponse;
      if (result.method === TORUS_METHOD.TRIGGER_LOGIN) {
        var _loginResponse$nodesD4;
        loginResponse = result.result;
        if (!loginResponse) {
          throw CoreKitError.invalidTorusLoginResponse();
        }
        this.updateState({
          postBoxKey: this._getPostBoxKey(loginResponse),
          postboxKeyNodeIndexes: ((_loginResponse$nodesD4 = loginResponse.nodesData) === null || _loginResponse$nodesD4 === void 0 ? void 0 : _loginResponse$nodesD4.nodeIndexes) || [],
          userInfo: loginResponse.userInfo,
          signatures: this._getSignatures(loginResponse.sessionData.sessionTokenData)
        });
        const userInfo2 = this.getUserInfo();
        this.torusSp.verifierName = userInfo2.verifier;
      } else if (result.method === TORUS_METHOD.TRIGGER_AGGREGATE_LOGIN) {
        var _loginResponse$nodesD5;
        loginResponse = result.result;
        if (!loginResponse) {
          throw CoreKitError.invalidTorusAggregateLoginResponse();
        }
        this.updateState({
          postBoxKey: this._getPostBoxKey(loginResponse),
          postboxKeyNodeIndexes: ((_loginResponse$nodesD5 = loginResponse.nodesData) === null || _loginResponse$nodesD5 === void 0 ? void 0 : _loginResponse$nodesD5.nodeIndexes) || [],
          userInfo: loginResponse.userInfo[0],
          signatures: this._getSignatures(loginResponse.sessionData.sessionTokenData)
        });
        const userInfo2 = this.getUserInfo();
        this.torusSp.verifierName = userInfo2.aggregateVerifier;
      } else {
        throw CoreKitError.unsupportedRedirectMethod();
      }
      const userInfo = this.getUserInfo();
      if (!this.state.postBoxKey) {
        throw CoreKitError.postBoxKeyMissing("postBoxKey not present in state after processing redirect result.");
      }
      this.torusSp.postboxKey = new import_bn8.default(this.state.postBoxKey, "hex");
      this.torusSp.verifierId = userInfo.verifierId;
      await this.setupTkey();
    } catch (error) {
      this.resetState();
      log.error("error while handling redirect result", error);
      throw CoreKitError.default(error.message);
    }
  }
  async inputFactorKey(factorKey) {
    this.checkReady();
    try {
      if (!this.tKey.secp256k1Key) {
        var _this$tkey$metadata$f;
        const factorKeyPrivate = factorKeyCurve.keyFromPrivate(factorKey.toBuffer());
        const factorPubX = factorKeyPrivate.getPublic().getX().toString("hex").padStart(64, "0");
        const factorEncExist = (_this$tkey$metadata$f = this.tkey.metadata.factorEncs) === null || _this$tkey$metadata$f === void 0 || (_this$tkey$metadata$f = _this$tkey$metadata$f[this.tkey.tssTag]) === null || _this$tkey$metadata$f === void 0 ? void 0 : _this$tkey$metadata$f[factorPubX];
        if (!factorEncExist) {
          throw CoreKitError.providedFactorKeyInvalid("Invalid FactorKey provided. Failed to input factor key.");
        }
        const factorKeyMetadata = await this.getFactorKeyMetadata(factorKey);
        await this.tKey.inputShareStoreSafe(factorKeyMetadata, true);
      }
      await this.tKey.reconstructKey();
      await this.finalizeTkey(factorKey);
    } catch (err) {
      log.error("login error", err);
      if (err instanceof CoreError$1) {
        if (err.code === 1302) {
          throw CoreKitError.default(ERRORS.TKEY_SHARES_REQUIRED);
        }
      }
      throw CoreKitError.default(err.message);
    }
  }
  setTssWalletIndex(accountIndex) {
    this.updateState({
      tssPubKey: this.tKey.getTSSPub(accountIndex).toSEC1(this.tkey.tssCurve, false),
      accountIndex
    });
  }
  getCurrentFactorKey() {
    this.checkReady();
    if (!this.state.factorKey) {
      throw CoreKitError.factorKeyNotPresent("factorKey not present in state when getting current factor key.");
    }
    if (!this.state.tssShareIndex) {
      throw CoreKitError.tssShareTypeIndexMissing("TSS Share Type (Index) not present in state when getting current factor key.");
    }
    try {
      return {
        factorKey: this.state.factorKey,
        shareType: this.state.tssShareIndex
      };
    } catch (err) {
      log.error("state error", err);
      throw CoreKitError.default(err.message);
    }
  }
  async enableMFA(enableMFAParams, recoveryFactor = true) {
    this.checkReady();
    const {
      postBoxKey
    } = this.state;
    const hashedFactorKey = getHashedPrivateKey(postBoxKey, this.options.hashedFactorNonce);
    if (!await this.checkIfFactorKeyValid(hashedFactorKey)) {
      if (this.tKey._localMetadataTransitions[0].length) {
        throw CoreKitError.commitChangesBeforeMFA();
      }
      throw CoreKitError.mfaAlreadyEnabled();
    }
    return this.atomicSync(async () => {
      let browserData;
      if (this.isNodejsOrRN(this.options.uxMode)) {
        browserData = {
          browserName: "Node Env",
          browserVersion: "",
          deviceName: "nodejs"
        };
      } else {
        const browserInfo = bowser_default.parse(navigator.userAgent);
        const browserName = `${browserInfo.browser.name}`;
        browserData = {
          browserName,
          browserVersion: browserInfo.browser.version,
          deviceName: browserInfo.os.name
        };
      }
      const deviceFactorKey = new import_bn8.default(await this.createFactor({
        shareType: TssShareType.DEVICE,
        additionalMetadata: browserData
      }), "hex");
      await this.setDeviceFactor(deviceFactorKey);
      await this.inputFactorKey(new import_bn8.default(deviceFactorKey, "hex"));
      const hashedFactorPub = getPubKeyPoint2(hashedFactorKey, factorKeyCurve);
      await this.deleteFactor(hashedFactorPub, hashedFactorKey);
      await this.deleteMetadataShareBackup(hashedFactorKey);
      let backupFactorKey;
      if (recoveryFactor) {
        backupFactorKey = await this.createFactor(_objectSpread2({
          shareType: TssShareType.RECOVERY
        }, enableMFAParams));
      }
      return backupFactorKey;
    }).catch((reason) => {
      log.error("error enabling MFA:", reason.message);
      const err = CoreKitError.default(reason.message);
      err.stack = reason.stack;
      throw err;
    });
  }
  // mutation function
  async createFactor(createFactorParams) {
    this.checkReady();
    const {
      shareType
    } = createFactorParams;
    let {
      factorKey,
      shareDescription,
      additionalMetadata
    } = createFactorParams;
    if (!VALID_SHARE_INDICES.includes(shareType)) {
      throw CoreKitError.newShareIndexInvalid(`Invalid share type provided (${shareType}). Valid share types are ${VALID_SHARE_INDICES}.`);
    }
    if (!factorKey) {
      factorKey = generateFactorKey().private;
    }
    if (!shareDescription) {
      shareDescription = FactorKeyTypeShareDescription.Other;
    }
    if (!additionalMetadata) {
      additionalMetadata = {};
    }
    const factorPub = getPubKeyPoint2(factorKey, factorKeyCurve);
    if (this.getTssFactorPub().includes(factorPub.toSEC1(factorKeyCurve, true).toString("hex"))) {
      throw CoreKitError.factorKeyAlreadyExists();
    }
    return this.atomicSync(async () => {
      await this.copyOrCreateShare(shareType, factorPub);
      await this.backupMetadataShare(factorKey);
      await this.addFactorDescription({
        factorKey,
        shareDescription,
        additionalMetadata,
        updateMetadata: false
      });
      return scalarBNToBufferSEC1(factorKey).toString("hex");
    }).catch((reason) => {
      log.error("error creating factor:", reason.message);
      const err = CoreKitError.default(`error creating factor: ${reason.message}`);
      err.stack = reason.stack;
      throw err;
    });
  }
  /**
   * Get public key point in SEC1 format.
   */
  getPubKey() {
    const {
      tssPubKey
    } = this.state;
    return Buffer.from(tssPubKey);
  }
  /**
   * Get public key point.
   */
  getPubKeyPoint() {
    const {
      tssPubKey
    } = this.state;
    return Point$1.fromSEC1(this.tkey.tssCurve, tssPubKey.toString("hex"));
  }
  /**
   * Get public key in ed25519 format.
   *
   * Throws an error if keytype is not compatible with ed25519.
   */
  getPubKeyEd25519() {
    const p = this.tkey.tssCurve.keyFromPublic(this.getPubKey()).getPublic();
    return ed25519().keyFromPublic(p).getPublic();
  }
  async precompute_secp256k1() {
    this.wasmLib = await this.loadTssWasm();
    const {
      tssShareIndex
    } = this.state;
    const tssPubKey = this.getPubKeyPoint();
    const {
      torusNodeTSSEndpoints
    } = fetchLocalConfig(this.options.web3AuthNetwork, this.keyType);
    if (!this.state.factorKey) {
      throw CoreKitError.factorKeyNotPresent("factorKey not present in state when signing.");
    }
    const {
      tssShare
    } = await this.tKey.getTSSShare(this.state.factorKey, {
      accountIndex: 0
    });
    const tssNonce = this.getTssNonce();
    if (!tssPubKey || !torusNodeTSSEndpoints) {
      throw CoreKitError.tssPublicKeyOrEndpointsMissing();
    }
    const randomSessionNonce = generateSessionNonce();
    const currentSession = getSessionId(this.verifier, this.verifierId, this.tKey.tssTag, tssNonce, randomSessionNonce);
    const parties = 4;
    const clientIndex = parties - 1;
    const {
      nodeIndexes
    } = await this.torusSp.getTSSPubKey(this.tKey.tssTag, this.tKey.metadata.tssNonces[this.tKey.tssTag]);
    const {
      endpoints,
      tssWSEndpoints,
      partyIndexes,
      nodeIndexesReturned: participatingServerDKGIndexes
    } = generateTSSEndpoints(torusNodeTSSEndpoints, parties, clientIndex, nodeIndexes);
    const sockets = await setupSockets(tssWSEndpoints, randomSessionNonce);
    const dklsCoeff = getDKLSCoeff(true, participatingServerDKGIndexes, tssShareIndex);
    const denormalisedShare = dklsCoeff.mul(tssShare).umod(secp256k1.curve.n);
    const accountNonce = this.tkey.computeAccountNonce(this.state.accountIndex);
    const derivedShare = denormalisedShare.add(accountNonce).umod(secp256k1.curve.n);
    const share = scalarBNToBufferSEC1(derivedShare).toString("base64");
    if (!currentSession) {
      throw CoreKitError.activeSessionNotFound();
    }
    const {
      signatures
    } = this;
    if (!signatures) {
      throw CoreKitError.signaturesNotPresent();
    }
    const tssPubKeyBase64 = Buffer.from(tssPubKey.toSEC1(secp256k1).subarray(1)).toString("base64");
    const client = new Client(currentSession, clientIndex, partyIndexes, endpoints, sockets, share, tssPubKeyBase64, true, this.wasmLib);
    const serverCoeffs = {};
    for (let i = 0; i < participatingServerDKGIndexes.length; i++) {
      const serverIndex = participatingServerDKGIndexes[i];
      serverCoeffs[serverIndex] = getDKLSCoeff(false, participatingServerDKGIndexes, tssShareIndex, serverIndex).toString("hex");
    }
    client.precompute({
      signatures,
      server_coeffs: serverCoeffs,
      nonce: scalarBNToBufferSEC1(this.getAccountNonce()).toString("base64")
    });
    await client.ready().catch((err) => {
      client.cleanup({
        signatures,
        server_coeffs: serverCoeffs
      });
      throw err;
    });
    return {
      client,
      serverCoeffs
    };
  }
  async sign(data, hashed = false, secp256k1Precompute) {
    if (this.preSigningHook) {
      const result = await this.preSigningHook({
        data: Uint8Array.from(data),
        hashed
      });
      if (!result.success || result.error) {
        throw Error(result.error || "preSigningValidator failed");
      }
    }
    this.wasmLib = await this.loadTssWasm();
    if (this.keyType === KeyType.secp256k1) {
      const sig = await this.sign_ECDSA_secp256k1(data, hashed, secp256k1Precompute);
      return Buffer.concat([sig.r, sig.s, Buffer.from([sig.v])]);
    } else if (this.keyType === KeyType.ed25519) {
      return this.sign_ed25519(data, hashed);
    }
    throw CoreKitError.default(`sign not supported for key type ${this.keyType}`);
  }
  // mutation function
  async deleteFactor(factorPub, factorKey) {
    if (!this.state.factorKey) {
      throw CoreKitError.factorKeyNotPresent("factorKey not present in state when deleting a factor.");
    }
    if (!this.tKey.metadata.factorPubs) {
      throw CoreKitError.factorPubsMissing();
    }
    await this.atomicSync(async () => {
      const remainingFactors = this.tKey.metadata.factorPubs[this.tKey.tssTag].length || 0;
      if (remainingFactors <= 1) {
        throw CoreKitError.cannotDeleteLastFactor("Cannot delete last factor");
      }
      const fpp = factorPub;
      const stateFpp = getPubKeyPoint2(this.state.factorKey, factorKeyCurve);
      if (fpp.equals(stateFpp)) {
        throw CoreKitError.factorInUseCannotBeDeleted("Cannot delete current active factor");
      }
      await this.tKey.deleteFactorPub({
        factorKey: this.state.factorKey,
        deleteFactorPub: factorPub,
        authSignatures: this.signatures
      });
      const factorPubHex = fpp.toSEC1(factorKeyCurve, true).toString("hex");
      const allDesc = this.tKey.metadata.getShareDescription();
      const keyDesc = allDesc[factorPubHex];
      if (keyDesc) {
        await Promise.all(keyDesc.map(async (desc) => {
          var _this$tKey;
          return (_this$tKey = this.tKey) === null || _this$tKey === void 0 ? void 0 : _this$tKey.metadata.deleteShareDescription(factorPubHex, desc);
        }));
      }
      if (factorKey) {
        const factorKeyBN = new import_bn8.default(factorKey, "hex");
        const derivedFactorPub = getPubKeyPoint2(factorKeyBN, factorKeyCurve);
        if (derivedFactorPub.equals(fpp)) {
          await this.deleteMetadataShareBackup(factorKeyBN);
        }
      }
    });
  }
  async logout() {
    var _this$sessionManager2;
    if ((_this$sessionManager2 = this.sessionManager) !== null && _this$sessionManager2 !== void 0 && _this$sessionManager2.sessionId) {
      await this.sessionManager.invalidateSession();
    }
    await this.currentStorage.set("sessionId", "");
    this.resetState();
    await this.init({
      handleRedirectResult: false,
      rehydrate: false
    });
  }
  getUserInfo() {
    if (!this.state.userInfo) {
      throw CoreKitError.userNotLoggedIn();
    }
    return this.state.userInfo;
  }
  getKeyDetails() {
    this.checkReady();
    const tkeyDetails = this.tKey.getKeyDetails();
    const tssPubKey = this.state.tssPubKey ? Point$1.fromSEC1(this.tkey.tssCurve, this.state.tssPubKey.toString("hex")) : void 0;
    const factors = this.tKey.metadata.factorPubs ? this.tKey.metadata.factorPubs[this.tKey.tssTag] : [];
    const keyDetails = {
      // use tkey's for now
      requiredFactors: tkeyDetails.requiredShares,
      threshold: tkeyDetails.threshold,
      totalFactors: factors.length + 1,
      shareDescriptions: this.tKey.getMetadata().getShareDescription(),
      metadataPubKey: tkeyDetails.pubKey,
      tssPubKey,
      keyType: this.keyType
    };
    return keyDetails;
  }
  async commitChanges() {
    this.checkReady();
    if (!this.state.factorKey) {
      throw CoreKitError.factorKeyNotPresent("factorKey not present in state when committing changes.");
    }
    try {
      await this.tKey._syncShareMetadata();
      await this.tKey.syncLocalMetadataTransitions();
    } catch (error) {
      log.error("sync metadata error", error);
      throw error;
    }
  }
  async setManualSync(manualSync) {
    this.checkReady();
    await this.tKey.syncLocalMetadataTransitions();
    this.options.manualSync = manualSync;
    this.tKey.manualSync = manualSync;
  }
  // device factor
  async setDeviceFactor(factorKey, replace = false) {
    if (!replace) {
      const existingFactor = await this.getDeviceFactor();
      if (existingFactor) {
        throw CoreKitError.default("Device factor already exists");
      }
    }
    const metadata = this.tKey.getMetadata();
    const tkeyPubX = metadata.pubKey.x.toString(16, FIELD_ELEMENT_HEX_LEN);
    await this.currentStorage.set(tkeyPubX, JSON.stringify({
      factorKey: factorKey.toString("hex").padStart(64, "0")
    }));
  }
  async getDeviceFactor() {
    const metadata = this.tKey.getMetadata();
    const tkeyPubX = metadata.pubKey.x.toString(16, FIELD_ELEMENT_HEX_LEN);
    const tKeyLocalStoreString = await this.currentStorage.get(tkeyPubX);
    const tKeyLocalStore = JSON.parse(tKeyLocalStoreString || "{}");
    return tKeyLocalStore.factorKey;
  }
  /**
   * WARNING: Use with caution. This will export the private signing key.
   *
   * Exports the private key scalar for the current account index.
   *
   * For keytype ed25519, consider using _UNSAFE_exportTssEd25519Seed.
   */
  async _UNSAFE_exportTssKey() {
    if (this.keyType !== KeyType.secp256k1) {
      throw CoreKitError.default("Wrong KeyType. Method can only be used when KeyType is secp256k1");
    }
    if (!this.state.factorKey) {
      throw CoreKitError.factorKeyNotPresent("factorKey not present in state when exporting tss key.");
    }
    if (!this.state.signatures) {
      throw CoreKitError.signaturesNotPresent("Signatures not present in state when exporting tss key.");
    }
    const exportTssKey0 = await this.tKey._UNSAFE_exportTssKey({
      factorKey: this.state.factorKey,
      authSignatures: this.state.signatures
    });
    const accountNonce = this.getAccountNonce();
    const tssKey = exportTssKey0.add(accountNonce).umod(this.tKey.tssCurve.n);
    return tssKey.toString("hex", FIELD_ELEMENT_HEX_LEN);
  }
  /**
   * WARNING: Use with caution. This will export the private signing key.
   *
   * Attempts to export the ed25519 private key seed. Only works if import key
   * flow has been used.
   */
  async _UNSAFE_exportTssEd25519Seed() {
    if (this.keyType !== KeyType.ed25519) {
      throw CoreKitError.default("Wrong KeyType. Method can only be used when KeyType is ed25519");
    }
    if (!this.state.factorKey) throw CoreKitError.factorKeyNotPresent("factorKey not present in state when exporting tss ed25519 seed.");
    if (!this.state.signatures) throw CoreKitError.signaturesNotPresent("Signatures not present in state when exporting tss ed25519 seed.");
    try {
      const exportEd25519Seed = await this.tKey._UNSAFE_exportTssEd25519Seed({
        factorKey: this.state.factorKey,
        authSignatures: this.state.signatures
      });
      return exportEd25519Seed;
    } catch (error) {
      throw CoreKitError.default(`Error exporting ed25519 seed: ${error}`);
    }
  }
  updateState(newState) {
    this.state = _objectSpread2(_objectSpread2({}, this.state), newState);
  }
  async atomicSync(f) {
    this.atomicCallStackCounter += 1;
    this.tkey.manualSync = true;
    try {
      const r = await f();
      if (this.atomicCallStackCounter === 1) {
        if (!this.options.manualSync) {
          await this.commitChanges();
        }
      }
      return r;
    } catch (error) {
      throw error;
    } finally {
      this.atomicCallStackCounter -= 1;
      if (this.atomicCallStackCounter === 0) {
        this.tkey.manualSync = this.options.manualSync;
      }
    }
  }
  async importTssKey(tssKey, factorPub, newTSSIndex = TssShareType.DEVICE) {
    if (!this.state.signatures) {
      throw CoreKitError.signaturesNotPresent("Signatures not present in state when importing tss key.");
    }
    await this.tKey.importTssKey({
      tag: this.tKey.tssTag,
      importKey: Buffer.from(tssKey, "hex"),
      factorPub,
      newTSSIndex
    }, {
      authSignatures: this.state.signatures
    });
  }
  getTssNonce() {
    if (!this.tKey.metadata.tssNonces || this.tKey.metadata.tssNonces[this.tKey.tssTag] === void 0) {
      throw CoreKitError.tssNoncesMissing(`tssNonce not present for tag ${this.tKey.tssTag}`);
    }
    const tssNonce = this.tKey.metadata.tssNonces[this.tKey.tssTag];
    return tssNonce;
  }
  async setupTkey(providedImportKey, sfaLoginResponse, importingSFAKey) {
    if (importingSFAKey && !sfaLoginResponse) {
      throw CoreKitError.default("SFA key registration requires SFA login response");
    }
    if (!this.state.postBoxKey) {
      throw CoreKitError.userNotLoggedIn();
    }
    const existingUser = await this.isMetadataPresent(this.state.postBoxKey);
    let importKey = providedImportKey;
    if (!existingUser) {
      if (!importKey && this.useClientGeneratedTSSKey) {
        if (this.keyType === KeyType.ed25519) {
          const k = generateEd25519Seed();
          importKey = k.toString("hex");
        } else if (this.keyType === KeyType.secp256k1) {
          const k = secp256k1.genKeyPair().getPrivate();
          importKey = scalarBNToBufferSEC1(k).toString("hex");
        } else {
          throw CoreKitError.default("Unsupported key type");
        }
      }
      if (importingSFAKey && sfaLoginResponse && sfaLoginResponse.metadata.upgraded) {
        throw CoreKitError.default("SFA key registration is not allowed for already upgraded users");
      }
      await this.handleNewUser(importKey, importingSFAKey);
    } else {
      if (importKey) {
        throw CoreKitError.tssKeyImportNotAllowed();
      }
      await this.handleExistingUser();
    }
  }
  // mutation function
  async handleNewUser(importTssKey, isSfaKey) {
    await this.atomicSync(async () => {
      let factorKey;
      if (this.options.disableHashedFactorKey) {
        factorKey = generateFactorKey().private;
        const hashedFactorKey = getHashedPrivateKey(this.state.postBoxKey, this.options.hashedFactorNonce);
        await this.deleteMetadataShareBackup(hashedFactorKey);
      } else {
        factorKey = getHashedPrivateKey(this.state.postBoxKey, this.options.hashedFactorNonce);
      }
      const deviceTSSIndex = TssShareType.DEVICE;
      const factorPub = getPubKeyPoint2(factorKey, factorKeyCurve);
      if (!importTssKey) {
        const ec$12 = new import_elliptic5.ec(this.keyType);
        const deviceTSSShare = ec$12.genKeyPair().getPrivate();
        await this.tKey.initialize({
          factorPub,
          deviceTSSShare,
          deviceTSSIndex
        });
      } else {
        await this.tKey.initialize({
          skipTssInit: true
        });
        await this.tKey.reconstructKey();
        await this.importTssKey(importTssKey, factorPub, deviceTSSIndex);
      }
      await this.tKey.reconstructKey();
      await this.finalizeTkey(factorKey);
      await this.backupMetadataShare(factorKey);
      if (this.options.disableHashedFactorKey) {
        await this.addFactorDescription({
          factorKey,
          shareDescription: FactorKeyTypeShareDescription.Other,
          updateMetadata: false
        });
      } else {
        await this.addFactorDescription({
          factorKey,
          shareDescription: FactorKeyTypeShareDescription.HashedShare,
          updateMetadata: false
        });
      }
      if (importTssKey && isSfaKey) {
        await this.tkey.addLocalMetadataTransitions({
          input: [{
            message: ONE_KEY_DELETE_NONCE
          }],
          privKey: [new import_bn8.default(this.state.postBoxKey, "hex")]
        });
      }
    });
  }
  async handleExistingUser() {
    await this.tKey.initialize({
      neverInitializeNewKey: true
    });
    if (this.options.disableHashedFactorKey) {
      return;
    }
    const hashedFactorKey = getHashedPrivateKey(this.state.postBoxKey, this.options.hashedFactorNonce);
    this.state.factorKey = hashedFactorKey;
    if (await this.checkIfFactorKeyValid(hashedFactorKey)) {
      const factorKeyMetadata = await this.getFactorKeyMetadata(hashedFactorKey);
      try {
        await this.tKey.inputShareStoreSafe(factorKeyMetadata, true);
        await this.tKey.reconstructKey();
        await this.finalizeTkey(hashedFactorKey);
      } catch (err) {
        log.error("error initializing tkey with hashed share", err);
      }
    } else {
      var _this$tKey2;
      const factorKeyMetadata = await ((_this$tKey2 = this.tKey) === null || _this$tKey2 === void 0 ? void 0 : _this$tKey2.readMetadata(hashedFactorKey));
      if (factorKeyMetadata.message === "SHARE_DELETED") {
        log.warn("hashed factor deleted");
      }
    }
  }
  async finalizeTkey(factorKey) {
    if (this.state.accountIndex !== 0) {
      log.warn("AccountIndex should be 0");
      this.state.accountIndex = 0;
    }
    const {
      tssIndex: tssShareIndex
    } = await this.tKey.getTSSShare(factorKey);
    const tssPubKey = this.tKey.getTSSPub().toSEC1(this.tkey.tssCurve, false);
    this.updateState({
      tssShareIndex,
      tssPubKey,
      factorKey
    });
    await this.createSession();
  }
  checkReady() {
    if (!this.ready) {
      throw CoreKitError.mpcCoreKitNotInitialized();
    }
  }
  async rehydrateSession(result) {
    try {
      this.checkReady();
      const factorKey = new import_bn8.default(result.factorKey, "hex");
      if (!factorKey) {
        throw CoreKitError.providedFactorKeyInvalid();
      }
      const postBoxKey = result.postBoxKey || result.oAuthKey;
      if (!postBoxKey) {
        throw CoreKitError.default("postBoxKey or oAuthKey not present in session data");
      }
      this.torusSp.postboxKey = new import_bn8.default(postBoxKey, "hex");
      this.torusSp.verifierName = result.userInfo.aggregateVerifier || result.userInfo.verifier;
      this.torusSp.verifierId = result.userInfo.verifierId;
      const factorKeyMetadata = await this.getFactorKeyMetadata(factorKey);
      await this.tKey.initialize({
        neverInitializeNewKey: true
      });
      await this.tKey.inputShareStoreSafe(factorKeyMetadata, true);
      await this.tKey.reconstructKey();
      this.updateState({
        factorKey: new import_bn8.default(result.factorKey, "hex"),
        postBoxKey,
        postboxKeyNodeIndexes: result.postboxKeyNodeIndexes || [],
        tssShareIndex: result.tssShareIndex,
        tssPubKey: this.tkey.getTSSPub().toSEC1(this.tKey.tssCurve, false),
        signatures: result.signatures,
        userInfo: result.userInfo
      });
    } catch (err) {
      log.warn("failed to authorize session", err);
    }
  }
  async createSession() {
    if (!this.options.disableSessionManager && !this.sessionManager) {
      throw new Error("sessionManager is not available");
    }
    if (this.options.disableSessionManager) {
      return;
    }
    try {
      const sessionId = SessionManager.generateRandomSessionKey();
      this.sessionManager.sessionId = sessionId;
      const {
        postBoxKey,
        factorKey,
        userInfo,
        tssShareIndex,
        tssPubKey,
        postboxKeyNodeIndexes
      } = this.state;
      if (!this.state.factorKey) {
        throw CoreKitError.factorKeyNotPresent("factorKey not present in state when creating session.");
      }
      const {
        tssShare
      } = await this.tKey.getTSSShare(this.state.factorKey, {
        accountIndex: this.state.accountIndex
      });
      if (!postBoxKey || !factorKey || !tssShare || !tssPubKey || !userInfo) {
        throw CoreKitError.userNotLoggedIn();
      }
      const payload = {
        postBoxKey,
        postboxKeyNodeIndexes: postboxKeyNodeIndexes || [],
        factorKey: factorKey === null || factorKey === void 0 ? void 0 : factorKey.toString("hex"),
        tssShareIndex,
        tssPubKey: Buffer.from(tssPubKey).toString("hex"),
        signatures: this.signatures,
        userInfo
      };
      await this.sessionManager.createSession(payload);
      await this.currentStorage.set("sessionId", sessionId);
    } catch (err) {
      log.error("error creating session", err);
    }
  }
  async isMetadataPresent(privateKey) {
    var _this$tKey3;
    const privateKeyBN = new import_bn8.default(privateKey, "hex");
    const metadata = await ((_this$tKey3 = this.tKey) === null || _this$tKey3 === void 0 ? void 0 : _this$tKey3.readMetadata(privateKeyBN));
    if (metadata && metadata.message !== "KEY_NOT_FOUND") {
      return true;
    }
    return false;
  }
  async checkIfFactorKeyValid(factorKey) {
    var _this$tKey4;
    this.checkReady();
    const factorKeyMetadata = await ((_this$tKey4 = this.tKey) === null || _this$tKey4 === void 0 ? void 0 : _this$tKey4.readMetadata(factorKey));
    if (!factorKeyMetadata || factorKeyMetadata.message === "KEY_NOT_FOUND" || factorKeyMetadata.message === "SHARE_DELETED") {
      return false;
    }
    return true;
  }
  async getFactorKeyMetadata(factorKey) {
    var _this$tKey5;
    this.checkReady();
    const factorKeyMetadata = await ((_this$tKey5 = this.tKey) === null || _this$tKey5 === void 0 ? void 0 : _this$tKey5.readMetadata(factorKey));
    if (!factorKeyMetadata || factorKeyMetadata.message === "KEY_NOT_FOUND") {
      throw CoreKitError.noMetadataFound();
    }
    return ShareStore$1.fromJSON(factorKeyMetadata);
  }
  /**
   * Copies a share and makes it available under a new factor key. If no share
   * exists at the specified share index, a new share is created.
   * @param newFactorTSSIndex - The index of the share to copy.
   * @param newFactorPub - The public key of the new share.
   */
  async copyOrCreateShare(newFactorTSSIndex, newFactorPub) {
    this.checkReady();
    if (!this.tKey.metadata.factorPubs || !Array.isArray(this.tKey.metadata.factorPubs[this.tKey.tssTag])) {
      throw CoreKitError.factorPubsMissing("'factorPubs' is missing in the metadata. Failed to copy factor public key.");
    }
    if (!this.tKey.metadata.factorEncs || typeof this.tKey.metadata.factorEncs[this.tKey.tssTag] !== "object") {
      throw CoreKitError.factorEncsMissing("'factorEncs' is missing in the metadata. Failed to copy factor public key.");
    }
    if (!this.state.factorKey) {
      throw CoreKitError.factorKeyNotPresent("factorKey not present in state when copying or creating a share.");
    }
    if (VALID_SHARE_INDICES.indexOf(newFactorTSSIndex) === -1) {
      throw CoreKitError.newShareIndexInvalid(`Invalid share type provided (${newFactorTSSIndex}). Valid share types are ${VALID_SHARE_INDICES}.`);
    }
    if (this.tKey.metadata.factorPubs[this.tKey.tssTag].length >= MAX_FACTORS) {
      throw CoreKitError.maximumFactorsReached(`The maximum number of allowable factors (${MAX_FACTORS}) has been reached.`);
    }
    await this.tkey.addFactorPub({
      existingFactorKey: this.state.factorKey,
      authSignatures: this.signatures,
      newFactorPub,
      newTSSIndex: newFactorTSSIndex,
      refreshShares: this.state.tssShareIndex !== newFactorTSSIndex
      // Refresh shares if we have a new factor key index.
    });
  }
  async getMetadataShare() {
    try {
      var _this$tKey6, _this$tKey7;
      const polyId = (_this$tKey6 = this.tKey) === null || _this$tKey6 === void 0 ? void 0 : _this$tKey6.metadata.getLatestPublicPolynomial().getPolynomialID();
      const shares = (_this$tKey7 = this.tKey) === null || _this$tKey7 === void 0 ? void 0 : _this$tKey7.shares[polyId];
      let share = null;
      for (const shareIndex in shares) {
        if (shareIndex !== SOCIAL_TKEY_INDEX.toString()) {
          share = shares[shareIndex];
        }
      }
      if (!share) {
        throw CoreKitError.noMetadataShareFound();
      }
      return share;
    } catch (err) {
      log.error("create device share error", err);
      throw CoreKitError.default(err.message);
    }
  }
  async deleteMetadataShareBackup(factorKey) {
    var _this$tkey, _this$tkey2;
    await this.tKey.addLocalMetadataTransitions({
      input: [{
        message: SHARE_DELETED,
        dateAdded: Date.now()
      }],
      privKey: [factorKey]
    });
    if (!((_this$tkey = this.tkey) !== null && _this$tkey !== void 0 && _this$tkey.manualSync)) await ((_this$tkey2 = this.tkey) === null || _this$tkey2 === void 0 ? void 0 : _this$tkey2.syncLocalMetadataTransitions());
  }
  async backupMetadataShare(factorKey) {
    var _this$tKey8, _this$tkey3, _this$tkey4;
    const metadataShare = await this.getMetadataShare();
    await ((_this$tKey8 = this.tKey) === null || _this$tKey8 === void 0 ? void 0 : _this$tKey8.addLocalMetadataTransitions({
      input: [metadataShare],
      privKey: [factorKey]
    }));
    if (!((_this$tkey3 = this.tkey) !== null && _this$tkey3 !== void 0 && _this$tkey3.manualSync)) await ((_this$tkey4 = this.tkey) === null || _this$tkey4 === void 0 ? void 0 : _this$tkey4.syncLocalMetadataTransitions());
  }
  async addFactorDescription(args) {
    var _this$tKey9;
    const {
      factorKey,
      shareDescription,
      updateMetadata
    } = args;
    let {
      additionalMetadata
    } = args;
    if (!additionalMetadata) {
      additionalMetadata = {};
    }
    const {
      tssIndex
    } = await this.tKey.getTSSShare(factorKey);
    const factorPoint = getPubKeyPoint2(factorKey, factorKeyCurve);
    const factorPub = factorPoint.toSEC1(factorKeyCurve, true).toString("hex");
    const params = _objectSpread2(_objectSpread2({
      module: shareDescription,
      dateAdded: Date.now()
    }, additionalMetadata), {}, {
      tssShareIndex: tssIndex
    });
    await ((_this$tKey9 = this.tKey) === null || _this$tKey9 === void 0 ? void 0 : _this$tKey9.addShareDescription(factorPub, JSON.stringify(params), updateMetadata));
  }
  resetState() {
    this.ready = false;
    this.tkey = null;
    this.torusSp = null;
    this.storageLayer = null;
    this.state = {
      accountIndex: 0
    };
  }
  _getPostBoxKey(result) {
    return Torus.getPostboxKey(result);
  }
  _getSignatures(sessionData) {
    return sessionData.filter((session) => !!session).map((session) => JSON.stringify({
      data: session.token,
      sig: session.signature
    }));
  }
  isNodejsOrRN(params) {
    const mode = params;
    return mode === "nodejs" || mode === "react-native";
  }
  async featureRequest() {
    const accessUrl = SIGNER_MAP[this.options.web3AuthNetwork];
    const accessRequest = {
      network: this.options.web3AuthNetwork,
      client_id: this.options.web3AuthClientId,
      is_mpc_core_kit: "true",
      enable_gating: "true",
      session_time: this.options.sessionTime.toString()
    };
    const url = new URL(`${accessUrl}/api/feature-access`);
    url.search = new URLSearchParams(accessRequest).toString();
    const result = await fetch(url);
    if (result.status !== 200) {
      this.resetState();
      const errMessage = await result.json();
      throw CoreKitError.default(errMessage.error);
    }
    return result.json();
  }
  getAccountNonce() {
    return this.tkey.computeAccountNonce(this.state.accountIndex);
  }
  async sign_ECDSA_secp256k1(data, hashed = false, precomputedTssClient) {
    const executeSign = async (client2, serverCoeffs2, hashedData, signatures2) => {
      const {
        r,
        s,
        recoveryParam
      } = await client2.sign(hashedData.toString("base64"), true, "", "keccak256", {
        signatures: signatures2
      });
      client2.cleanup({
        signatures: signatures2,
        server_coeffs: serverCoeffs2
      });
      return {
        v: recoveryParam,
        r: scalarBNToBufferSEC1(r),
        s: scalarBNToBufferSEC1(s)
      };
    };
    if (!hashed) {
      data = keccak2562(data);
    }
    const isAlreadyPrecomputed = (precomputedTssClient === null || precomputedTssClient === void 0 ? void 0 : precomputedTssClient.client) && (precomputedTssClient === null || precomputedTssClient === void 0 ? void 0 : precomputedTssClient.serverCoeffs);
    const {
      client,
      serverCoeffs
    } = isAlreadyPrecomputed ? precomputedTssClient : await this.precompute_secp256k1();
    const {
      signatures
    } = this;
    if (!signatures) {
      throw CoreKitError.signaturesNotPresent();
    }
    try {
      return await executeSign(client, serverCoeffs, data, signatures);
    } catch (error) {
      if (!isAlreadyPrecomputed) {
        throw error;
      }
      const {
        client: newClient,
        serverCoeffs: newServerCoeffs
      } = await this.precompute_secp256k1();
      const result = await executeSign(newClient, newServerCoeffs, data, signatures);
      return result;
    }
  }
  async sign_ed25519(data, hashed = false) {
    if (hashed) {
      throw CoreKitError.default("hashed data not supported for ed25519");
    }
    const nodeDetails = fetchLocalConfig(this.options.web3AuthNetwork, "ed25519");
    if (!nodeDetails.torusNodeTSSEndpoints) {
      throw CoreKitError.default("could not fetch tss node endpoints");
    }
    const ED25519_ENDPOINTS = nodeDetails.torusNodeTSSEndpoints.map((ep, i) => ({
      index: nodeDetails.torusIndexes[i],
      url: `${ep}/`
    }));
    const serverThreshold = Math.floor(ED25519_ENDPOINTS.length / 2) + 1;
    const endpoints = sampleEndpoints(ED25519_ENDPOINTS, serverThreshold);
    const serverXCoords = endpoints.map((x) => x.index);
    const clientXCoord = Math.max(...endpoints.map((ep) => ep.index)) + 1;
    const ec4 = new Ed25519Curve();
    const {
      serverCoefficients,
      clientCoefficient
    } = deriveShareCoefficients(ec4, serverXCoords, clientXCoord, this.state.tssShareIndex);
    const tssPubKey = await this.getPubKey();
    const tssPubKeyPoint = ec4.keyFromPublic(tssPubKey).getPublic();
    if (this.state.accountIndex !== 0) {
      throw CoreKitError.default("Account index not supported for ed25519");
    }
    const {
      tssShare
    } = await this.tKey.getTSSShare(this.state.factorKey);
    const clientShareAdjusted = tssShare.mul(clientCoefficient).umod(ec4.n);
    const clientShareAdjustedHex = ec4.scalarToBuffer(clientShareAdjusted, Buffer).toString("hex");
    const tssNonce = this.getTssNonce();
    const sessionNonce = generateSessionNonce();
    const session = getSessionId(this.verifier, this.verifierId, this.tKey.tssTag, tssNonce, sessionNonce);
    const serverURLs = endpoints.map((x) => x.url);
    const pubKeyHex = ec4.pointToBuffer(tssPubKeyPoint, Buffer).toString("hex");
    const serverCoefficientsHex = serverCoefficients.map((c) => ec4.scalarToBuffer(c, Buffer).toString("hex"));
    const signature = await sign(this.wasmLib, session, this.signatures, serverXCoords, serverURLs, clientXCoord, clientShareAdjustedHex, pubKeyHex, data, serverCoefficientsHex);
    log.info(`signature: ${signature}`);
    return Buffer.from(signature, "hex");
  }
  async loadTssWasm() {
    if (this.wasmLib) return this.wasmLib;
    if (typeof this._tssLib.load === "function") {
      return this._tssLib.load();
    } else if (this._tssLib.lib) {
      return this._tssLib.lib;
    }
  }
};
export {
  AsyncStorage,
  COREKIT_STATUS,
  DELIMITERS,
  ERRORS,
  FIELD_ELEMENT_HEX_LEN,
  FactorKeyTypeShareDescription,
  MAX_FACTORS,
  MemoryStorage,
  SCALAR_LEN,
  SOCIAL_FACTOR_INDEX,
  SOCIAL_TKEY_INDEX,
  TssSecurityQuestion,
  TssSecurityQuestionStore,
  TssShareType,
  USER_PATH,
  VALID_SHARE_INDICES,
  WEB3AUTH_NETWORK,
  Web3AuthMPCCoreKit,
  deriveShareCoefficients,
  ed25519,
  factorKeyCurve,
  fraction,
  generateEd25519Seed,
  generateFactorKey,
  generateSessionNonce,
  generateTSSEndpoints,
  getHashedPrivateKey,
  getSessionId,
  keyToMnemonic,
  lagrangeCoefficient,
  lagrangeCoefficients,
  log,
  makeEthereumSigner,
  mnemonicToKey,
  parseToken,
  randomBytes2 as randomBytes,
  sampleEndpoints,
  scalarBNToBufferSEC1,
  sigToRSV,
  storageAvailable2 as storageAvailable
};
//# sourceMappingURL=@web3auth_mpc-core-kit.js.map
