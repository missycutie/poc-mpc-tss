{
  "version": 3,
  "sources": ["../../@toruslabs/metadata-helpers/dist/lib.esm/utils.js", "../../@toruslabs/metadata-helpers/node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js", "../../@toruslabs/metadata-helpers/dist/lib.esm/webAuthnShareResolver.js", "../../@toruslabs/metadata-helpers/dist/lib.esm/MetadataStorageLayer.js"],
  "sourcesContent": ["import { ec as ec$1 } from 'elliptic';\nimport { keccak256 as keccak256$1 } from 'ethereum-cryptography/keccak';\n\nfunction keccak256(a) {\n  return Buffer.from(keccak256$1(a));\n}\nconst ec = new ec$1(\"secp256k1\");\n\nexport { ec, keccak256 };\n", "import { ec as ec$1 } from 'elliptic';\n\nconst ec = new ec$1(\"secp256k1\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, n/no-unsupported-features/node-builtins\nconst browserCrypto = globalThis.crypto || globalThis.msCrypto || {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\nconst EC_GROUP_ORDER = Buffer.from(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", \"hex\");\nconst ZERO32 = Buffer.alloc(32, 0);\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message || \"Assertion failed\");\n  }\n}\nfunction isScalar(x) {\n  return Buffer.isBuffer(x) && x.length === 32;\n}\nfunction isValidPrivateKey(privateKey) {\n  if (!isScalar(privateKey)) {\n    return false;\n  }\n  return privateKey.compare(ZERO32) > 0 &&\n  // > 0\n  privateKey.compare(EC_GROUP_ORDER) < 0; // < G\n}\n\n// Compare two buffers in constant time to prevent timing attacks.\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n  let res = 0;\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n  return res === 0;\n}\n\n/* This must check if we're in the browser or\nnot, since the functions are different and does\nnot convert using browserify */\nfunction randomBytes(size) {\n  if (typeof browserCrypto.getRandomValues === \"undefined\") {\n    return Buffer.from(browserCrypto.randomBytes(size));\n  }\n  const arr = new Uint8Array(size);\n  browserCrypto.getRandomValues(arr);\n  return Buffer.from(arr);\n}\nasync function sha512(msg) {\n  if (!browserCrypto.createHash) {\n    const hash = await subtle.digest(\"SHA-512\", msg);\n    const result = new Uint8Array(hash);\n    return result;\n  }\n  const hash = browserCrypto.createHash(\"sha512\");\n  const result = hash.update(msg).digest();\n  return new Uint8Array(result);\n}\nfunction getAes(op) {\n  return async function (iv, key, data) {\n    if (subtle && subtle[op] && subtle.importKey) {\n      const importAlgorithm = {\n        name: \"AES-CBC\"\n      };\n      const cryptoKey = await subtle.importKey(\"raw\", key, importAlgorithm, false, [op]);\n      const encAlgorithm = {\n        name: \"AES-CBC\",\n        iv\n      };\n      // encrypt and decrypt ops are not implemented in react-native-quick-crypto yet.\n      const result = await subtle[op](encAlgorithm, cryptoKey, data);\n      return Buffer.from(new Uint8Array(result));\n    } else if (op === \"encrypt\" && browserCrypto.createCipheriv) {\n      // This is available if crypto is polyfilled in react native environment\n      const cipher = browserCrypto.createCipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = cipher.update(data);\n      const secondChunk = cipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    } else if (op === \"decrypt\" && browserCrypto.createDecipheriv) {\n      const decipher = browserCrypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      const firstChunk = decipher.update(data);\n      const secondChunk = decipher.final();\n      return Buffer.concat([firstChunk, secondChunk]);\n    }\n    throw new Error(`Unsupported operation: ${op}`);\n  };\n}\nconst aesCbcEncrypt = getAes(\"encrypt\");\nconst aesCbcDecrypt = getAes(\"decrypt\");\nasync function hmacSha256Sign(key, msg) {\n  if (!browserCrypto.createHmac) {\n    const importAlgorithm = {\n      name: \"HMAC\",\n      hash: {\n        name: \"SHA-256\"\n      }\n    };\n    const cryptoKey = await subtle.importKey(\"raw\", new Uint8Array(key), importAlgorithm, false, [\"sign\", \"verify\"]);\n    const sig = await subtle.sign(\"HMAC\", cryptoKey, msg);\n    const result = Buffer.from(new Uint8Array(sig));\n    return result;\n  }\n  const hmac = browserCrypto.createHmac(\"sha256\", Buffer.from(key));\n  hmac.update(msg);\n  const result = hmac.digest();\n  return result;\n}\nasync function hmacSha256Verify(key, msg, sig) {\n  const expectedSig = await hmacSha256Sign(key, msg);\n  return equalConstTime(expectedSig, sig);\n}\n\n/**\n * Generate a new valid private key. Will use the window.crypto or window.msCrypto as source\n * depending on your browser.\n */\nconst generatePrivate = function () {\n  let privateKey = randomBytes(32);\n  while (!isValidPrivateKey(privateKey)) {\n    privateKey = randomBytes(32);\n  }\n  return privateKey;\n};\nconst getPublic = function (privateKey) {\n  // This function has sync API so we throw an error immediately.\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // XXX(Kagami): `elliptic.utils.encode` returns array for every\n  // encoding except `hex`.\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(\"array\"));\n};\n\n/**\n * Get compressed version of public key.\n */\nconst getPublicCompressed = function (privateKey) {\n  // jshint ignore:line\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  // See https://github.com/wanderer/secp256k1-node/issues/46\n  const compressed = true;\n  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, \"array\"));\n};\n\n// NOTE(Kagami): We don't use promise shim in Browser implementation\n// because it's supported natively in new browsers (see\n// <http://caniuse.com/#feat=promises>) and we can use only new browsers\n// because of the WebCryptoAPI (see\n// <http://caniuse.com/#feat=cryptography>).\nconst sign = async function (privateKey, msg) {\n  assert(privateKey.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKey), \"Bad private key\");\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  return Buffer.from(ec.sign(msg, privateKey, {\n    canonical: true\n  }).toDER());\n};\nconst verify = async function (publicKey, msg, sig) {\n  assert(publicKey.length === 65 || publicKey.length === 33, \"Bad public key\");\n  if (publicKey.length === 65) {\n    assert(publicKey[0] === 4, \"Bad public key\");\n  }\n  if (publicKey.length === 33) {\n    assert(publicKey[0] === 2 || publicKey[0] === 3, \"Bad public key\");\n  }\n  assert(msg.length > 0, \"Message should not be empty\");\n  assert(msg.length <= 32, \"Message is too long\");\n  if (ec.verify(msg, sig, publicKey)) {\n    return null;\n  }\n  throw new Error(\"Bad signature\");\n};\nconst derive = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toArray());\n};\nconst deriveUnpadded = derive;\nconst derivePadded = async function (privateKeyA, publicKeyB) {\n  assert(Buffer.isBuffer(privateKeyA), \"Bad private key\");\n  assert(Buffer.isBuffer(publicKeyB), \"Bad public key\");\n  assert(privateKeyA.length === 32, \"Bad private key\");\n  assert(isValidPrivateKey(privateKeyA), \"Bad private key\");\n  assert(publicKeyB.length === 65 || publicKeyB.length === 33, \"Bad public key\");\n  if (publicKeyB.length === 65) {\n    assert(publicKeyB[0] === 4, \"Bad public key\");\n  }\n  if (publicKeyB.length === 33) {\n    assert(publicKeyB[0] === 2 || publicKeyB[0] === 3, \"Bad public key\");\n  }\n  const keyA = ec.keyFromPrivate(privateKeyA);\n  const keyB = ec.keyFromPublic(publicKeyB);\n  const Px = keyA.derive(keyB.getPublic()); // BN instance\n  return Buffer.from(Px.toString(16, 64), \"hex\");\n};\nconst encrypt = async function (publicKeyTo, msg, opts) {\n  opts = opts || {};\n  let ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  // There is a very unlikely possibility that it is not a valid key\n  while (!isValidPrivateKey(ephemPrivateKey)) {\n    ephemPrivateKey = opts.ephemPrivateKey || randomBytes(32);\n  }\n  const ephemPublicKey = getPublic(ephemPrivateKey);\n  const Px = await deriveUnpadded(ephemPrivateKey, publicKeyTo);\n  const hash = await sha512(Px);\n  const iv = opts.iv || randomBytes(16);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const data = await aesCbcEncrypt(iv, Buffer.from(encryptionKey), msg);\n  const ciphertext = data;\n  const dataToMac = Buffer.concat([iv, ephemPublicKey, ciphertext]);\n  const mac = await hmacSha256Sign(Buffer.from(macKey), dataToMac);\n  return {\n    iv,\n    ephemPublicKey,\n    ciphertext,\n    mac\n  };\n};\nconst decrypt = async function (privateKey, opts, _padding) {\n  const padding = _padding !== null && _padding !== void 0 ? _padding : false;\n  const deriveLocal = padding ? derivePadded : deriveUnpadded;\n  const Px = await deriveLocal(privateKey, opts.ephemPublicKey);\n  const hash = await sha512(Px);\n  const encryptionKey = hash.slice(0, 32);\n  const macKey = hash.slice(32);\n  const dataToMac = Buffer.concat([opts.iv, opts.ephemPublicKey, opts.ciphertext]);\n  const macGood = await hmacSha256Verify(Buffer.from(macKey), dataToMac, opts.mac);\n  if (!macGood && padding === false) {\n    return decrypt(privateKey, opts, true);\n  } else if (!macGood && padding === true) {\n    throw new Error(\"bad MAC after trying padded\");\n  }\n  const msg = await aesCbcDecrypt(opts.iv, Buffer.from(encryptionKey), opts.ciphertext);\n  return Buffer.from(new Uint8Array(msg));\n};\n\nexport { decrypt, derive, derivePadded, deriveUnpadded, encrypt, generatePrivate, getPublic, getPublicCompressed, sign, verify };\n", "import { encrypt, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { ec } from './utils.js';\n\nconst WEBAUTHN_TORUS_SHARE = \"webauthn_torus_share\";\nconst WEBAUTHN_DEVICE_SHARE = \"webauthn_device_share\";\nfunction encParamsHexToBuf(encParamsHex) {\n  return {\n    iv: Buffer.from(encParamsHex.iv, \"hex\"),\n    ephemPublicKey: Buffer.from(encParamsHex.ephemPublicKey, \"hex\"),\n    ciphertext: Buffer.from(encParamsHex.ciphertext, \"hex\"),\n    mac: Buffer.from(encParamsHex.mac, \"hex\")\n  };\n}\nfunction encParamsBufToHex(encParams) {\n  return {\n    iv: Buffer.from(encParams.iv).toString(\"hex\"),\n    ephemPublicKey: Buffer.from(encParams.ephemPublicKey).toString(\"hex\"),\n    ciphertext: Buffer.from(encParams.ciphertext).toString(\"hex\"),\n    mac: Buffer.from(encParams.mac).toString(\"hex\")\n  };\n}\nasync function encryptData(privKeyHex, d) {\n  const serializedDec = JSON.stringify(d);\n  const serializedBuf = Buffer.from(serializedDec, \"utf-8\");\n  const encParams = await encrypt(getPublic(Buffer.from(privKeyHex, \"hex\")), serializedBuf);\n  const encParamsHex = encParamsBufToHex(encParams);\n  const sData = JSON.stringify(encParamsHex);\n  return sData;\n}\nasync function decryptData(privKeyHex, d) {\n  const encParamsHex = JSON.parse(d);\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(privKeyHex);\n  const serializedBuf = await decrypt(Buffer.from(keyPair.getPrivate().toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedDec = serializedBuf.toString(\"utf-8\");\n  const data = JSON.parse(serializedDec);\n  return data;\n}\nasync function getAndDecryptData(m, privKeyHex, namespace) {\n  const keyPair = ec.keyFromPrivate(privKeyHex, \"hex\");\n  const pubKey = keyPair.getPublic();\n  const serializedData = await m.getMetadata({\n    pub_key_X: pubKey.getX().toString(16, 64),\n    pub_key_Y: pubKey.getY().toString(16, 64)\n  }, namespace);\n  if (!serializedData) {\n    return null;\n  }\n  const data = await decryptData(privKeyHex, serializedData);\n  return data;\n}\nasync function encryptAndSetData(m, privKeyHex, d, namespace) {\n  const sData = await encryptData(privKeyHex, d);\n  const metadataParams = m.generateMetadataParams(sData, privKeyHex);\n  await m.setMetadata(metadataParams, namespace);\n}\nasync function setTorusShare(m, webAuthnPubKey, webAuthnRefHex, subspace, subspaceData) {\n  const refKeyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = refKeyPair.getPrivate();\n  const pubKey = ec.keyFromPublic({\n    x: webAuthnPubKey.pub_key_X,\n    y: webAuthnPubKey.pub_key_Y\n  });\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  let d = {};\n  if (data) d = data;\n  const serializedSubspaceData = JSON.stringify(subspaceData);\n  const serializedSubspaceDataBuf = Buffer.from(serializedSubspaceData, \"utf-8\");\n  const encSubspaceData = await encrypt(Buffer.from(pubKey.getPublic(\"hex\"), \"hex\"), serializedSubspaceDataBuf);\n  const encSubspaceDataHex = encParamsBufToHex(encSubspaceData);\n  d[subspace] = encSubspaceDataHex;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_TORUS_SHARE);\n}\nasync function setDeviceShare(m, webAuthnRefHex, subspace, subspaceData) {\n  const keyPair = ec.keyFromPrivate(webAuthnRefHex);\n  const privKey = keyPair.getPrivate();\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  let d = {};\n  if (data) d = data;\n  d[subspace] = subspaceData;\n  await encryptAndSetData(m, privKey.toString(\"hex\", 64), d, WEBAUTHN_DEVICE_SHARE);\n}\nasync function getTorusShare(m, webAuthnKeyHex, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_TORUS_SHARE);\n  if (!data) return null;\n  const encParamsHex = data[subspace];\n  if (!encParamsHex) return null;\n  const encParams = encParamsHexToBuf(encParamsHex);\n  const keyPair = ec.keyFromPrivate(webAuthnKeyHex);\n  const privKey = keyPair.getPrivate();\n  const serializedSubspaceDataBuf = await decrypt(Buffer.from(privKey.toString(\"hex\", 64), \"hex\"), encParams);\n  const serializedSubspaceData = serializedSubspaceDataBuf.toString(\"utf-8\");\n  const subspaceData = JSON.parse(serializedSubspaceData);\n  return subspaceData;\n}\nasync function getDeviceShare(m, webAuthnRefHex, subspace) {\n  const data = await getAndDecryptData(m, webAuthnRefHex, WEBAUTHN_DEVICE_SHARE);\n  if (data) return data[subspace];\n  return null;\n}\n\nexport { decryptData, encParamsBufToHex, encParamsHexToBuf, encryptAndSetData, encryptData, getAndDecryptData, getDeviceShare, getTorusShare, setDeviceShare, setTorusShare };\n", "import _objectSpread from '@babel/runtime/helpers/objectSpread2';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { setAPIKey, setEmbedHost, post } from '@toruslabs/http-helpers';\nimport stringify from 'json-stable-stringify';\nimport { ec, keccak256 } from './utils.js';\n\nclass MetadataStorageLayer {\n  // ms\n\n  constructor(metadataHost = \"https://metadata.tor.us\", serverTimeOffset = 0) {\n    _defineProperty(this, \"metadataHost\", void 0);\n    _defineProperty(this, \"serverTimeOffset\", void 0);\n    this.metadataHost = metadataHost;\n    this.serverTimeOffset = serverTimeOffset;\n  }\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey);\n  }\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost);\n  }\n  generateMetadataParams(message, privateKeyHex) {\n    var _sig$recoveryParam$to, _sig$recoveryParam;\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    const setData = {\n      data: message,\n      timestamp: Math.floor(this.serverTimeOffset + Date.now() / 1000).toString(16)\n    };\n    const sig = key.sign(keccak256(Buffer.from(stringify(setData), \"utf8\")));\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + ((_sig$recoveryParam$to = (_sig$recoveryParam = sig.recoveryParam) === null || _sig$recoveryParam === void 0 ? void 0 : _sig$recoveryParam.toString(16).padStart(2, \"0\").slice(-2)) !== null && _sig$recoveryParam$to !== void 0 ? _sig$recoveryParam$to : \"00\"), \"hex\").toString(\"base64\")\n    };\n  }\n  generatePubKeyParams(privateKeyHex) {\n    const key = ec.keyFromPrivate(privateKeyHex, \"hex\");\n    return {\n      pub_key_X: key.getPublic().getX().toString(16, 64),\n      pub_key_Y: key.getPublic().getY().toString(16, 64)\n    };\n  }\n  async setMetadata(data, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, data), {}, {\n      namespace\n    }) : data;\n    const metadataResponse = await post(`${this.metadataHost}/set`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n  async getMetadata(pubKey, namespace, options) {\n    const params = namespace !== null ? _objectSpread(_objectSpread({}, pubKey), {}, {\n      namespace\n    }) : pubKey;\n    const metadataResponse = await post(`${this.metadataHost}/get`, params, options, {\n      useAPIKey: true\n    });\n    return metadataResponse.message;\n  }\n}\n\nexport { MetadataStorageLayer };\n"],
  "mappings": "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",
  "names": ["keccak256", "ec$1", "import_elliptic", "ec", "ec$1", "hash", "result", "ec", "ec"]
}
