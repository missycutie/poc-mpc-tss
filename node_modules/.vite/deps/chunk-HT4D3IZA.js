import {
  lookup
} from "./chunk-A4ET6CEC.js";
import {
  decryptData,
  encryptData,
  keccak256
} from "./chunk-UXA7HNRO.js";
import {
  require_elliptic,
  require_loglevel
} from "./chunk-NYBMST6M.js";
import {
  __export,
  __publicField,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/native.js
var native_exports = {};
__export(native_exports, {
  averageResponseTime: () => averageResponseTime,
  canBeUsed: () => canBeUsed,
  close: () => close,
  create: () => create,
  microSeconds: () => microSeconds2,
  onMessage: () => onMessage,
  postMessage: () => postMessage,
  type: () => type
});

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/util.js
var import_loglevel = __toESM(require_loglevel());
function isPromise(obj) {
  if (obj && typeof obj.then === "function") {
    return true;
  } else {
    return false;
  }
}
Promise.resolve(false);
Promise.resolve(true);
var PROMISE_RESOLVED_VOID = Promise.resolve();
function sleep(time, resolveWith) {
  if (!time) time = 0;
  return new Promise((res) => setTimeout(() => res(resolveWith), time));
}
function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}
function randomToken() {
  return Math.random().toString(36).substring(2);
}
var lastMs = 0;
function microSeconds() {
  let ret = Date.now() * 1e3;
  if (ret <= lastMs) {
    ret = lastMs + 1;
  }
  lastMs = ret;
  return ret;
}
var log = import_loglevel.default.getLogger("broadcast-channel");
log.setLevel("error");

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/native.js
var microSeconds2 = microSeconds;
var type = "native";
function create(channelName) {
  const state = {
    time: microSeconds(),
    messagesCallback: null,
    bc: new BroadcastChannel(channelName),
    subFns: []
    // subscriberFunctions
  };
  state.bc.onmessage = (msg) => {
    if (state.messagesCallback) {
      state.messagesCallback(msg.data);
    }
  };
  return state;
}
function close(channelState) {
  channelState.bc.close();
  channelState.subFns = [];
}
function postMessage(channelState, messageJson) {
  try {
    channelState.bc.postMessage(messageJson, false);
    return PROMISE_RESOLVED_VOID;
  } catch (err) {
    return Promise.reject(err);
  }
}
function onMessage(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed() {
  if (typeof window === "undefined") return false;
  if (typeof BroadcastChannel === "function") {
    if (BroadcastChannel._pubkey) {
      throw new Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
    }
    return true;
  } else return false;
}
function averageResponseTime() {
  return 150;
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/indexed-db.js
var indexed_db_exports = {};
__export(indexed_db_exports, {
  TRANSACTION_SETTINGS: () => TRANSACTION_SETTINGS,
  averageResponseTime: () => averageResponseTime2,
  canBeUsed: () => canBeUsed2,
  cleanOldMessages: () => cleanOldMessages,
  close: () => close2,
  commitIndexedDBTransaction: () => commitIndexedDBTransaction,
  create: () => create2,
  createDatabase: () => createDatabase,
  getAllMessages: () => getAllMessages,
  getIdb: () => getIdb,
  getMessagesHigherThan: () => getMessagesHigherThan,
  getOldMessages: () => getOldMessages,
  microSeconds: () => microSeconds3,
  onMessage: () => onMessage2,
  postMessage: () => postMessage2,
  removeMessagesById: () => removeMessagesById,
  type: () => type2,
  writeMessage: () => writeMessage
});

// node_modules/oblivious-set/dist/esm/src/index.js
var ObliviousSet = class {
  constructor(ttl) {
    __publicField(this, "ttl");
    __publicField(this, "map", /* @__PURE__ */ new Map());
    /**
     * Creating calls to setTimeout() is expensive,
     * so we only do that if there is not timeout already open.
     */
    __publicField(this, "_to", false);
    this.ttl = ttl;
  }
  has(value) {
    return this.map.has(value);
  }
  add(value) {
    this.map.set(value, now());
    if (!this._to) {
      this._to = true;
      setTimeout(() => {
        this._to = false;
        removeTooOldValues(this);
      }, 0);
    }
  }
  clear() {
    this.map.clear();
  }
};
function removeTooOldValues(obliviousSet) {
  const olderThen = now() - obliviousSet.ttl;
  const iterator = obliviousSet.map[Symbol.iterator]();
  while (true) {
    const next = iterator.next().value;
    if (!next) {
      return;
    }
    const value = next[0];
    const time = next[1];
    if (time < olderThen) {
      obliviousSet.map.delete(value);
    } else {
      return;
    }
  }
}
function now() {
  return Date.now();
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/options.js
function fillOptionsWithDefaults(originalOptions = {}) {
  const options = JSON.parse(JSON.stringify(originalOptions));
  if (typeof options.webWorkerSupport === "undefined") options.webWorkerSupport = true;
  if (!options.idb) options.idb = {};
  if (!options.idb.ttl) options.idb.ttl = 1e3 * 45;
  if (!options.idb.fallbackInterval) options.idb.fallbackInterval = 150;
  if (originalOptions.idb && typeof originalOptions.idb.onclose === "function") options.idb.onclose = originalOptions.idb.onclose;
  if (!options.localstorage) options.localstorage = {};
  if (!options.localstorage.removeTimeout) options.localstorage.removeTimeout = 1e3 * 60;
  if (!options.server) options.server = {};
  if (!options.server.url) options.server.url = "https://session.web3auth.io";
  if (!options.server.removeTimeout) options.server.removeTimeout = 1e3 * 60 * 5;
  if (originalOptions.methods) options.methods = originalOptions.methods;
  return options;
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/indexed-db.js
var microSeconds3 = microSeconds;
var DB_PREFIX = "pubkey.broadcast-channel-0-";
var OBJECT_STORE_ID = "messages";
var TRANSACTION_SETTINGS = {
  durability: "relaxed"
};
var type2 = "idb";
function getIdb() {
  if (typeof indexedDB !== "undefined") return indexedDB;
  if (typeof window !== "undefined") {
    if (typeof window.mozIndexedDB !== "undefined") return window.mozIndexedDB;
    if (typeof window.webkitIndexedDB !== "undefined") return window.webkitIndexedDB;
    if (typeof window.msIndexedDB !== "undefined") return window.msIndexedDB;
  }
  return false;
}
function commitIndexedDBTransaction(tx) {
  if (tx.commit) {
    tx.commit();
  }
}
function createDatabase(channelName) {
  const IndexedDB = getIdb();
  const dbName = DB_PREFIX + channelName;
  const openRequest = IndexedDB.open(dbName);
  openRequest.onupgradeneeded = (ev) => {
    const db = ev.target.result;
    db.createObjectStore(OBJECT_STORE_ID, {
      keyPath: "id",
      autoIncrement: true
    });
  };
  const dbPromise = new Promise((res, rej) => {
    openRequest.onerror = (ev) => rej(ev);
    openRequest.onsuccess = () => {
      res(openRequest.result);
    };
  });
  return dbPromise;
}
function writeMessage(db, readerUuid, messageJson) {
  const time = Date.now();
  const writeObject = {
    uuid: readerUuid,
    time,
    data: messageJson
  };
  const tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  return new Promise((res, rej) => {
    tx.oncomplete = () => res();
    tx.onerror = (ev) => rej(ev);
    const objectStore = tx.objectStore(OBJECT_STORE_ID);
    objectStore.add(writeObject);
    commitIndexedDBTransaction(tx);
  });
}
function getAllMessages(db) {
  const tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  const objectStore = tx.objectStore(OBJECT_STORE_ID);
  const ret = [];
  return new Promise((res) => {
    objectStore.openCursor().onsuccess = (ev) => {
      const cursor = ev.target.result;
      if (cursor) {
        ret.push(cursor.value);
        cursor.continue();
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function getMessagesHigherThan(db, lastCursorId) {
  const tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  const objectStore = tx.objectStore(OBJECT_STORE_ID);
  const ret = [];
  let keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
  if (objectStore.getAll) {
    const getAllRequest = objectStore.getAll(keyRangeValue);
    return new Promise((res, rej) => {
      getAllRequest.onerror = (err) => rej(err);
      getAllRequest.onsuccess = function(e) {
        res(e.target.result);
      };
    });
  }
  function openCursor() {
    try {
      keyRangeValue = IDBKeyRange.bound(lastCursorId + 1, Infinity);
      return objectStore.openCursor(keyRangeValue);
    } catch (e) {
      return objectStore.openCursor();
    }
  }
  return new Promise((res, rej) => {
    const openCursorRequest = openCursor();
    openCursorRequest.onerror = (err) => rej(err);
    openCursorRequest.onsuccess = (ev) => {
      const cursor = ev.target.result;
      if (cursor) {
        if (cursor.value.id < lastCursorId + 1) {
          cursor.continue(lastCursorId + 1);
        } else {
          ret.push(cursor.value);
          cursor.continue();
        }
      } else {
        commitIndexedDBTransaction(tx);
        res(ret);
      }
    };
  });
}
function removeMessagesById(db, ids) {
  const tx = db.transaction([OBJECT_STORE_ID], "readwrite", TRANSACTION_SETTINGS);
  const objectStore = tx.objectStore(OBJECT_STORE_ID);
  return Promise.all(ids.map((id) => {
    const deleteRequest = objectStore.delete(id);
    return new Promise((res) => {
      deleteRequest.onsuccess = () => res();
    });
  }));
}
function getOldMessages(db, ttl) {
  const olderThen = Date.now() - ttl;
  const tx = db.transaction(OBJECT_STORE_ID, "readonly", TRANSACTION_SETTINGS);
  const objectStore = tx.objectStore(OBJECT_STORE_ID);
  const ret = [];
  return new Promise((res) => {
    objectStore.openCursor().onsuccess = (ev) => {
      const cursor = ev.target.result;
      if (cursor) {
        const msgObk = cursor.value;
        if (msgObk.time < olderThen) {
          ret.push(msgObk);
          cursor.continue();
        } else {
          commitIndexedDBTransaction(tx);
          res(ret);
          return;
        }
      } else {
        res(ret);
      }
    };
  });
}
function cleanOldMessages(db, ttl) {
  return getOldMessages(db, ttl).then((tooOld) => {
    return removeMessagesById(db, tooOld.map((msg) => msg.id));
  });
}
function create2(channelName, options) {
  options = fillOptionsWithDefaults(options);
  return createDatabase(channelName).then((db) => {
    const state = {
      closed: false,
      lastCursorId: 0,
      channelName,
      options,
      uuid: randomToken(),
      /**
       * emittedMessagesIds
       * contains all messages that have been emitted before
       * @type {ObliviousSet}
       */
      eMIs: new ObliviousSet(options.idb.ttl * 2),
      // ensures we do not read messages in parrallel
      writeBlockPromise: PROMISE_RESOLVED_VOID,
      messagesCallback: null,
      readQueuePromises: [],
      db,
      time: microSeconds()
    };
    db.onclose = function() {
      state.closed = true;
      if (options.idb.onclose) options.idb.onclose();
    };
    _readLoop(state);
    return state;
  });
}
function _readLoop(state) {
  if (state.closed) return;
  readNewMessages(state).then(() => sleep(state.options.idb.fallbackInterval)).then(() => _readLoop(state));
}
function _filterMessage(msgObj, state) {
  if (msgObj.uuid === state.uuid) return false;
  if (state.eMIs.has(msgObj.id)) return false;
  if (msgObj.data.time < state.messagesCallbackTime) return false;
  return true;
}
function readNewMessages(state) {
  if (state.closed) return PROMISE_RESOLVED_VOID;
  if (!state.messagesCallback) return PROMISE_RESOLVED_VOID;
  return getMessagesHigherThan(state.db, state.lastCursorId).then((newerMessages) => {
    const useMessages = newerMessages.filter((msgObj) => !!msgObj).map((msgObj) => {
      if (msgObj.id > state.lastCursorId) {
        state.lastCursorId = msgObj.id;
      }
      return msgObj;
    }).filter((msgObj) => _filterMessage(msgObj, state)).sort((msgObjA, msgObjB) => msgObjA.time - msgObjB.time);
    useMessages.forEach((msgObj) => {
      if (state.messagesCallback) {
        state.eMIs.add(msgObj.id);
        state.messagesCallback(msgObj.data);
      }
    });
    return PROMISE_RESOLVED_VOID;
  });
}
function close2(channelState) {
  channelState.closed = true;
  channelState.db.close();
}
function postMessage2(channelState, messageJson) {
  channelState.writeBlockPromise = channelState.writeBlockPromise.then(() => writeMessage(channelState.db, channelState.uuid, messageJson)).then(() => {
    if (randomInt(0, 10) === 0) {
      cleanOldMessages(channelState.db, channelState.options.idb.ttl);
    }
  });
  return channelState.writeBlockPromise;
}
function onMessage2(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
  readNewMessages(channelState);
}
function canBeUsed2() {
  const idb = getIdb();
  if (!idb) return false;
  return true;
}
function averageResponseTime2(options) {
  return options.idb.fallbackInterval * 2;
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/localstorage.js
var localstorage_exports = {};
__export(localstorage_exports, {
  addStorageEventListener: () => addStorageEventListener,
  averageResponseTime: () => averageResponseTime3,
  canBeUsed: () => canBeUsed3,
  close: () => close3,
  create: () => create3,
  getLocalStorage: () => getLocalStorage,
  microSeconds: () => microSeconds4,
  onMessage: () => onMessage3,
  postMessage: () => postMessage3,
  removeStorageEventListener: () => removeStorageEventListener,
  storageKey: () => storageKey,
  type: () => type3
});
var microSeconds4 = microSeconds;
var KEY_PREFIX = "pubkey.broadcastChannel-";
var type3 = "localstorage";
function getLocalStorage() {
  let localStorage;
  if (typeof window === "undefined") return null;
  try {
    localStorage = window.localStorage;
    localStorage = window["ie8-eventlistener/storage"] || window.localStorage;
  } catch (e) {
  }
  return localStorage;
}
function storageKey(channelName) {
  return KEY_PREFIX + channelName;
}
function postMessage3(channelState, messageJson) {
  return new Promise((res) => {
    sleep().then(() => {
      const key = storageKey(channelState.channelName);
      const writeObj = {
        token: randomToken(),
        time: Date.now(),
        data: messageJson,
        uuid: channelState.uuid
      };
      const value = JSON.stringify(writeObj);
      getLocalStorage().setItem(key, value);
      const ev = document.createEvent("Event");
      ev.initEvent("storage", true, true);
      ev.key = key;
      ev.newValue = value;
      window.dispatchEvent(ev);
      res();
    });
  });
}
function addStorageEventListener(channelName, fn) {
  const key = storageKey(channelName);
  const listener = (ev) => {
    if (ev.key === key) {
      fn(JSON.parse(ev.newValue));
    }
  };
  window.addEventListener("storage", listener);
  return listener;
}
function removeStorageEventListener(listener) {
  window.removeEventListener("storage", listener);
}
function create3(channelName, options) {
  options = fillOptionsWithDefaults(options);
  if (!canBeUsed3()) {
    throw new Error("BroadcastChannel: localstorage cannot be used");
  }
  const uuid = randomToken();
  const eMIs = new ObliviousSet(options.localstorage.removeTimeout);
  const state = {
    channelName,
    uuid,
    time: microSeconds(),
    eMIs
    // emittedMessagesIds
  };
  state.listener = addStorageEventListener(channelName, (msgObj) => {
    if (!state.messagesCallback) return;
    if (msgObj.uuid === uuid) return;
    if (!msgObj.token || eMIs.has(msgObj.token)) return;
    if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return;
    eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  return state;
}
function close3(channelState) {
  removeStorageEventListener(channelState.listener);
}
function onMessage3(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed3() {
  const ls = getLocalStorage();
  if (!ls) return false;
  try {
    const key = "__broadcastchannel_check";
    ls.setItem(key, "works");
    ls.removeItem(key);
  } catch (e) {
    return false;
  }
  return true;
}
function averageResponseTime3() {
  const defaultTime = 120;
  const userAgent = navigator.userAgent.toLowerCase();
  if (userAgent.includes("safari") && !userAgent.includes("chrome")) {
    return defaultTime * 2;
  }
  return defaultTime;
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/server.js
var server_exports = {};
__export(server_exports, {
  averageResponseTime: () => averageResponseTime4,
  canBeUsed: () => canBeUsed4,
  close: () => close4,
  create: () => create4,
  getSocketInstance: () => getSocketInstance,
  microSeconds: () => microSeconds5,
  onMessage: () => onMessage4,
  postMessage: () => postMessage4,
  removeStorageEventListener: () => removeStorageEventListener2,
  setupSocketConnection: () => setupSocketConnection,
  storageKey: () => storageKey2,
  type: () => type4
});

// node_modules/@toruslabs/broadcast-channel/node_modules/@toruslabs/eccrypto/dist/lib.esm/index.js
var import_elliptic = __toESM(require_elliptic());
var ec = new import_elliptic.ec("secp256k1");
var browserCrypto = globalThis.crypto || globalThis.msCrypto || {};
var subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
var EC_GROUP_ORDER = Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", "hex");
var ZERO32 = Buffer.alloc(32, 0);
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isScalar(x) {
  return Buffer.isBuffer(x) && x.length === 32;
}
function isValidPrivateKey(privateKey) {
  if (!isScalar(privateKey)) {
    return false;
  }
  return privateKey.compare(ZERO32) > 0 && // > 0
  privateKey.compare(EC_GROUP_ORDER) < 0;
}
function getAes(op) {
  return async function(iv, key, data) {
    if (subtle && subtle[op] && subtle.importKey) {
      const importAlgorithm = {
        name: "AES-CBC"
      };
      const cryptoKey = await subtle.importKey("raw", key, importAlgorithm, false, [op]);
      const encAlgorithm = {
        name: "AES-CBC",
        iv
      };
      const result = await subtle[op](encAlgorithm, cryptoKey, data);
      return Buffer.from(new Uint8Array(result));
    } else if (op === "encrypt" && browserCrypto.createCipheriv) {
      const cipher = browserCrypto.createCipheriv("aes-256-cbc", key, iv);
      const firstChunk = cipher.update(data);
      const secondChunk = cipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    } else if (op === "decrypt" && browserCrypto.createDecipheriv) {
      const decipher = browserCrypto.createDecipheriv("aes-256-cbc", key, iv);
      const firstChunk = decipher.update(data);
      const secondChunk = decipher.final();
      return Buffer.concat([firstChunk, secondChunk]);
    }
    throw new Error(`Unsupported operation: ${op}`);
  };
}
var aesCbcEncrypt = getAes("encrypt");
var aesCbcDecrypt = getAes("decrypt");
var getPublic = function(privateKey) {
  assert(privateKey.length === 32, "Bad private key");
  assert(isValidPrivateKey(privateKey), "Bad private key");
  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic("array"));
};
var sign = async function(privateKey, msg) {
  assert(privateKey.length === 32, "Bad private key");
  assert(isValidPrivateKey(privateKey), "Bad private key");
  assert(msg.length > 0, "Message should not be empty");
  assert(msg.length <= 32, "Message is too long");
  return Buffer.from(ec.sign(msg, privateKey, {
    canonical: true
  }).toDER());
};

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/server.js
var microSeconds5 = microSeconds;
var KEY_PREFIX2 = "pubkey.broadcastChannel-";
var type4 = "server";
var SOCKET_CONN_INSTANCE = null;
var runningChannels = /* @__PURE__ */ new Set();
function storageKey2(channelName) {
  return KEY_PREFIX2 + channelName;
}
function postMessage4(channelState, messageJson) {
  return new Promise((res, rej) => {
    sleep().then(async () => {
      const key = storageKey2(channelState.channelName);
      const channelEncPrivKey = keccak256(Buffer.from(key, "utf8"));
      const encData = await encryptData(channelEncPrivKey.toString("hex"), {
        token: randomToken(),
        time: Date.now(),
        data: messageJson,
        uuid: channelState.uuid
      });
      const body = {
        sameOriginCheck: true,
        sameIpCheck: true,
        key: getPublic(channelEncPrivKey).toString("hex"),
        data: encData,
        signature: (await sign(channelEncPrivKey, keccak256(Buffer.from(encData, "utf8")))).toString("hex")
      };
      if (channelState.timeout) body.timeout = channelState.timeout;
      return fetch(channelState.serverUrl + "/channel/set", {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          "Content-Type": "application/json; charset=utf-8"
        }
      }).then(res).catch(rej);
    });
  });
}
function getSocketInstance(serverUrl) {
  if (SOCKET_CONN_INSTANCE) {
    return SOCKET_CONN_INSTANCE;
  }
  const SOCKET_CONN = lookup(serverUrl, {
    transports: ["websocket", "polling"],
    // use WebSocket first, if available
    withCredentials: true,
    reconnectionDelayMax: 1e4,
    reconnectionAttempts: 10
  });
  SOCKET_CONN.on("connect_error", (err) => {
    SOCKET_CONN.io.opts.transports = ["polling", "websocket"];
    log.error("connect error", err);
  });
  SOCKET_CONN.on("connect", async () => {
    const {
      engine
    } = SOCKET_CONN.io;
    log.debug("initially connected to", engine.transport.name);
    engine.once("upgrade", () => {
      log.debug("upgraded", engine.transport.name);
    });
    engine.once("close", (reason) => {
      log.debug("connection closed", reason);
    });
  });
  SOCKET_CONN.on("error", (err) => {
    log.error("socket errored", err);
    SOCKET_CONN.disconnect();
  });
  SOCKET_CONN_INSTANCE = SOCKET_CONN;
  return SOCKET_CONN;
}
function setupSocketConnection(serverUrl, channelState, fn) {
  const socketConn = getSocketInstance(serverUrl);
  const key = storageKey2(channelState.channelName);
  const channelEncPrivKey = keccak256(Buffer.from(key, "utf8"));
  const channelPubKey = getPublic(channelEncPrivKey).toString("hex");
  if (socketConn.connected) {
    socketConn.emit("check_auth_status", channelPubKey, {
      sameOriginCheck: true,
      sameIpCheck: true
    });
  } else {
    socketConn.once("connect", () => {
      log.debug("connected with socket");
      socketConn.emit("check_auth_status", channelPubKey, {
        sameOriginCheck: true,
        sameIpCheck: true
      });
    });
  }
  const reconnect = () => {
    socketConn.once("connect", async () => {
      if (runningChannels.has(channelState.channelName)) {
        socketConn.emit("check_auth_status", channelPubKey, {
          sameOriginCheck: true,
          sameIpCheck: true
        });
      }
    });
  };
  const visibilityListener = () => {
    if (!socketConn || !runningChannels.has(channelState.channelName)) {
      document.removeEventListener("visibilitychange", visibilityListener);
      return;
    }
    if (!socketConn.connected && document.visibilityState === "visible") {
      reconnect();
    }
  };
  const listener = async (ev) => {
    try {
      const decData = await decryptData(channelEncPrivKey.toString("hex"), ev);
      log.info(decData);
      fn(decData);
    } catch (error) {
      log.error(error);
    }
  };
  socketConn.on("disconnect", () => {
    log.debug("socket disconnected");
    if (runningChannels.has(channelState.channelName)) {
      log.error("socket disconnected unexpectedly, reconnecting socket");
      reconnect();
    }
  });
  socketConn.on(`${channelPubKey}_success`, listener);
  if (typeof document !== "undefined") document.addEventListener("visibilitychange", visibilityListener);
  return socketConn;
}
function removeStorageEventListener2() {
  if (SOCKET_CONN_INSTANCE) {
    SOCKET_CONN_INSTANCE.disconnect();
  }
}
function create4(channelName, options) {
  options = fillOptionsWithDefaults(options);
  const uuid = randomToken();
  const eMIs = new ObliviousSet(options.server.removeTimeout);
  const state = {
    channelName,
    uuid,
    eMIs,
    // emittedMessagesIds
    serverUrl: options.server.url,
    time: microSeconds()
  };
  if (options.server.timeout) state.timeout = options.server.timeout;
  setupSocketConnection(options.server.url, state, (msgObj) => {
    if (!state.messagesCallback) return;
    if (msgObj.uuid === state.uuid) return;
    if (!msgObj.token || state.eMIs.has(msgObj.token)) return;
    state.eMIs.add(msgObj.token);
    state.messagesCallback(msgObj.data);
  });
  runningChannels.add(channelName);
  return state;
}
function close4(channelState) {
  runningChannels.delete(channelState.channelName);
}
function onMessage4(channelState, fn, time) {
  channelState.messagesCallbackTime = time;
  channelState.messagesCallback = fn;
}
function canBeUsed4() {
  return true;
}
function averageResponseTime4() {
  const defaultTime = 500;
  return defaultTime;
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/methods/simulate.js
var simulate_exports = {};
__export(simulate_exports, {
  SIMULATE_DELAY_TIME: () => SIMULATE_DELAY_TIME,
  averageResponseTime: () => averageResponseTime5,
  canBeUsed: () => canBeUsed5,
  close: () => close5,
  create: () => create5,
  microSeconds: () => microSeconds6,
  onMessage: () => onMessage5,
  postMessage: () => postMessage5,
  type: () => type5
});
var microSeconds6 = microSeconds;
var type5 = "simulate";
var SIMULATE_CHANNELS = /* @__PURE__ */ new Set();
var SIMULATE_DELAY_TIME = 5;
function create5(channelName) {
  const state = {
    time: microSeconds(),
    name: channelName,
    messagesCallback: null
  };
  SIMULATE_CHANNELS.add(state);
  return state;
}
function close5(channelState) {
  SIMULATE_CHANNELS.delete(channelState);
}
function postMessage5(channelState, messageJson) {
  return new Promise((res) => setTimeout(() => {
    const channelArray = Array.from(SIMULATE_CHANNELS);
    channelArray.forEach((channel) => {
      if (channel.name === channelState.name && // has same name
      channel !== channelState && // not own channel
      !!channel.messagesCallback && // has subscribers
      channel.time < messageJson.time) {
        channel.messagesCallback(messageJson);
      }
    });
    res();
  }, SIMULATE_DELAY_TIME));
}
function onMessage5(channelState, fn) {
  channelState.messagesCallback = fn;
}
function canBeUsed5() {
  return true;
}
function averageResponseTime5() {
  return SIMULATE_DELAY_TIME;
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/method-chooser.js
var METHODS = [
  native_exports,
  // fastest
  indexed_db_exports,
  localstorage_exports,
  server_exports
];
function chooseMethod(options) {
  let chooseMethods = [].concat(options.methods, METHODS).filter(Boolean);
  if (options.type) {
    if (options.type === "simulate") {
      return simulate_exports;
    }
    const ret = chooseMethods.find((m) => m.type === options.type);
    if (!ret) throw new Error("method-type " + options.type + " not found");
    else return ret;
  }
  if (!options.webWorkerSupport) {
    chooseMethods = chooseMethods.filter((m) => m.type !== "idb");
  }
  const useMethod = chooseMethods.find((method) => method.canBeUsed(options));
  if (!useMethod) throw new Error(`No useable method found in ${JSON.stringify(METHODS.map((m) => m.type))}`);
  else return useMethod;
}

// node_modules/@toruslabs/broadcast-channel/dist/lib.esm/broadcast-channel.js
var OPEN_BROADCAST_CHANNELS = /* @__PURE__ */ new Set();
var lastId = 0;
var BroadcastChannel2 = function(name, options) {
  this.id = lastId++;
  OPEN_BROADCAST_CHANNELS.add(this);
  this.name = name;
  if (ENFORCED_OPTIONS) {
    options = ENFORCED_OPTIONS;
  }
  this.options = fillOptionsWithDefaults(options);
  this.method = chooseMethod(this.options);
  this._iL = false;
  this._onML = null;
  this._addEL = {
    message: [],
    internal: []
  };
  this._uMP = /* @__PURE__ */ new Set();
  this._befC = [];
  this._prepP = null;
  _prepareChannel(this);
};
BroadcastChannel2._pubkey = true;
var ENFORCED_OPTIONS;
function enforceOptions(options) {
  ENFORCED_OPTIONS = options;
}
BroadcastChannel2.prototype = {
  postMessage(msg) {
    if (this.closed) {
      throw new Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + /**
       * In the past when this error appeared, it was realy hard to debug.
       * So now we log the msg together with the error so it at least
       * gives some clue about where in your application this happens.
       */
      JSON.stringify(msg));
    }
    return _post(this, "message", msg);
  },
  postInternal(msg) {
    return _post(this, "internal", msg);
  },
  set onmessage(fn) {
    const time = this.method.microSeconds();
    const listenObj = {
      time,
      fn
    };
    _removeListenerObject(this, "message", this._onML);
    if (fn && typeof fn === "function") {
      this._onML = listenObj;
      _addListenerObject(this, "message", listenObj);
    } else {
      this._onML = null;
    }
  },
  addEventListener(type6, fn) {
    const time = this.method.microSeconds();
    const listenObj = {
      time,
      fn
    };
    _addListenerObject(this, type6, listenObj);
  },
  removeEventListener(type6, fn) {
    const obj = this._addEL[type6].find((obj2) => obj2.fn === fn);
    _removeListenerObject(this, type6, obj);
  },
  close() {
    if (this.closed) {
      return;
    }
    OPEN_BROADCAST_CHANNELS.delete(this);
    this.closed = true;
    const awaitPrepare = this._prepP ? this._prepP : PROMISE_RESOLVED_VOID;
    this._onML = null;
    this._addEL.message = [];
    return awaitPrepare.then(() => Promise.all(Array.from(this._uMP))).then(() => Promise.all(this._befC.map((fn) => fn()))).then(() => this.method.close(this._state));
  },
  get type() {
    return this.method.type;
  },
  get isClosed() {
    return this.closed;
  }
};
function _post(broadcastChannel, type6, msg) {
  const time = broadcastChannel.method.microSeconds();
  const msgObj = {
    time,
    type: type6,
    data: msg
  };
  const awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : PROMISE_RESOLVED_VOID;
  return awaitPrepare.then(() => {
    const sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj);
    broadcastChannel._uMP.add(sendPromise);
    sendPromise.catch().then(() => broadcastChannel._uMP.delete(sendPromise));
    return sendPromise;
  });
}
function _prepareChannel(channel) {
  const maybePromise = channel.method.create(channel.name, channel.options);
  if (isPromise(maybePromise)) {
    channel._prepP = maybePromise;
    maybePromise.then((s) => {
      channel._state = s;
    });
  } else {
    channel._state = maybePromise;
  }
}
function _hasMessageListeners(channel) {
  if (channel._addEL.message.length > 0) return true;
  if (channel._addEL.internal.length > 0) return true;
  return false;
}
function _addListenerObject(channel, type6, obj) {
  channel._addEL[type6].push(obj);
  _startListening(channel);
}
function _removeListenerObject(channel, type6, obj) {
  channel._addEL[type6] = channel._addEL[type6].filter((o) => o !== obj);
  _stopListening(channel);
}
function _startListening(channel) {
  if (!channel._iL && _hasMessageListeners(channel)) {
    const listenerFn = (msgObj) => {
      channel._addEL[msgObj.type].forEach((listenerObject) => {
        if (msgObj.time >= listenerObject.time) {
          listenerObject.fn(msgObj.data);
        } else if (channel.method.type === "server") {
          listenerObject.fn(msgObj.data);
        }
      });
    };
    const time = channel.method.microSeconds();
    if (channel._prepP) {
      channel._prepP.then(() => {
        channel._iL = true;
        channel.method.onMessage(channel._state, listenerFn, time);
      });
    } else {
      channel._iL = true;
      channel.method.onMessage(channel._state, listenerFn, time);
    }
  }
}
function _stopListening(channel) {
  if (channel._iL && !_hasMessageListeners(channel)) {
    channel._iL = false;
    const time = channel.method.microSeconds();
    channel.method.onMessage(channel._state, null, time);
  }
}

export {
  native_exports,
  indexed_db_exports,
  localstorage_exports,
  server_exports,
  chooseMethod,
  OPEN_BROADCAST_CHANNELS,
  BroadcastChannel2 as BroadcastChannel,
  enforceOptions
};
//# sourceMappingURL=chunk-HT4D3IZA.js.map
